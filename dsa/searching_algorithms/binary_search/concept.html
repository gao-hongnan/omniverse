

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Concept &#8212; Omniverse</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=365ca57ee442770a23c6" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=365ca57ee442770a23c6" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=365ca57ee442770a23c6" />
  <script src="../../../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=365ca57ee442770a23c6"></script>

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'dsa/searching_algorithms/binary_search/concept';</script>
    <link rel="canonical" href="https://www.gaohongnan.com/dsa/searching_algorithms/binary_search/concept.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Koko Eating Bananas" href="problems/875-koko-eating-bananas.html" />
    <link rel="prev" title="Binary Search" href="intro.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.png" class="logo__image only-light" alt="Omniverse - Home"/>
    <script>document.write(`<img src="../../../_static/logo.png" class="logo__image only-dark" alt="Omniverse - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../intro.html">
                    üåå Omniverse: A Journey Through Knowledge
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Data Structures and Algorithms</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../linear_search/intro.html">Linear Search</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../linear_search/concept.html">Concept</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="intro.html">Binary Search</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Concept</a></li>
<li class="toctree-l2"><a class="reference internal" href="problems/875-koko-eating-bananas.html">Koko Eating Bananas</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Linear Algebra</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../linear_algebra/01_preliminaries/intro.html">Preliminaries</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../linear_algebra/01_preliminaries/01-fields.html">Fields</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../linear_algebra/02_vectors/intro.html">Vectors</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../linear_algebra/02_vectors/01-vector-definition.html">Vector and Its Definition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../linear_algebra/02_vectors/02-vector-operation.html">Vector and Its Operations</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References, Resources and Roadmap</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://colab.research.google.com/github/gao-hongnan/Omniverse/blob/main/omniverse/dsa/searching_algorithms/binary_search/concept.md" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onColab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../../../_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/gao-hongnan/Omniverse" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/gao-hongnan/Omniverse/issues/new?title=Issue%20on%20page%20%2Fdsa/searching_algorithms/binary_search/concept.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/dsa/searching_algorithms/binary_search/concept.ipynb" target="_blank"
   class="btn btn-sm btn-download-notebook-button dropdown-item"
   title="Download notebook file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-code"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li><a href="../../../_sources/dsa/searching_algorithms/binary_search/concept.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Concept</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#definition">Definition</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithm-iterative-exact-match">Algorithm (Iterative + Exact Match)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pseudocode-iterative">Pseudocode (Iterative)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-representation-recursive">Mathematical Representation (Recursive)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#explanation">Explanation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#correctness">Correctness</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#example">Example</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualization">Visualization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Explanation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#intuition">Intuition</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#assumptions">Assumptions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#constraints">Constraints</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-left-right-2-may-cause-overflow">Why Left + Right // 2 May Cause Overflow?</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#test-cases">Test Cases</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#edge-cases">Edge Cases</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-iterative-find-the-exact-value">Solution (Iterative - Find the Exact Value)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Intuition</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">Visualization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithm">Algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#claim">Claim</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proof">Proof</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implementation">Implementation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tests">Tests</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#time-complexity">Time Complexity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#space-complexity">Space Complexity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#input-space-complexity">Input Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#auxiliary-space-complexity">Auxiliary Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#total-space-complexity">Total Space Complexity</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-recursive-find-the-exact-value">Solution (Recursive - Find the Exact Value)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">Intuition</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">Visualization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">Algorithm</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pseudocode">Pseudocode</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-representation">Mathematical Representation</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">Claim</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">Proof</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">Implementation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">Tests</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">Time Complexity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#master-theorem">Master Theorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#repeated-substitution">Repeated Substitution</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">Space Complexity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">Input Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">Auxiliary Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">Total Space Complexity</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#when-to-use-binary-search">When to use Binary Search?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-minimize-k-s-t-condition-k-is-true">Solution (Minimize <span class="math notranslate nohighlight">\(k\)</span>, <span class="math notranslate nohighlight">\(s.t.\)</span> condition(<span class="math notranslate nohighlight">\(k\)</span>) is True)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references-and-further-readings">References and Further Readings</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="concept">
<h1>Concept<a class="headerlink" href="#concept" title="Permalink to this heading">#</a></h1>
<p><a class="reference external" href="https://colab.research.google.com/github/gao-hongnan/gaohn-dsa/blob/main/content/searching_algorithms/binary_search/concept.ipynb"><img alt="Open in Colab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a></p>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id20">Introduction</a></p></li>
<li><p><a class="reference internal" href="#definition" id="id21">Definition</a></p></li>
<li><p><a class="reference internal" href="#algorithm-iterative-exact-match" id="id22">Algorithm (Iterative + Exact Match)</a></p>
<ul>
<li><p><a class="reference internal" href="#pseudocode-iterative" id="id23">Pseudocode (Iterative)</a></p></li>
<li><p><a class="reference internal" href="#mathematical-representation-recursive" id="id24">Mathematical Representation (Recursive)</a></p></li>
<li><p><a class="reference internal" href="#explanation" id="id25">Explanation</a></p></li>
<li><p><a class="reference internal" href="#correctness" id="id26">Correctness</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#example" id="id27">Example</a></p>
<ul>
<li><p><a class="reference internal" href="#visualization" id="id28">Visualization</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id29">Explanation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#intuition" id="id30">Intuition</a></p></li>
<li><p><a class="reference internal" href="#assumptions" id="id31">Assumptions</a></p></li>
<li><p><a class="reference internal" href="#constraints" id="id32">Constraints</a></p>
<ul>
<li><p><a class="reference internal" href="#why-left-right-2-may-cause-overflow" id="id33">Why Left + Right // 2 May Cause Overflow?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#test-cases" id="id34">Test Cases</a></p></li>
<li><p><a class="reference internal" href="#edge-cases" id="id35">Edge Cases</a></p></li>
<li><p><a class="reference internal" href="#solution-iterative-find-the-exact-value" id="id36">Solution (Iterative - Find the Exact Value)</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id37">Intuition</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id38">Visualization</a></p></li>
<li><p><a class="reference internal" href="#algorithm" id="id39">Algorithm</a></p></li>
<li><p><a class="reference internal" href="#claim" id="id40">Claim</a></p></li>
<li><p><a class="reference internal" href="#proof" id="id41">Proof</a></p></li>
<li><p><a class="reference internal" href="#implementation" id="id42">Implementation</a></p></li>
<li><p><a class="reference internal" href="#tests" id="id43">Tests</a></p></li>
<li><p><a class="reference internal" href="#time-complexity" id="id44">Time Complexity</a></p></li>
<li><p><a class="reference internal" href="#space-complexity" id="id45">Space Complexity</a></p>
<ul>
<li><p><a class="reference internal" href="#input-space-complexity" id="id46">Input Space Complexity</a></p></li>
<li><p><a class="reference internal" href="#auxiliary-space-complexity" id="id47">Auxiliary Space Complexity</a></p></li>
<li><p><a class="reference internal" href="#total-space-complexity" id="id48">Total Space Complexity</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#solution-recursive-find-the-exact-value" id="id49">Solution (Recursive - Find the Exact Value)</a></p>
<ul>
<li><p><a class="reference internal" href="#id8" id="id50">Intuition</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id51">Visualization</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id52">Algorithm</a></p>
<ul>
<li><p><a class="reference internal" href="#pseudocode" id="id53">Pseudocode</a></p></li>
<li><p><a class="reference internal" href="#mathematical-representation" id="id54">Mathematical Representation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id11" id="id55">Claim</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id56">Proof</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id57">Implementation</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id58">Tests</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id59">Time Complexity</a></p>
<ul>
<li><p><a class="reference internal" href="#master-theorem" id="id60">Master Theorem</a></p></li>
<li><p><a class="reference internal" href="#repeated-substitution" id="id61">Repeated Substitution</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id16" id="id62">Space Complexity</a></p>
<ul>
<li><p><a class="reference internal" href="#id17" id="id63">Input Space Complexity</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id64">Auxiliary Space Complexity</a></p></li>
<li><p><a class="reference internal" href="#id19" id="id65">Total Space Complexity</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#when-to-use-binary-search" id="id66">When to use Binary Search?</a></p></li>
<li><p><a class="reference internal" href="#solution-minimize-k-s-t-condition-k-is-true" id="id67">Solution (Minimize <span class="math notranslate nohighlight">\(k\)</span>, <span class="math notranslate nohighlight">\(s.t.\)</span> condition(<span class="math notranslate nohighlight">\(k\)</span>) is True)</a></p></li>
<li><p><a class="reference internal" href="#references-and-further-readings" id="id68">References and Further Readings</a></p></li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this heading">#</a></h2>
<p><strong><a class="reference external" href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Binary Search</a></strong> is an
exceptionally efficient
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Search_algorithm">search algorithm</a></strong> used
ubiquitously in computer science. At its heart, binary search is a
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a></strong>
strategy that halves the search space with each iteration, providing a search
efficiency that is
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Logarithmic_time_complexity">logarithmic</a></strong> in
the size of the dataset.</p>
<p>In binary search, the dataset must be in a
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Sorting_algorithm">sorted</a></strong> format, as the
algorithm operates by repeatedly dividing the search interval in half. It starts
with an interval covering the whole array, and if the value of the search key is
less than the middle element of the interval, it narrows the interval to the
lower half. Otherwise, it narrows it to the upper half. Repeatedly, this process
continues until the value is found or the interval is empty.</p>
<p>Binary search can be used not only to find whether a specific value exists in a
sorted array but also to find the position of an insert for a new value to keep
the array sorted. Because of this and its impressive efficiency, it underpins
many fundamental computer science algorithms and data structures, such as
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Binary_search_tree">binary search trees</a></strong> and
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/B-tree">B-trees</a></strong>.</p>
<p>Applications of binary search in computer science are many and varied:</p>
<ul class="simple">
<li><p><strong>Search Algorithms</strong>: Binary search is one of the fundamental search
algorithms, applied when dealing with sorted lists or arrays to find the
existence and position of a particular value.</p></li>
<li><p><strong>Database and File-System Indexing</strong>: Many
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Database_index">database indexing</a></strong>
techniques use structures like B-trees and binary search trees, which at their
core use a binary search approach for efficiently locating records.</p></li>
<li><p><strong>Numerical Computation</strong>: Binary search is used in
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Numerical_analysis">numeric computations</a></strong>
for tasks like
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Root-finding_algorithm">root-finding</a></strong> or
for implementing
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Mathematical_optimization">numerical optimization</a></strong>
algorithms.</p></li>
<li><p><strong>Version Control Systems</strong>: In
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Version_control">software version control systems</a></strong>,
binary search is used in ‚Äúbisecting‚Äù, which is a method to find which commit
introduced a particular bug.</p></li>
<li><p><strong>Memory Management</strong>: In
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Memory_management">memory management</a></strong>
tasks, binary search is often used to search in address spaces and page tables
in a fast and efficient way.</p></li>
</ul>
<p>Mastering binary search is essential for any aspiring computer science
professional or software developer, as it forms the backbone of many algorithms
and data structures and its understanding provides insight into how to manage
and utilize data effectively. For a more comprehensive understanding of binary
search, you can visit its
<a class="reference external" href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Wikipedia</a> page.</p>
</section>
<section id="definition">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Definition</a><a class="headerlink" href="#definition" title="Permalink to this heading">#</a></h2>
<p>There is really not much to the definition of binary search. The bulk of the
definition exists in the algorithm itself, which we‚Äôll cover in the next few
sections.</p>
</section>
<section id="algorithm-iterative-exact-match">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">Algorithm (Iterative + Exact Match)</a><a class="headerlink" href="#algorithm-iterative-exact-match" title="Permalink to this heading">#</a></h2>
<p>As per leetcode, this algorithm is the most generic version and is an exact
match. See
<a class="reference external" href="https://leetcode.com/explore/learn/card/binary-search/125/template-i">here</a>.</p>
<p>We will check some more variants later.</p>
<section id="pseudocode-iterative">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Pseudocode (Iterative)</a><a class="headerlink" href="#pseudocode-iterative" title="Permalink to this heading">#</a></h3>
<div class="proof algorithm admonition" id="binary-search-pseudocode">
<p class="admonition-title"><span class="caption-number">Algorithm 3 </span> (Pseudocode)</p>
<section class="algorithm-content" id="proof-content">
<p>Algorithm: <code class="docutils literal notranslate"><span class="pre">binarySearch(nums,</span> <span class="pre">target)</span></code></p>
<p>Input: <code class="docutils literal notranslate"><span class="pre">nums</span></code> (sorted array of integers), <code class="docutils literal notranslate"><span class="pre">target</span></code> (integer to search for)</p>
<p>Output: <code class="docutils literal notranslate"><span class="pre">index</span></code> (index of the target in the array, or -1 if not found)</p>
<p>Binary search operates on a sorted array. It starts by comparing the target
value with the middle element of the array. If the target equals this middle
element, the position of this element in the array is returned. If the target is
less than the middle element, the search continues in the lower half of the
array. If the target is greater than the middle element, the search continues in
the upper half of the array. By doing this, the algorithm eliminates the half of
the array in which the target cannot lie in each iteration.</p>
<p>Given an array <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> of <span class="math notranslate nohighlight">\(n\)</span> elements with values or records
<span class="math notranslate nohighlight">\(A_0, A_1, \dots, A_{n-1}\)</span>, sorted such that
<span class="math notranslate nohighlight">\(A_0 \leq A_1 \leq \dots \leq A_{n-1}\)</span>, and target value <span class="math notranslate nohighlight">\(T\)</span>, the following
subroutine uses binary search to find the index of <span class="math notranslate nohighlight">\(T\)</span> in <span class="math notranslate nohighlight">\(\mathcal{A}\)</span>.</p>
<ol class="arabic simple">
<li><p>Set <span class="math notranslate nohighlight">\(L\)</span> to 0 and <span class="math notranslate nohighlight">\(R\)</span> to <span class="math notranslate nohighlight">\(n-1\)</span> (the indices of the leftmost and rightmost
elements of the array).</p></li>
<li><p>If <span class="math notranslate nohighlight">\(L &gt; R\)</span>, the search terminates as unsuccessful, return -1. In other words,
here is while <span class="math notranslate nohighlight">\(L \leq R\)</span>.</p></li>
<li><p>Set <span class="math notranslate nohighlight">\(m\)</span> to the floor of <span class="math notranslate nohighlight">\((L + R) / 2\)</span> (the index of the middle element of the
array). In other words, <span class="math notranslate nohighlight">\(m = \lfloor \frac{L + R}{2} \rfloor\)</span>. In the event
where the length of the array <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is odd, then <span class="math notranslate nohighlight">\(m\)</span> will be the index
of the
middle element (exactly middle). In the event where the length of the array
<span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is even, then <span class="math notranslate nohighlight">\(m\)</span> will be the index of the leftmost element of
the right
half. In practice, to avoid overflow, use
<span class="math notranslate nohighlight">\(m = L + \lfloor \frac{R - L}{2} \rfloor\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(A_m &lt; T\)</span>, set <span class="math notranslate nohighlight">\(L\)</span> to <span class="math notranslate nohighlight">\(m + 1\)</span> and go to step 2.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(A_m &gt; T\)</span>, set <span class="math notranslate nohighlight">\(R\)</span> to <span class="math notranslate nohighlight">\(m - 1\)</span> and go to step 2.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(A_m = T\)</span>, the search is done; return <span class="math notranslate nohighlight">\(m\)</span>.</p></li>
</ol>
<p>The pseudocode for the binary search algorithm is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">T</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">R</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">L</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">L</span> <span class="o">+</span> <span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="n">L</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">A</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</section>
</div><p>Note that we can use the ceiling function in step 3. This may change the result
if the target value appears more than once in the array.</p>
</section>
<section id="mathematical-representation-recursive">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">Mathematical Representation (Recursive)</a><a class="headerlink" href="#mathematical-representation-recursive" title="Permalink to this heading">#</a></h3>
<p>The binary search algorithm is a divide-and-conquer algorithm that halves the
search space at each step. It can be formally described using the notation for
sequences, with <span class="math notranslate nohighlight">\(a\)</span> representing the sequence (i.e., the array), <span class="math notranslate nohighlight">\(n\)</span>
representing the length of the sequence, <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> representing the low and
high indices of the search space, and <span class="math notranslate nohighlight">\(m\)</span> representing the midpoint.</p>
<p>Here‚Äôs a rigorous mathematical version for binary search:</p>
<div class="proof algorithm admonition" id="binary-search-mathematical-representation">
<p class="admonition-title"><span class="caption-number">Algorithm 4 </span> (Mathematical Representation)</p>
<section class="algorithm-content" id="proof-content">
<p>Define the function <span class="math notranslate nohighlight">\(f: (\mathcal{A}, \ell, r, T) \rightarrow k\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
f(\mathcal{A}, \ell, r, T) =
    \begin{cases}
      -1 &amp; \text{if } r &lt; \ell \\
      f(A, \ell, m - 1, T) &amp; \text{if } A_m &gt; T \\
      f(A, m + 1, r, T) &amp; \text{if } A_m &lt; T \\
      m &amp; \text{if } A_m = T
    \end{cases}
\end{split}\]</div>
<p>where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is a sequence of sorted elements (the array)</p></li>
<li><p><span class="math notranslate nohighlight">\(\ell\)</span> and <span class="math notranslate nohighlight">\(r\)</span> are the leftmost and rightmost indices of the search space,
respectively</p></li>
<li><p><span class="math notranslate nohighlight">\(m = \ell + \lfloor \frac{r - \ell}{2} \rfloor\)</span> is the index of the middle
element of the search space</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(m\)</span> is a function of <span class="math notranslate nohighlight">\(\ell\)</span> and <span class="math notranslate nohighlight">\(r\)</span>.</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(A_m\)</span> is the element at index <span class="math notranslate nohighlight">\(m\)</span> in the sequence <span class="math notranslate nohighlight">\(\mathcal{A}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span> is the target value</p></li>
</ul>
<p>This function operates on the half of the search space where the target value
may exist (as determined by comparing the target value <span class="math notranslate nohighlight">\(T\)</span> to the middle value
of the search space). It divides the size of the problem in half at each step,
which is what makes it a divide-and-conquer algorithm.</p>
</section>
</div><p>This representation of the binary search algorithm emphasizes that it works by
reducing the size of the problem at each step. If the target value is less than
the middle value of the array, then the algorithm searches the left half of the
array, and if the target value is greater than the middle value, then it
searches the right half. If the middle value is equal to the target, then the
search is successful, and the index of the middle value is returned. If the size
of the array is 0, then the search is unsuccessful, and -1 is returned.</p>
</section>
<section id="explanation">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">Explanation</a><a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>The search space is initially defined as the entire array, from index <code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">0</span></code>
to <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">len(array)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p></li>
<li><p>The middle point <code class="docutils literal notranslate"><span class="pre">M</span></code> of the search space is defined as <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">(L</span> <span class="pre">+</span> <span class="pre">R)</span> <span class="pre">//</span> <span class="pre">2</span></code>.</p></li>
<li><p>We compare the value at the midpoint <code class="docutils literal notranslate"><span class="pre">M</span></code> with the target value. There are
three possible outcomes:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">array[M]</span> <span class="pre">==</span> <span class="pre">target</span></code>, then we have found the target at index <code class="docutils literal notranslate"><span class="pre">M</span></code> and the
search is complete.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">array[M]</span> <span class="pre">&gt;</span> <span class="pre">target</span></code>, then the target must, if it exists, be in the left
half of the array, specifically in the range from <code class="docutils literal notranslate"><span class="pre">L</span></code> to <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">-</span> <span class="pre">1</span></code>, because
all values at and after <code class="docutils literal notranslate"><span class="pre">M</span></code> are greater than the target. We update
<code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">M</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">array[M]</span> <span class="pre">&lt;</span> <span class="pre">target</span></code>, then the target must, if it exists, be in the right
half of the array, specifically in the range from <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">+</span> <span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">R</span></code>, because
all values before <code class="docutils literal notranslate"><span class="pre">M</span></code> are less than the target. We update <code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">M</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p></li>
</ul>
</li>
</ol>
<p>We repeat the process until we find the target or the search space is empty
(<code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">&gt;</span> <span class="pre">R</span></code>).</p>
</section>
<section id="correctness">
<h3><a class="toc-backref" href="#id26" role="doc-backlink">Correctness</a><a class="headerlink" href="#correctness" title="Permalink to this heading">#</a></h3>
<p>For the proof of correctness, assume that the binary search algorithm does not
correctly find the target. This means that either the algorithm did not return
the target when it was present in the array or returned an incorrect value when
the target was not in the array.</p>
<p>However, each step of the binary search algorithm precisely follows the sorted
property of the array. If the target is less than the value at the midpoint, we
know that the target, if it exists, must be in the left half. Similarly, if the
target is greater than the value at the midpoint, it must be in the right half
if it exists. Therefore, the algorithm correctly narrows down the search space
at each step based on the sorted property of the array.</p>
<p>This contradicts our assumption that the binary search algorithm does not
correctly find the target, and thus proves that the binary search algorithm is
correct.</p>
<p>More formally:</p>
<p>I‚Äôm still assuming the list indices start from 1 for the sake of simplicity.
However, in most programming languages (including Python), they start from 0.</p>
<div class="proof admonition" id="proof">
<p>Proof. We want to prove that the binary search algorithm correctly finds a target value
in a sorted list or correctly reports that the target is not in the list.</p>
<p>Let‚Äôs denote the proposition <span class="math notranslate nohighlight">\(P(n)\)</span>: ‚ÄúFor all sorted lists of length <span class="math notranslate nohighlight">\(n\)</span>, binary
search either finds the target or correctly reports it is not in the list.‚Äù</p>
<p><strong>Base Case:</strong></p>
<p>For <span class="math notranslate nohighlight">\(n=1\)</span>, binary search correctly reports whether the single element is equal
to the target. So, <span class="math notranslate nohighlight">\(P(1)\)</span> is true.</p>
<p><strong>Inductive Step:</strong></p>
<p>We assume that <span class="math notranslate nohighlight">\(P(k)\)</span> holds for all <span class="math notranslate nohighlight">\(k\)</span> such that <span class="math notranslate nohighlight">\(1 \leq k &lt; n\)</span> (Inductive
Hypothesis). We want to show <span class="math notranslate nohighlight">\(P(n)\)</span> is true.</p>
<p>We can write down the steps of binary search for a sorted list of length <span class="math notranslate nohighlight">\(n\)</span> as
follows:</p>
<ol class="arabic simple">
<li><p>Compute <span class="math notranslate nohighlight">\(m = \lfloor \frac{n}{2} \rfloor\)</span> (mid-point).</p></li>
<li><p>If the target equals the <span class="math notranslate nohighlight">\(m^{th}\)</span> element of the list, then we have found the
target.</p></li>
<li><p>If the target is less than the <span class="math notranslate nohighlight">\(m^{th}\)</span> element, then we recursively search
the left subarray of length <span class="math notranslate nohighlight">\(m-1\)</span>.</p></li>
<li><p>If the target is greater than the <span class="math notranslate nohighlight">\(m^{th}\)</span> element, then we recursively
search the right subarray of length <span class="math notranslate nohighlight">\(n-m\)</span>.</p></li>
</ol>
<p>Both the left subarray in step 3 and the right subarray in step 4 have length
less than <span class="math notranslate nohighlight">\(n\)</span>, so by our inductive hypothesis, our algorithm works correctly in
these cases. Therefore, we conclude that <span class="math notranslate nohighlight">\(P(n)\)</span> is true.</p>
<p>This completes our induction and the proof that the binary search algorithm is
correct.</p>
<p><strong>Q.E.D.</strong></p>
</div>
</section>
</section>
<section id="example">
<h2><a class="toc-backref" href="#id27" role="doc-backlink">Example</a><a class="headerlink" href="#example" title="Permalink to this heading">#</a></h2>
<p>Consider the following sorted list of numbers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">sorted_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">91</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>and we seek to find if the number <code class="docutils literal notranslate"><span class="pre">23</span></code> exists in the list. We can use binary
search to find the answer.</p>
<p>Let‚Äôs have a visualization next.</p>
<section id="visualization">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">Visualization</a><a class="headerlink" href="#visualization" title="Permalink to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># List of SVG image paths</span>
<span class="linenos"> 2</span><span class="n">svg_images</span> <span class="o">=</span> <span class="p">[</span>
<span class="linenos"> 3</span>    <span class="s2">&quot;./assets/binary-search-0.svg&quot;</span><span class="p">,</span>
<span class="linenos"> 4</span>    <span class="s2">&quot;./assets/binary-search-1.svg&quot;</span><span class="p">,</span>
<span class="linenos"> 5</span>    <span class="s2">&quot;./assets/binary-search-2.svg&quot;</span><span class="p">,</span>
<span class="linenos"> 6</span>    <span class="s2">&quot;./assets/binary-search-3.svg&quot;</span><span class="p">,</span>
<span class="linenos"> 7</span><span class="p">]</span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="n">tab_titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Step 1&quot;</span><span class="p">,</span> <span class="s2">&quot;Step 2&quot;</span><span class="p">,</span> <span class="s2">&quot;Step 3&quot;</span><span class="p">,</span> <span class="s2">&quot;Step 4&quot;</span><span class="p">]</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="n">tab</span> <span class="o">=</span> <span class="n">create_tabbed_svg_viewer</span><span class="p">(</span><span class="n">svg_images</span><span class="p">,</span> <span class="n">tab_titles</span><span class="p">)</span>
<span class="linenos">12</span><span class="n">display</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"version_major": 2, "version_minor": 0, "model_id": "02f929c877ce44898909a974dd9b84bb"}</script></div>
</div>
</section>
<section id="id1">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">Explanation</a><a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<p>Given a list of 10 elements <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">5,</span> <span class="pre">8,</span> <span class="pre">12,</span> <span class="pre">16,</span> <span class="pre">23,</span> <span class="pre">38,</span> <span class="pre">56,</span> <span class="pre">72,</span> <span class="pre">91]</span></code>, we can use
the binary search algorithm to find the index of the target value <code class="docutils literal notranslate"><span class="pre">23</span></code> in the
list. Following the algorithm, we see the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">9</span></code>, the middle index is <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">(0</span> <span class="pre">+</span> <span class="pre">9)</span> <span class="pre">//</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">4</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">A[m]</span> <span class="pre">=</span> <span class="pre">16</span> <span class="pre">&lt;</span> <span class="pre">T</span> <span class="pre">=</span> <span class="pre">23</span></code>, so we set <code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">5</span></code> because we know that the
target value <code class="docutils literal notranslate"><span class="pre">23</span></code> is in the right half of the array, if it exists.</p></li>
<li><p>It is worth noting that the right index <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">9</span></code> does not need to be changed.
Furthermore, we defined <code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">+</span> <span class="pre">1</span></code> instead of <code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">m</span></code> because we know that
the middle index <code class="docutils literal notranslate"><span class="pre">m</span></code> is not the target value <code class="docutils literal notranslate"><span class="pre">23</span></code>, and we do not need to
search it again.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">5</span></code> and <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">9</span></code>, the middle index is <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">(5</span> <span class="pre">+</span> <span class="pre">9)</span> <span class="pre">//</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">7</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">A[m]</span> <span class="pre">=</span> <span class="pre">56</span> <span class="pre">&gt;</span> <span class="pre">T</span> <span class="pre">=</span> <span class="pre">23</span></code>, so we set <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">6</span></code> because we know that the
target value <code class="docutils literal notranslate"><span class="pre">23</span></code> is in the left half of the array, if it exists.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">5</span></code> and <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">6</span></code>, the middle index is <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">(5</span> <span class="pre">+</span> <span class="pre">6)</span> <span class="pre">//</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">5</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">A[m]</span> <span class="pre">=</span> <span class="pre">23</span> <span class="pre">=</span> <span class="pre">T</span> <span class="pre">=</span> <span class="pre">23</span></code>, so we return <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">5</span></code> because we found the target value
<code class="docutils literal notranslate"><span class="pre">23</span></code> in the array.</p></li>
</ul>
</li>
</ul>
<p>So, the target value <code class="docutils literal notranslate"><span class="pre">23</span></code> is found at index <code class="docutils literal notranslate"><span class="pre">5</span></code> in the sorted list.</p>
<p>Now, let‚Äôs visualize this. Here‚Äôs a table that shows the state of the variables
at each step:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Step</p></th>
<th class="head"><p>L</p></th>
<th class="head"><p>R</p></th>
<th class="head"><p>m</p></th>
<th class="head"><p>A[m]</p></th>
<th class="head"><p>Target</p></th>
<th class="head"><p>Action</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>9</p></td>
<td><p>4</p></td>
<td><p>16</p></td>
<td><p>23</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">A[m]</span> <span class="pre">&lt;</span> <span class="pre">T</span></code>, so <code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">+</span> <span class="pre">1</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>5</p></td>
<td><p>9</p></td>
<td><p>7</p></td>
<td><p>56</p></td>
<td><p>23</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">A[m]</span> <span class="pre">&gt;</span> <span class="pre">T</span></code>, so <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">1</span></code></p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>23</p></td>
<td><p>23</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">A[m]</span> <span class="pre">=</span> <span class="pre">T</span></code>, return <code class="docutils literal notranslate"><span class="pre">m</span></code></p></td>
</tr>
</tbody>
</table>
<p>At the start, we‚Äôre looking at the full list (L=0, R=9). At each step, we adjust
L or R to close in on the target number based on whether it‚Äôs greater than or
less than the middle element. When we find the target number, we return the
index.</p>
</section>
</section>
<section id="intuition">
<h2><a class="toc-backref" href="#id30" role="doc-backlink">Intuition</a><a class="headerlink" href="#intuition" title="Permalink to this heading">#</a></h2>
<p>In <strong><a class="reference internal" href="../linear_search/concept.html"><span class="doc std std-doc">Linear Search</span></a></strong>, even though the list is
sorted, we still have to traverse each element until we find the target, or we
reach the end of the list. This yields a time complexity of <span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span>,
with <span class="math notranslate nohighlight">\(n\)</span> being the size of the list.</p>
<p>However, if the list is sorted, we can leverage a strategy known as
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide and conquer</a></strong>
to improve our search speed significantly. This is where
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Binary Search</a></strong> comes
into play.</p>
<p>The principle behind binary search is that we continually halve our search
space. We begin with the whole list, then determine whether our target value is
in the first or the second half by comparing it with the middle element. If our
target is less than the middle element, it must lie in the first half of the
list, so we can immediately discard the second half. Conversely, if our target
is larger than the middle element, it must reside in the second half, and we
discard the first half.</p>
<p>This process continues until we either find our target or our search space is
exhausted, i.e., there‚Äôs no element left to check. Notably, with each step, we
halve our problem size, leading to a logarithmic time complexity,
<span class="math notranslate nohighlight">\(\mathcal{O}(\log n)\)</span>, making binary search significantly faster than linear
search on large, sorted datasets.</p>
<p>A neat connection exists between binary search and the concept of a
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Binary_search_tree">Binary Search Tree (BST)</a></strong>.
In a BST, each node has a value larger than all the values in its left subtree
and smaller than all the values in its right subtree. This is akin to how binary
search operates, dividing the list into two halves, with one half always less
than and the other always greater than the middle. Indeed, if you perform an
inorder traversal of a BST (left, root, right), you retrieve the elements in
sorted order, just as you would have them arranged for a binary search. So the
middle number of the sorted list is the ‚Äúroot‚Äù of the BST, and the left and
right halves of the list are the left and right subtrees of the root. This is a
great way to visualize the process of binary search and how it operates.</p>
<p>Understanding these relationships and principles helps in realizing why binary
search is so effective and where it can best be applied. It‚Äôs an essential tool
in the algorithmic toolkit of any computer scientist or software developer.</p>
</section>
<section id="assumptions">
<h2><a class="toc-backref" href="#id31" role="doc-backlink">Assumptions</a><a class="headerlink" href="#assumptions" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p><strong>Sorted Array</strong>: We assume the input array is already sorted in ascending
order, and binary search is not suitable for unsorted arrays.</p></li>
<li><p><strong>Unique Elements</strong>: As mentioned, the array consists of unique elements.
This implies that the return index for any valid target is unique.</p></li>
<li><p><strong>Deterministic</strong>: The input array does not change during the course of the
algorithm, and there are no external factors affecting its content.</p></li>
</ol>
</section>
<section id="constraints">
<h2><a class="toc-backref" href="#id32" role="doc-backlink">Constraints</a><a class="headerlink" href="#constraints" title="Permalink to this heading">#</a></h2>
<p>The constaints/assumptions are made below, we follow the same set of assumptions
from <a class="reference external" href="https://leetcode.com/problems/binary-search/">LeetCode‚Äôs Binary Search</a>.</p>
<ul class="simple">
<li><p>The array must be sorted in ascending order.</p></li>
<li><p>The array consists of <strong>unique</strong> elements of type <code class="docutils literal notranslate"><span class="pre">int</span></code> with base 10.</p></li>
<li><p><strong>Array Length</strong>: The length of the array <code class="docutils literal notranslate"><span class="pre">nums</span></code> will always be in the range
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">len(nums)</span> <span class="pre">&lt;=</span> <span class="pre">10^4</span></code>.</p></li>
<li><p><strong>Array Content</strong>: Every element in the array, as well as the target value, is
guaranteed to be in the range <code class="docutils literal notranslate"><span class="pre">-10^4</span> <span class="pre">&lt;=</span> <span class="pre">nums[i],</span> <span class="pre">target</span> <span class="pre">&lt;=</span> <span class="pre">10^4</span></code>.</p></li>
<li><p><strong>Return Value</strong>: The function should return the index of the <code class="docutils literal notranslate"><span class="pre">target</span></code> if it
exists in <code class="docutils literal notranslate"><span class="pre">nums</span></code> and <code class="docutils literal notranslate"><span class="pre">-1</span></code> if it doesn‚Äôt.</p></li>
</ul>
<section id="why-left-right-2-may-cause-overflow">
<h3><a class="toc-backref" href="#id33" role="doc-backlink">Why Left + Right // 2 May Cause Overflow?</a><a class="headerlink" href="#why-left-right-2-may-cause-overflow" title="Permalink to this heading">#</a></h3>
<p>In programming, when two integers are added, and the result goes beyond the
maximum value that can be stored in that integer type, it‚Äôs referred to as an
integer overflow.</p>
<p>Consider a 32-bit signed integer in most languages. The largest value it can
hold is <span class="math notranslate nohighlight">\(2^{31} - 1\)</span>, because one bit is reserved for the sign. When you add two
large numbers, their sum might exceed this value, causing an overflow.</p>
<p>Now, let‚Äôs explore the mid calculation:</p>
<div class="math notranslate nohighlight">
\[m = \left\lfloor \frac{l + r}{2} \right\rfloor\]</div>
<p>If <span class="math notranslate nohighlight">\( l \)</span> and <span class="math notranslate nohighlight">\( r \)</span> are very large (close to the maximum value for the integer
type), their sum can overflow, even though their average (mid value) might still
be within the valid range.</p>
<p>Example: Let‚Äôs take a hypothetical situation where the maximum value an integer
can store is <span class="math notranslate nohighlight">\(15\)</span> (in reality, this is much larger, but we‚Äôre simplifying for
the sake of illustration).</p>
<p>Suppose <span class="math notranslate nohighlight">\(l = 7\)</span> and <span class="math notranslate nohighlight">\(r = 14\)</span>. When you add these together, you get <span class="math notranslate nohighlight">\(l + r =
21\)</span>,
which exceeds our hypothetical maximum value of <span class="math notranslate nohighlight">\(15\)</span>. Hence, an overflow occurs.</p>
<p>However, if we use the safer approach:</p>
<div class="math notranslate nohighlight">
\[m = l + \left\lfloor \frac{r - l}{2} \right\rfloor\]</div>
<p>With our values, we‚Äôd get:</p>
<div class="math notranslate nohighlight">
\[m = 7 + \left\lfloor \frac{14 - 7}{2} \right\rfloor = 7 + 3 = 10\]</div>
<p>This approach avoids overflow because <span class="math notranslate nohighlight">\(l\)</span> and
<span class="math notranslate nohighlight">\(\left\lfloor \frac{r - l}{2}
\right\rfloor\)</span> will always be valid integers and
their sum will be too.</p>
<p>In real-world applications, this is relevant for very large arrays when using
32-bit integers. Using 64-bit integers (like <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> in C++ or <code class="docutils literal notranslate"><span class="pre">int64</span></code> in
some other languages) delays the point where overflow might occur, but the
principle remains. The alternate method for calculating mid is a safer approach
that avoids the potential overflow issue altogether.</p>
</section>
</section>
<section id="test-cases">
<h2><a class="toc-backref" href="#id34" role="doc-backlink">Test Cases</a><a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h2>
<ol class="arabic">
<li><p><strong>Standard Test Case</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">container</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">5</span>
<span class="c1"># Expected Output: 2 (since container[2] = 5)</span>
</pre></div>
</div>
</li>
<li><p><strong>Target at Start</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">container</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1"># Expected Output: 0 (since container[0] = 1)</span>
</pre></div>
</div>
</li>
<li><p><strong>Target at End</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">container</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">9</span>
<span class="c1"># Expected Output: 4 (since container[4] = 9)</span>
</pre></div>
</div>
</li>
<li><p><strong>Target Not in List</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">container</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1"># Expected Output: -1 (since 4 is not in the container)</span>
</pre></div>
</div>
</li>
<li><p><strong>Large Numbers in Array</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">container</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">,</span> <span class="mi">30000</span><span class="p">,</span> <span class="mi">40000</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">30000</span>
<span class="c1"># Expected Output: 2 (since container[2] = 30000)</span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="edge-cases">
<h2><a class="toc-backref" href="#id35" role="doc-backlink">Edge Cases</a><a class="headerlink" href="#edge-cases" title="Permalink to this heading">#</a></h2>
<ol class="arabic">
<li><p><strong>Empty List</strong></p>
<p>Although the problem constraints state the minimum size of the array is 1,
it‚Äôs always a good idea to consider what would happen with an empty array.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">container</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1"># Expected Output: -1 (since the array is empty)</span>
</pre></div>
</div>
</li>
<li><p><strong>Single Element Array</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">container</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1"># Expected Output: 0 (since container[0] = 3)</span>
</pre></div>
</div>
</li>
<li><p><strong>Single Element Array, Target Not Present</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">container</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1"># Expected Output: -1 (since 4 is not in the container)</span>
</pre></div>
</div>
</li>
<li><p><strong>Target Value is Minimum Possible Value</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">container</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">10000</span><span class="p">,</span> <span class="o">-</span><span class="mi">9999</span><span class="p">,</span> <span class="o">-</span><span class="mi">9998</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10000</span>
<span class="c1"># Expected Output: 0 (since container[0] = -10000)</span>
</pre></div>
</div>
</li>
<li><p><strong>Target Value is Maximum Possible Value</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">container</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9998</span><span class="p">,</span> <span class="mi">9999</span><span class="p">,</span> <span class="mi">10000</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="c1"># Expected Output: 2 (since container[2] = 10000)</span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="solution-iterative-find-the-exact-value">
<h2><a class="toc-backref" href="#id36" role="doc-backlink">Solution (Iterative - Find the Exact Value)</a><a class="headerlink" href="#solution-iterative-find-the-exact-value" title="Permalink to this heading">#</a></h2>
<section id="id2">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">Intuition</a><a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h3>
<p>See the intuition above.</p>
</section>
<section id="id3">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">Visualization</a><a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h3>
<p>See the visualization above.</p>
</section>
<section id="algorithm">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">Algorithm</a><a class="headerlink" href="#algorithm" title="Permalink to this heading">#</a></h3>
<p>See the algorithm above.</p>
</section>
<section id="claim">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">Claim</a><a class="headerlink" href="#claim" title="Permalink to this heading">#</a></h3>
<p>‚Ä¶</p>
</section>
<section id="proof">
<h3><a class="toc-backref" href="#id41" role="doc-backlink">Proof</a><a class="headerlink" href="#proof" title="Permalink to this heading">#</a></h3>
<p>‚Ä¶</p>
</section>
<section id="implementation">
<h3><a class="toc-backref" href="#id42" role="doc-backlink">Implementation</a><a class="headerlink" href="#implementation" title="Permalink to this heading">#</a></h3>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="linenos"> 2</span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>  <span class="c1"># T should be of type int, float or str</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="k">class</span> <span class="nc">BinarySearch</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Interface for Binary Search Strategies (Strategy Design Pattern).&quot;&quot;&quot;</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">11</span>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">12</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Search for a target from a sorted array nums.&quot;&quot;&quot;</span>
<span class="linenos">13</span>
<span class="linenos">14</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">15</span>    <span class="k">def</span> <span class="nf">mid_strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">16</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Strategy for calculating the middle index.&quot;&quot;&quot;</span>
<span class="linenos">17</span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="k">class</span> <span class="nc">BinarySearch</span><span class="p">:</span>
<span class="linenos">20</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">:</span> <span class="n">BinarySearch</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">21</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">22</span><span class="sd">        Usually, the Context (here is BinarySearch executor)</span>
<span class="linenos">23</span><span class="sd">        accepts a strategy through the constructor, but also</span>
<span class="linenos">24</span><span class="sd">        provides a setter to change it at runtime.</span>
<span class="linenos">25</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">26</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">=</span> <span class="n">strategy</span>
<span class="linenos">27</span>
<span class="linenos">28</span>    <span class="nd">@property</span>
<span class="linenos">29</span>    <span class="k">def</span> <span class="nf">strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinarySearch</span><span class="p">:</span>
<span class="linenos">30</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">31</span><span class="sd">        The Context maintains a reference to one of the Strategy objects. The</span>
<span class="linenos">32</span><span class="sd">        Context does not know the concrete class of a strategy. It should work</span>
<span class="linenos">33</span><span class="sd">        with all strategies via the Strategy interface.</span>
<span class="linenos">34</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">35</span>
<span class="linenos">36</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span>
<span class="linenos">37</span>
<span class="linenos">38</span>    <span class="nd">@strategy</span><span class="o">.</span><span class="n">setter</span>
<span class="linenos">39</span>    <span class="k">def</span> <span class="nf">strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">:</span> <span class="n">BinarySearch</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">40</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">41</span><span class="sd">        Usually, the Context allows replacing a Strategy object at runtime.</span>
<span class="linenos">42</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">43</span>
<span class="linenos">44</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">=</span> <span class="n">strategy</span>
<span class="linenos">45</span>
<span class="linenos">46</span>    <span class="k">def</span> <span class="nf">find_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">47</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the target.&quot;&quot;&quot;</span>
<span class="linenos">48</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="nc">IterativeBinarySearchExactMatch</span><span class="p">(</span><span class="n">BinarySearch</span><span class="p">):</span>
<span class="linenos"> 2</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Leetcode calls this template 1:</span>
<span class="linenos"> 3</span><span class="sd">    https://leetcode.com/explore/learn/card/binary-search/125/template-i/</span>
<span class="linenos"> 4</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos"> 7</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Search for a target from a sorted array nums.&quot;&quot;&quot;</span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span>        <span class="n">left_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos">10</span>        <span class="n">right_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="linenos">11</span>
<span class="linenos">12</span>        <span class="k">while</span> <span class="n">left_index</span> <span class="o">&lt;=</span> <span class="n">right_index</span><span class="p">:</span>
<span class="linenos">13</span>            <span class="n">mid_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mid_strategy</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">left_index</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right_index</span><span class="p">)</span>
<span class="linenos">14</span>            <span class="c1"># Check if target is present at mid</span>
<span class="linenos">15</span>            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid_index</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
<span class="linenos">16</span>                <span class="k">return</span> <span class="n">mid_index</span>
<span class="linenos">17</span>
<span class="linenos">18</span>            <span class="c1"># If target is greater, we discard left half, so we update left_index</span>
<span class="linenos">19</span>            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid_index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
<span class="linenos">20</span>                <span class="n">left_index</span> <span class="o">=</span> <span class="n">mid_index</span> <span class="o">+</span> <span class="mi">1</span>
<span class="linenos">21</span>
<span class="linenos">22</span>            <span class="c1"># If target is smaller, we discard right half, so we update right_index</span>
<span class="linenos">23</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">24</span>                <span class="n">right_index</span> <span class="o">=</span> <span class="n">mid_index</span> <span class="o">-</span> <span class="mi">1</span>
<span class="linenos">25</span>
<span class="linenos">26</span>        <span class="c1"># Search has ended and target is not present in the nums, so we return -1</span>
<span class="linenos">27</span>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="linenos">28</span>
<span class="linenos">29</span>    <span class="k">def</span> <span class="nf">mid_strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">30</span>        <span class="c1"># (left_index + right_index) // 2 will cause overflow.</span>
<span class="linenos">31</span>        <span class="n">mid_index</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="linenos">32</span>        <span class="k">return</span> <span class="n">mid_index</span>
</pre></div>
</div>
</div>
</div>
<p>Think of the following:</p>
<ul>
<li><p>Terminating condition: the search space is empty.</p>
<ul>
<li><p>We don‚Äôt use <code class="docutils literal notranslate"><span class="pre">len(nums)</span> <span class="pre">==</span> <span class="pre">0</span></code> because this question usually want us to have
auxiliary space complexity of <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>. And thus <code class="docutils literal notranslate"><span class="pre">nums</span></code> may not be
mutated directly here (retrospectively).</p></li>
<li><p>We generally use left, right pointers and if <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">&gt;</span> <span class="pre">right</span></code> then the search
space is empty. Why?</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">left</span></code> pointer moves right (<code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">=</span> <span class="pre">mid</span> <span class="pre">+</span> <span class="pre">1</span></code>), and the <code class="docutils literal notranslate"><span class="pre">right</span></code> pointer
moves left (<code class="docutils literal notranslate"><span class="pre">right</span> <span class="pre">=</span> <span class="pre">mid</span> <span class="pre">-</span> <span class="pre">1</span></code>), so if they cross, it means we‚Äôve checked
all possible elements.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">&lt;=</span> <span class="pre">right</span></code> condition ensures that when <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> are
pointing to the same element (i.e., the search space has only one item
left), we still check this last element.</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">&gt;</span> <span class="pre">right</span></code>, there are no elements left to check in the search
space, and the algorithm can terminate.</p></li>
</ul>
<p>This condition works for the binary search paradigm where we exclude the
middle element at each step after checking it. There are other paradigms
where the <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> pointers do not exclude the middle element
after checking it, and the terminating condition for those may be
<code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">&lt;</span> <span class="pre">right</span></code>. However, for the classic binary search, the <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">&gt;</span> <span class="pre">right</span></code>
condition is used to indicate an empty search space.</p>
</li>
</ul>
</li>
<li><p>Distinguishing Syntax:</p>
<ul class="simple">
<li><p>Initial Condition: <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">=</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">right</span> <span class="pre">=</span> <span class="pre">length-1</span></code></p></li>
<li><p>Termination: <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">&gt;</span> <span class="pre">right</span></code></p></li>
<li><p>Searching Left: <code class="docutils literal notranslate"><span class="pre">right</span> <span class="pre">=</span> <span class="pre">mid-1</span></code></p></li>
<li><p>Searching Right: <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">=</span> <span class="pre">mid+1</span></code></p></li>
</ul>
</li>
</ul>
</section>
<section id="tests">
<h3><a class="toc-backref" href="#id43" role="doc-backlink">Tests</a><a class="headerlink" href="#tests" title="Permalink to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">binary_search</span> <span class="o">=</span> <span class="n">BinarySearch</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">IterativeBinarySearchExactMatch</span><span class="p">())</span>
<span class="linenos">2</span><span class="n">result</span> <span class="o">=</span> <span class="n">binary_search</span><span class="o">.</span><span class="n">find_target</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">91</span><span class="p">],</span> <span class="mi">23</span><span class="p">)</span>
<span class="linenos">3</span><span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">line</span> <span class="mi">1</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">binary_search</span> <span class="o">=</span> <span class="n">BinarySearch</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">IterativeBinarySearchExactMatch</span><span class="p">())</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="n">result</span> <span class="o">=</span> <span class="n">binary_search</span><span class="o">.</span><span class="n">find_target</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">91</span><span class="p">],</span> <span class="mi">23</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">5</span>

<span class="ne">TypeError</span>: __init__() missing 1 required positional argument: &#39;strategy&#39;
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-complexity">
<h3><a class="toc-backref" href="#id44" role="doc-backlink">Time Complexity</a><a class="headerlink" href="#time-complexity" title="Permalink to this heading">#</a></h3>
<p>Let‚Äôs consider a sorted list <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8,</span> <span class="pre">9]</span></code> and we want to
find the target value <code class="docutils literal notranslate"><span class="pre">9</span></code>.</p>
<p>We see that for an array of <span class="math notranslate nohighlight">\(10\)</span> elements, I purposely choose <code class="docutils literal notranslate"><span class="pre">9</span></code> as the target
value, which is also the last element. In a typical sequential search, it will
take <span class="math notranslate nohighlight">\(10\)</span> iterations to find the target value <code class="docutils literal notranslate"><span class="pre">9</span></code>, and therefore the time
complexity is <span class="math notranslate nohighlight">\(O(n)\)</span>.</p>
<p>However, we took a total of <span class="math notranslate nohighlight">\(4\)</span> iterations to find the target value <code class="docutils literal notranslate"><span class="pre">9</span></code> in the
array for a binary search. How did we get to this result?</p>
<p>To analyze the binary search algorithm, we need to recall that each comparison
eliminates about half of the remaining items from consideration. What is the
maximum number of comparisons this algorithm will require to check the entire
list <span id="id4">[<a class="reference internal" href="../../../bibliography.html#id5" title="Runestone Interactive. Problem solving with algorithms and data structures using python. 2023. URL: \url{https://runestone.academy/ns/books/published/pythonds3/index.html}.">Runestone Interactive, 2023</a>]</span>?</p>
<p>Let‚Äôs say we have an array of <span class="math notranslate nohighlight">\(n\)</span> elements.</p>
<ul class="simple">
<li><p>The first comparison eliminates about half of the remaining items from
consideration. Thus, after the first comparison, we have about <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span>
elements left.</p></li>
<li><p>The second comparison eliminates about half of the remaining items from
consideration. Thus, after the second comparison, we have about
<span class="math notranslate nohighlight">\(\frac{n}{2^2}\)</span> elements left.</p></li>
<li><p>The third comparison eliminates about half of the remaining items from
consideration. Thus, after the third comparison, we have about <span class="math notranslate nohighlight">\(\frac{n}{2^3}\)</span>
elements left.</p></li>
<li><p>The <span class="math notranslate nohighlight">\(k\)</span>-th comparison eliminates about half of the remaining items from
consideration. Thus, after the <span class="math notranslate nohighlight">\(k\)</span>-th comparison, we have about
<span class="math notranslate nohighlight">\(\frac{n}{2^k}\)</span> elements left.</p></li>
</ul>
<p>Note that we say approximately/about because the number of elements left after
the <span class="math notranslate nohighlight">\(i\)</span>-th comparison is not always ‚Äúhalf‚Äù. Using back the same example
previously, if we have an array of <span class="math notranslate nohighlight">\(10\)</span> elements, and we want to find <span class="math notranslate nohighlight">\(9\)</span>, then
after the first comparison, we discard the first half of the array,
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code>, and we have <code class="docutils literal notranslate"><span class="pre">[5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8,</span> <span class="pre">9]</span></code> left. This is indeed
<span class="math notranslate nohighlight">\(\frac{n}{2} = \frac{10}{2} = 5\)</span> elements left. However, after the second
comparison, we discard the first half of the array, <code class="docutils literal notranslate"><span class="pre">[5,</span> <span class="pre">6]</span></code>, and we have
<code class="docutils literal notranslate"><span class="pre">[7,</span> <span class="pre">8,</span> <span class="pre">9]</span></code> left. This is now <span class="math notranslate nohighlight">\(3\)</span> elements left, which is not exactly half of
the remaining items from consideration since <code class="docutils literal notranslate"><span class="pre">[5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8,</span> <span class="pre">9]</span></code> is an array of
odd length.</p>
<table class="table" id="items-left-binary-search">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">Number of items left after <span class="math notranslate nohighlight">\(k\)</span>-th comparison</span><a class="headerlink" href="#items-left-binary-search" title="Permalink to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Comparisons</p></th>
<th class="head"><p>Approximate number of items left</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(i = 1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{n}{2}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(i = 2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{n}{2^2}\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(i = 3\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{n}{2^3}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\ldots\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\ldots\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(i = k\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{n}{2^k}\)</span></p></td>
</tr>
</tbody>
</table>
<p>If we split the container/list enough times, eventually we will have only one
item left <span id="id5">[<a class="reference internal" href="../../../bibliography.html#id5" title="Runestone Interactive. Problem solving with algorithms and data structures using python. 2023. URL: \url{https://runestone.academy/ns/books/published/pythonds3/index.html}.">Runestone Interactive, 2023</a>]</span>. The last item is either the target value or it is
not.</p>
<p>So our stopping condition is when the number of items left is <span class="math notranslate nohighlight">\(1\)</span>. Consequently,
we solve for <span class="math notranslate nohighlight">\(k\)</span> in the equation <span class="math notranslate nohighlight">\(\frac{n}{2^k} = 1\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\frac{n}{2^k} &amp;\iff 1 \\
2^k &amp;\iff n \\
\log_2 2^k &amp;\iff \log_2 n \\
k &amp;\iff \log_2 n
\end{align*}
\end{split}\]</div>
<p>This means that the maximum number of comparisons is <span class="math notranslate nohighlight">\(\log_2 n\)</span>. In other words,
after approximately <span class="math notranslate nohighlight">\(\log_2 n\)</span> comparisons, we can reduce the size of the list
to <span class="math notranslate nohighlight">\(1\)</span> and since we will not be able to divide the list any further, we can
conclude that the target value is either the last element or it is not in the
list, ending the search.</p>
<p>In terms of big-O, we say that the binary search algorithm takes <span class="math notranslate nohighlight">\(\O(\log_2 n)\)</span>
time to search for an item in a list of <span class="math notranslate nohighlight">\(n\)</span> items, which means the maximum
number of comparisons is in a logarithmic relationship to the number of items in
the list <span id="id6">[<a class="reference internal" href="../../../bibliography.html#id5" title="Runestone Interactive. Problem solving with algorithms and data structures using python. 2023. URL: \url{https://runestone.academy/ns/books/published/pythonds3/index.html}.">Runestone Interactive, 2023</a>]</span>.</p>
<p>The time complexity table is listed below, the best case is <span class="math notranslate nohighlight">\(\O(1)\)</span> for the same
reason as the sequential search algorithm, where the <code class="docutils literal notranslate"><span class="pre">target</span></code> element is in the
middle, and we just need to make one comparison. For the worst case, the element
is either in the first or last index, or it is not in the list at all. In this
case, we need to make <span class="math notranslate nohighlight">\(\log_2 n\)</span> comparisons.</p>
<table class="table" id="binary-search-time-complexity-iterative">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">Best, Worst, and Average Case Analysis of Binary Search</span><a class="headerlink" href="#binary-search-time-complexity-iterative" title="Permalink to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Case</p></th>
<th class="head"><p>Worst Case</p></th>
<th class="head"><p>Average Case</p></th>
<th class="head"><p>Best Case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Element is in the list</p></td>
<td><p><span class="math notranslate nohighlight">\(\O(\log_2 n)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\O(\log_2 n)\)</span><a class="footnote-reference brackets" href="#average-case" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(\O(1)\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Element is not in the list</p></td>
<td><p><span class="math notranslate nohighlight">\(\O(\log_2 n)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\O(\log_2 n)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\O(\log_2 n)\)</span></p></td>
</tr>
</tbody>
</table>
</section>
<section id="space-complexity">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">Space Complexity</a><a class="headerlink" href="#space-complexity" title="Permalink to this heading">#</a></h3>
<p>We break down the space complexity of binary search into three parts: input,
auxiliary and total space complexity.</p>
<section id="input-space-complexity">
<h4><a class="toc-backref" href="#id46" role="doc-backlink">Input Space Complexity</a><a class="headerlink" href="#input-space-complexity" title="Permalink to this heading">#</a></h4>
<p>Input space complexity is the space used to store the input to the problem. For
a binary search, the input is the array or list we are searching through, and a
target value. We do not usually consider the space taken by the inputs when
analyzing the space complexity of an algorithm, unless the algorithm modifies
the input in place.</p>
<p>But if we do want to consider the input space, that is the space taken by the
inputs, which is <span class="math notranslate nohighlight">\(\mathcal{O}(n) + \mathcal{O}(1) = \mathcal{O}(n)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span>
is the length of the array and <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span> is the space taken by the target
value.</p>
</section>
<section id="auxiliary-space-complexity">
<h4><a class="toc-backref" href="#id47" role="doc-backlink">Auxiliary Space Complexity</a><a class="headerlink" href="#auxiliary-space-complexity" title="Permalink to this heading">#</a></h4>
<p>Auxiliary space complexity is the extra space or the temporary space used by an
algorithm. In the case of binary search, we only need three variables to hold
the left, right and middle indices (<code class="docutils literal notranslate"><span class="pre">L</span></code>, <code class="docutils literal notranslate"><span class="pre">R</span></code>, <code class="docutils literal notranslate"><span class="pre">m</span></code>). These variables occupy
constant space, so the auxiliary space complexity is <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>.</p>
<p>For the iterative approach, only one stack frame is used, contributing to the
auxiliary space complexity of O(1). There is no extra allocation in each
iteration of the while loop in terms of variables or object instances.</p>
</section>
<section id="total-space-complexity">
<h4><a class="toc-backref" href="#id48" role="doc-backlink">Total Space Complexity</a><a class="headerlink" href="#total-space-complexity" title="Permalink to this heading">#</a></h4>
<p>Total space complexity is the sum of input and auxiliary space complexities. For
binary search, if the input space complexity is not considered and the auxiliary
space complexity is <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>, the total space complexity of binary
search is <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>, else it is <span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span>.</p>
<p>To summarize, the binary search algorithm is very space-efficient as it only
requires constant auxiliary space to perform the search, and it does not modify
the input array or list.</p>
</section>
</section>
</section>
<section id="solution-recursive-find-the-exact-value">
<h2><a class="toc-backref" href="#id49" role="doc-backlink">Solution (Recursive - Find the Exact Value)</a><a class="headerlink" href="#solution-recursive-find-the-exact-value" title="Permalink to this heading">#</a></h2>
<section id="id8">
<h3><a class="toc-backref" href="#id50" role="doc-backlink">Intuition</a><a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h3>
<p>‚Ä¶</p>
</section>
<section id="id9">
<h3><a class="toc-backref" href="#id51" role="doc-backlink">Visualization</a><a class="headerlink" href="#id9" title="Permalink to this heading">#</a></h3>
<p>‚Ä¶</p>
</section>
<section id="id10">
<h3><a class="toc-backref" href="#id52" role="doc-backlink">Algorithm</a><a class="headerlink" href="#id10" title="Permalink to this heading">#</a></h3>
<section id="pseudocode">
<h4><a class="toc-backref" href="#id53" role="doc-backlink">Pseudocode</a><a class="headerlink" href="#pseudocode" title="Permalink to this heading">#</a></h4>
<p>‚Ä¶</p>
</section>
<section id="mathematical-representation">
<h4><a class="toc-backref" href="#id54" role="doc-backlink">Mathematical Representation</a><a class="headerlink" href="#mathematical-representation" title="Permalink to this heading">#</a></h4>
<p>The binary search algorithm is a divide-and-conquer algorithm that halves the
search space at each step. It can be formally described using the notation for
sequences, with <span class="math notranslate nohighlight">\(a\)</span> representing the sequence (i.e., the array), <span class="math notranslate nohighlight">\(n\)</span>
representing the length of the sequence, <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> representing the low and
high indices of the search space, and <span class="math notranslate nohighlight">\(m\)</span> representing the midpoint.</p>
<p>Here‚Äôs a rigorous mathematical version for binary search:</p>
<div class="proof algorithm admonition" id="binary-search-mathematical-representation-algorithm-exact-match">
<p class="admonition-title"><span class="caption-number">Algorithm 5 </span> (Mathematical Representation)</p>
<section class="algorithm-content" id="proof-content">
<p>Define the function <span class="math notranslate nohighlight">\(f: (\mathcal{A}, \ell, r, T) \rightarrow k\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
f(\mathcal{A}, \ell, r, T) =
    \begin{cases}
      -1 &amp; \text{if } r &lt; \ell \\
      f(A, \ell, m - 1, T) &amp; \text{if } A_m &gt; T \\
      f(A, m + 1, r, T) &amp; \text{if } A_m &lt; T \\
      m &amp; \text{if } A_m = T
    \end{cases}
\end{split}\]</div>
<p>where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is a sequence of sorted elements (the array)</p></li>
<li><p><span class="math notranslate nohighlight">\(\ell\)</span> and <span class="math notranslate nohighlight">\(r\)</span> are the leftmost and rightmost indices of the search space,
respectively</p></li>
<li><p><span class="math notranslate nohighlight">\(m = \ell + \lfloor \frac{r - \ell}{2} \rfloor\)</span> is the index of the middle
element of the search space</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(m\)</span> is a function of <span class="math notranslate nohighlight">\(\ell\)</span> and <span class="math notranslate nohighlight">\(r\)</span>.</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(A_m\)</span> is the element at index <span class="math notranslate nohighlight">\(m\)</span> in the sequence <span class="math notranslate nohighlight">\(\mathcal{A}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span> is the target value</p></li>
</ul>
<p>This function operates on the half of the search space where the target value
may exist (as determined by comparing the target value <span class="math notranslate nohighlight">\(T\)</span> to the middle value
of the search space). It divides the size of the problem in half at each step,
which is what makes it a divide-and-conquer algorithm.</p>
</section>
</div><p>This representation of the binary search algorithm emphasizes that it works by
reducing the size of the problem at each step. If the target value is less than
the middle value of the array, then the algorithm searches the left half of the
array, and if the target value is greater than the middle value, then it
searches the right half. If the middle value is equal to the target, then the
search is successful, and the index of the middle value is returned. If the size
of the array is 0, then the search is unsuccessful, and -1 is returned.</p>
</section>
</section>
<section id="id11">
<h3><a class="toc-backref" href="#id55" role="doc-backlink">Claim</a><a class="headerlink" href="#id11" title="Permalink to this heading">#</a></h3>
<p>‚Ä¶</p>
</section>
<section id="id12">
<h3><a class="toc-backref" href="#id56" role="doc-backlink">Proof</a><a class="headerlink" href="#id12" title="Permalink to this heading">#</a></h3>
<p>‚Ä¶</p>
</section>
<section id="id13">
<h3><a class="toc-backref" href="#id57" role="doc-backlink">Implementation</a><a class="headerlink" href="#id13" title="Permalink to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="nc">RecursiveBinarySearchExactMatch</span><span class="p">(</span><span class="n">BinarySearch</span><span class="p">):</span>
<span class="linenos"> 2</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Template 1 but recursive.&quot;&quot;&quot;</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos"> 5</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Search for a target from a sorted array nums.&quot;&quot;&quot;</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span>        <span class="k">def</span> <span class="nf">recursive</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos"> 8</span>            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span>
<span class="linenos"> 9</span>                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="linenos">10</span>
<span class="linenos">11</span>            <span class="n">mid_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mid_strategy</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="linenos">12</span>
<span class="linenos">13</span>            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid_index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
<span class="linenos">14</span>                <span class="k">return</span> <span class="n">recursive</span><span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="n">mid_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>
<span class="linenos">15</span>            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid_index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
<span class="linenos">16</span>                <span class="k">return</span> <span class="n">recursive</span><span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">mid_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">17</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">18</span>                <span class="k">return</span> <span class="n">mid_index</span>
<span class="linenos">19</span>
<span class="linenos">20</span>        <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="linenos">21</span>        <span class="k">return</span> <span class="n">recursive</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="linenos">22</span>
<span class="linenos">23</span>    <span class="k">def</span> <span class="nf">mid_strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">24</span>        <span class="n">mid_index</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="linenos">25</span>        <span class="k">return</span> <span class="n">mid_index</span>
</pre></div>
</div>
</div>
</div>
<p>Using Python Tutor to visualize recursive calls
<a class="reference external" href="https://pythontutor.com/render.html#code=import%20math%0Afrom%20typing%20import%20Iterable,%20TypeVar,%20Tuple%0A%0AT%20%3D%20TypeVar%28%22T%22,%20str,%20int,%20float%29%20%20%23%20T%20should%20be%20of%20type%20int,%20float%20or%20str%0A%0Adef%20binary_search_recursive%28%0A%20%20%20%20container%3A%20Iterable%5BT%5D,%20target%3A%20T,%20left_index%3A%20int,%20right_index%3A%20int%0A%29%20-%3E%20int%3A%0A%20%20%20%20%22%22%22Binary%20search%20recursive%20implementation.%22%22%22%0A%20%20%20%20mid_index%20%3D%20left_index%20%2B%20math.floor%28%28right_index%20-%20left_index%29%20/%202%29%0A%20%20%20%20if%20left_index%20%3C%3D%20right_index%3A%0A%20%20%20%20%20%20%20%20if%20container%5Bmid_index%5D%20%3D%3D%20target%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20mid_index%20%20%23%20base%20case%201%0A%20%20%20%20%20%20%20%20elif%20container%5Bmid_index%5D%20%3C%20target%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20binary_search_recursive%28%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20container,%20target,%20mid_index%20%2B%201,%20right_index%0A%20%20%20%20%20%20%20%20%20%20%20%20%29%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20binary_search_recursive%28container,%20target,%20left_index,%20mid_index%20-%201%29%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20-1%20%20%23%20base%20case%202%0A%20%20%20%20%0Aordered_list%20%3D%20%5B0,%201,%202,%208,%2013,%2017,%2019,%2032,%2042%5D%0Aleft_index%20%3D%200%0Aright_index%20%3D%20len%28ordered_list%29%20-%201%0Aprint%28binary_search_recursive%28ordered_list,%2042,%20left_index,%20right_index%29%29&amp;cumulative=false&amp;curInstr=17&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">here</a>.</p>
<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=import%20math%0Afrom%20typing%20import%20Iterable,%20TypeVar,%20Tuple%0A%0AT%20%3D%20TypeVar%28%22T%22,%20str,%20int,%20float%29%20%20%23%20T%20should%20be%20of%20type%20int,%20float%20or%20str%0A%0Adef%20binary_search_recursive%28%0A%20%20%20%20container%3A%20Iterable%5BT%5D,%20target%3A%20T,%20left_index%3A%20int,%20right_index%3A%20int%0A%29%20-%3E%20int%3A%0A%20%20%20%20%22%22%22Binary%20search%20recursive%20implementation.%22%22%22%0A%20%20%20%20mid_index%20%3D%20left_index%20%2B%20math.floor%28%28right_index%20-%20left_index%29%20/%202%29%0A%20%20%20%20if%20left_index%20%3C%3D%20right_index%3A%0A%20%20%20%20%20%20%20%20if%20container%5Bmid_index%5D%20%3D%3D%20target%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20mid_index%20%20%23%20base%20case%201%0A%20%20%20%20%20%20%20%20elif%20container%5Bmid_index%5D%20%3C%20target%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20binary_search_recursive%28%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20container,%20target,%20mid_index%20%2B%201,%20right_index%0A%20%20%20%20%20%20%20%20%20%20%20%20%29%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20binary_search_recursive%28container,%20target,%20left_index,%20mid_index%20-%201%29%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20-1%20%20%23%20base%20case%202%0A%20%20%20%20%0Aordered_list%20%3D%20%5B0,%201,%202,%208,%2013,%2017,%2019,%2032,%2042%5D%0Aleft_index%20%3D%200%0Aright_index%20%3D%20len%28ordered_list%29%20-%201%0Aprint%28binary_search_recursive%28ordered_list,%2042,%20left_index,%20right_index%29%29&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>
</section>
<section id="id14">
<h3><a class="toc-backref" href="#id58" role="doc-backlink">Tests</a><a class="headerlink" href="#id14" title="Permalink to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># Changing the strategy to RecursiveBinarySearchExactMatch</span>
<span class="linenos">2</span><span class="n">binary_search</span><span class="o">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="n">RecursiveBinarySearchExactMatch</span><span class="p">()</span>
<span class="linenos">3</span><span class="n">result</span> <span class="o">=</span> <span class="n">binary_search</span><span class="o">.</span><span class="n">find_target</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">91</span><span class="p">],</span> <span class="mi">23</span><span class="p">)</span>
<span class="linenos">4</span><span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id15">
<h3><a class="toc-backref" href="#id59" role="doc-backlink">Time Complexity</a><a class="headerlink" href="#id15" title="Permalink to this heading">#</a></h3>
<section id="master-theorem">
<h4><a class="toc-backref" href="#id60" role="doc-backlink">Master Theorem</a><a class="headerlink" href="#master-theorem" title="Permalink to this heading">#</a></h4>
<p>We have a recurrence relation of the form:</p>
<div class="math notranslate nohighlight">
\[T(n) = a \cdot T\left(\frac{n}{b}\right) + f(n)\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(a\)</span> is the number of subproblems in the recursion.</p></li>
<li><p><span class="math notranslate nohighlight">\(\frac{n}{b}\)</span> is the size of each subproblem. (All subproblems are assumed to
have the same size.)</p></li>
<li><p><span class="math notranslate nohighlight">\(f(n)\)</span> represents the cost of the work done outside the recursive calls, which
includes the cost of dividing the problem and the cost of merging the
solutions.</p></li>
</ul>
<p>For our binary search, we have:</p>
<div class="math notranslate nohighlight">
\[T(n) = T\left(\frac{n}{2}\right) + \mathcal{O}(1)\]</div>
<p>This translates into <span class="math notranslate nohighlight">\(a = 1\)</span>, <span class="math notranslate nohighlight">\(b = 2\)</span>, and <span class="math notranslate nohighlight">\(f(n) = \mathcal{O}(1)\)</span>, which means
<span class="math notranslate nohighlight">\(d = 0\)</span> since <span class="math notranslate nohighlight">\(\mathcal{O}(n^0) = \mathcal{O}(1)\)</span>.</p>
<p>Now let‚Äôs proceed with the Master Theorem. The Master Theorem states that the
solution to the recurrence relation:</p>
<div class="math notranslate nohighlight">
\[T(n) = a \cdot T\left(\frac{n}{b}\right) + f(n)\]</div>
<p>is given as follows:</p>
<ol class="arabic simple">
<li><p>If <span class="math notranslate nohighlight">\(f(n) = \mathcal{O}(n^c)\)</span>, where <span class="math notranslate nohighlight">\(c &lt; \log_b{a}\)</span>, then
<span class="math notranslate nohighlight">\(T(n) = \Theta(n^{\log_b{a}})\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f(n) = \mathcal{O}(n^c)\)</span>, where <span class="math notranslate nohighlight">\(c = \log_b{a}\)</span>, then
<span class="math notranslate nohighlight">\(T(n) = \Theta(n^c \log n)\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f(n) = \mathcal{O}(n^c)\)</span>, where <span class="math notranslate nohighlight">\(c &gt; \log_b{a}\)</span>, then
<span class="math notranslate nohighlight">\(T(n) = \Theta(f(n))\)</span>.</p></li>
</ol>
<p>Comparing <span class="math notranslate nohighlight">\(d\)</span> with <span class="math notranslate nohighlight">\(\log_b a\)</span>, we see that <span class="math notranslate nohighlight">\(d = \log_b a = \log_2 1 = 0\)</span>.</p>
<p>So, we‚Äôre in the second case of the Master Theorem. According to the second case
of the Master Theorem, if <span class="math notranslate nohighlight">\(f(n) = \Theta(n^d)\)</span>, where <span class="math notranslate nohighlight">\(d = \log_b a\)</span>, then
<span class="math notranslate nohighlight">\(T(n) = \Theta(n^d \log n)\)</span>.</p>
<p>Substitute <span class="math notranslate nohighlight">\(d = 0\)</span> into <span class="math notranslate nohighlight">\(T(n) = \Theta(n^d \log n)\)</span>, we get
<span class="math notranslate nohighlight">\(T(n) = \Theta(\log n)\)</span>, which means that the time complexity of binary search
is <span class="math notranslate nohighlight">\(\mathcal{O}(\log n)\)</span>.</p>
</section>
<section id="repeated-substitution">
<h4><a class="toc-backref" href="#id61" role="doc-backlink">Repeated Substitution</a><a class="headerlink" href="#repeated-substitution" title="Permalink to this heading">#</a></h4>
<p>Let‚Äôs denote the time complexity of our function as <span class="math notranslate nohighlight">\(\mathcal{T}(n)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span>
is the number of elements being considered during a given recursive call.
Initially, <span class="math notranslate nohighlight">\(n\)</span> is the size of the entire list, but with each recursive call, it
gets halved.</p>
<p>On every recursive call to the <code class="docutils literal notranslate"><span class="pre">recursive</span></code> function, the list is divided into
two halves, and only one half is considered for further search. Hence, the size
of the problem is reduced to half its previous size.</p>
<p>To find the recurrence relation, let‚Äôs break down the operations:</p>
<ol class="arabic simple">
<li><p>We calculate the middle index, which takes constant time <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>.</p></li>
<li><p>We make a decision based on the middle element, again taking <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>
time.</p></li>
<li><p>We make a recursive call, but only on half of the current list.</p></li>
</ol>
<p>Putting this into a recurrence relation:</p>
<div class="math notranslate nohighlight">
\[\mathcal{T}(n) = \mathcal{T}\left(\frac{n}{2}\right) + \mathcal{O}(1)\]</div>
<p>This is a standard divide-and-conquer recurrence relation. We can solve it using
the Master Theorem or repeated substitution.</p>
<p>Using repeated substitution:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\mathcal{T}(n) &amp;= \mathcal{T}\left(\frac{n}{2}\right) + \mathcal{O}(1) \\
\mathcal{T}(n) &amp;= \left[\mathcal{T}\left(\frac{n}{4}\right) + \mathcal{O}(1)\right] + \mathcal{O}(1) \\
\mathcal{T}(n) &amp;= \mathcal{T}\left(\frac{n}{4}\right) + 2\mathcal{O}(1) \\
\mathcal{T}(n) &amp;= \mathcal{T}\left(\frac{n}{8}\right) + 3\mathcal{O}(1) \\
&amp;\vdots \\
\mathcal{T}(n) &amp;= \mathcal{T}\left(\frac{n}{2^k}\right) + k\mathcal{O}(1)
\end{align*}
\end{split}\]</div>
<p>Now, <span class="math notranslate nohighlight">\(\mathcal{T}\left(\frac{n}{2^k}\right)\)</span> will be <span class="math notranslate nohighlight">\(\mathcal{T}(1)\)</span> (i.e., a
constant) when <span class="math notranslate nohighlight">\(\frac{n}{2^k} = 1\)</span> or <span class="math notranslate nohighlight">\(k = \log n\)</span>.</p>
<p>So, the expansion becomes:</p>
<div class="math notranslate nohighlight">
\[\mathcal{T}(n) = \mathcal{T}(1) + \log n \times \mathcal{O}(1)\]</div>
<p>Given that <span class="math notranslate nohighlight">\(\mathcal{T}(1)\)</span> is a constant time, the dominating factor here is
<span class="math notranslate nohighlight">\(\log n\)</span>. Therefore, the time complexity is:</p>
<div class="math notranslate nohighlight">
\[\mathcal{T}(n) = \mathcal{O}(\log n)\]</div>
</section>
</section>
<section id="id16">
<h3><a class="toc-backref" href="#id62" role="doc-backlink">Space Complexity</a><a class="headerlink" href="#id16" title="Permalink to this heading">#</a></h3>
<p>For recursive algorithms, the space complexity is often determined by the
maximum depth of the recursion. In other words, it‚Äôs based on the maximum number
of recursive calls that are in progress at the same time.</p>
<p>So the intuition is simple, we already established there can be a maximum of
<span class="math notranslate nohighlight">\(\log n\)</span> splits, thus it follows that the recursion depth is bounded by
<span class="math notranslate nohighlight">\(\log n\)</span>.</p>
<p>The space complexity of a recursive binary search gets divided into three parts:
input, auxiliary, and total space complexity.</p>
<section id="id17">
<h4><a class="toc-backref" href="#id63" role="doc-backlink">Input Space Complexity</a><a class="headerlink" href="#id17" title="Permalink to this heading">#</a></h4>
<p>Input space complexity is the space used to store the input to the problem. For
binary search, the input is the array or list we are searching through, and a
target value.</p>
<p>In most cases, we don‚Äôt consider the space taken by the inputs when analyzing
the space complexity of an algorithm, unless the algorithm modifies the input in
place. But if we do want to consider the input space, that‚Äôs the space taken by
the inputs, which is <span class="math notranslate nohighlight">\(\mathcal{O}(n) + \mathcal{O}(1) = \mathcal{O}(n)\)</span>, where
<span class="math notranslate nohighlight">\(n\)</span> is the length of the array, and <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span> is the space taken by the
target value.</p>
</section>
<section id="id18">
<h4><a class="toc-backref" href="#id64" role="doc-backlink">Auxiliary Space Complexity</a><a class="headerlink" href="#id18" title="Permalink to this heading">#</a></h4>
<p>Auxiliary space complexity is the extra space or temporary space used by an
algorithm. In the case of recursive binary search, we still only need three
variables to hold the left, right, and middle indices (<code class="docutils literal notranslate"><span class="pre">l</span></code>, <code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">mid_index</span></code>).
These variables occupy constant space, so the auxiliary space complexity is
<span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span> per recursive call.</p>
<p>However, because this is a recursive function, we also have to consider the
space taken up by the recursion stack. In the worst-case scenario, binary search
makes <span class="math notranslate nohighlight">\(\mathcal{O}(\log n)\)</span> recursive calls, and each call adds a level to the
stack. So, the auxiliary space complexity in this case is <span class="math notranslate nohighlight">\(\mathcal{O}(\log n)\)</span>.</p>
<p>Note that an iterative implementation of binary search would have a space
complexity of <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>, as it doesn‚Äôt need additional space that grows
with the input size. It only uses a constant amount of space to store the
pointers and the target element.</p>
<p>For the recursive binary search:</p>
<ul class="simple">
<li><p>Each time we make a recursive call, we essentially halve the input size.</p></li>
<li><p>At most, we would need to make <span class="math notranslate nohighlight">\(\log n\)</span> recursive calls (since we are dividing
by 2 each time) before we either find our target or exhaust the list.</p></li>
<li><p>Each of these calls gets pushed onto the call stack.</p></li>
</ul>
<p>Therefore, the maximum height of the call stack, and hence the space complexity
due to the recursive calls, is <span class="math notranslate nohighlight">\(O(\log n)\)</span>.</p>
</section>
<section id="id19">
<h4><a class="toc-backref" href="#id65" role="doc-backlink">Total Space Complexity</a><a class="headerlink" href="#id19" title="Permalink to this heading">#</a></h4>
<p>Total space complexity is the sum of input and auxiliary space complexities. For
binary search, if the input space complexity is not considered and the uses
<span class="math notranslate nohighlight">\(\mathcal{O}(\log n)\)</span> auxiliary space, the total space complexity of recursive
binary search is <span class="math notranslate nohighlight">\(\mathcal{O}(\log n)\)</span>; otherwise, it is <span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span>.</p>
<p>To summarize, the recursive binary search algorithm is still very
space-efficient as it only requires logarithmic auxiliary space to perform the
search, and it does not modify the input array or list.</p>
</section>
</section>
</section>
<section id="when-to-use-binary-search">
<h2><a class="toc-backref" href="#id66" role="doc-backlink">When to use Binary Search?</a><a class="headerlink" href="#when-to-use-binary-search" title="Permalink to this heading">#</a></h2>
<p>If we can discover some kind of <strong>monotonicity</strong>, for example, if <code class="docutils literal notranslate"><span class="pre">condition(k)</span></code>
is <code class="docutils literal notranslate"><span class="pre">True</span></code> then <code class="docutils literal notranslate"><span class="pre">condition(k</span> <span class="pre">+</span> <span class="pre">1)</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then we can consider binary search.</p>
<p>More formally, we have:</p>
<p>The essential precondition to apply binary search is the presence of a
<strong>monotonic property</strong>. This is a property that allows us to decide which half
of the search space should be eliminated based on the comparison between the
target value and the value at the current index.</p>
<div class="proof definition admonition" id="monotonicity">
<p class="admonition-title"><span class="caption-number">Definition 1 </span> (Monotonicity)</p>
<section class="definition-content" id="proof-content">
<p>In more formal terms, a function or sequence is said to have the property of
monotonicity if it is either entirely non-increasing or non-decreasing. A
function that increases monotonically does not necessarily increase constantly,
but it does not decrease at any point. Similarly, a function that decreases
monotonically does not necessarily decrease constantly, but it does not increase
at any point.</p>
<ol class="arabic simple">
<li><p>A sequence or function <span class="math notranslate nohighlight">\(f\)</span> is said to be <strong>monotone increasing</strong> (or
non-decreasing) on an interval <span class="math notranslate nohighlight">\(I\)</span> if for all <span class="math notranslate nohighlight">\(x, y \in I\)</span>, if <span class="math notranslate nohighlight">\(x \leq y\)</span>,
then <span class="math notranslate nohighlight">\(f(x) \leq f(y)\)</span>. In simple terms, as we move along the interval, the
function value does not decrease; it either increases or stays the same.</p></li>
<li><p>Similarly, a sequence or function <span class="math notranslate nohighlight">\(f\)</span> is said to be <strong>monotone decreasing</strong>
(or non-increasing) on an interval <span class="math notranslate nohighlight">\(I\)</span> if for all <span class="math notranslate nohighlight">\(x, y \in I\)</span>, if
<span class="math notranslate nohighlight">\(x \leq y\)</span>, then <span class="math notranslate nohighlight">\(f(x) \geq f(y)\)</span>. That is, as we move along the interval,
the function value does not increase; it either decreases or stays the same.</p></li>
</ol>
</section>
</div><p>In the context of binary search, when the <code class="docutils literal notranslate"><span class="pre">condition</span></code> function has a monotonic
property (either always <code class="docutils literal notranslate"><span class="pre">True</span></code> to <code class="docutils literal notranslate"><span class="pre">False</span></code>, or always <code class="docutils literal notranslate"><span class="pre">False</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>), it
means that there is a clear threshold or tipping point in the sorted array that
divides the array into two halves - the first half where the <code class="docutils literal notranslate"><span class="pre">condition</span></code>
function is <code class="docutils literal notranslate"><span class="pre">True</span></code> and the second half where the <code class="docutils literal notranslate"><span class="pre">condition</span></code> function is <code class="docutils literal notranslate"><span class="pre">False</span></code>
(or vice versa).</p>
<p>That‚Äôs where binary search comes into play: it allows us to effectively locate
that threshold by iteratively narrowing down the search space. If we find that
the <code class="docutils literal notranslate"><span class="pre">condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> for a given middle element (let‚Äôs call it <code class="docutils literal notranslate"><span class="pre">mid</span></code>), we
know that all elements on the right of <code class="docutils literal notranslate"><span class="pre">mid</span></code> will also satisfy <code class="docutils literal notranslate"><span class="pre">condition</span></code>
(because of the monotonic property), so we can safely ignore the right half.
Conversely, if <code class="docutils literal notranslate"><span class="pre">condition(mid)</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, we can ignore the left half.</p>
<p>If we can‚Äôt establish such a monotonic property, it‚Äôs difficult (or even
impossible) to decide which half of the array to eliminate, rendering binary
search ineffective or incorrect. Therefore, confirming the existence of this
monotonicity is crucial before deciding to use binary search.</p>
</section>
<section id="solution-minimize-k-s-t-condition-k-is-true">
<h2><a class="toc-backref" href="#id67" role="doc-backlink">Solution (Minimize <span class="math notranslate nohighlight">\(k\)</span>, <span class="math notranslate nohighlight">\(s.t.\)</span> condition(<span class="math notranslate nohighlight">\(k\)</span>) is True)</a><a class="headerlink" href="#solution-minimize-k-s-t-condition-k-is-true" title="Permalink to this heading">#</a></h2>
<p>Before going into details, we see the below:</p>
<div class="proof remark admonition" id="finding-target-and-finding-first-true">
<p class="admonition-title"><span class="caption-number">Remark 1 </span> (Finding Target and Finding First True)</p>
<section class="remark-content" id="proof-content">
<p>Finding a target in a sorted array and finding the ‚Äúfirst True‚Äù in a sorted
Boolean array are conceptually similar because both rely on a monotonic
condition. In the first case, the condition is ‚ÄúIs the element at the current
index greater or equal to the target?‚Äù In the second case, it‚Äôs ‚ÄúIs the element
at the current index True?‚Äù</p>
<p>To bridge the gap:</p>
<ol class="arabic simple">
<li><p>Consider the feasible function <span class="math notranslate nohighlight">\(f(x)\)</span> that maps each element in the sorted
array to either True or False based on whether the element is greater or
equal to the target. This makes the problem equivalent to finding the ‚Äúfirst
True‚Äù in a sorted Boolean array derived from <span class="math notranslate nohighlight">\(f(x)\)</span>.</p></li>
<li><p>In both problems, once you identify an element that satisfies the condition
(either being the target or being True), you can be sure that no elements
satisfying the condition exist in the half of the array that is ‚Äòless‚Äô than
the current element.</p></li>
</ol>
<p>In the context of finding a specific target element <span class="math notranslate nohighlight">\(x\)</span> in a sorted array, the
feasible function <span class="math notranslate nohighlight">\(f(i)\)</span> would map to True for all elements greater than or
equal to <span class="math notranslate nohighlight">\(x\)</span> and False for all elements less than <span class="math notranslate nohighlight">\(x\)</span>. So, if the array is
<span class="math notranslate nohighlight">\([1, 3, 5, 7]\)</span> and the target is <span class="math notranslate nohighlight">\(5\)</span>, the mapped Boolean array based on <span class="math notranslate nohighlight">\(f(i)\)</span>
would be <span class="math notranslate nohighlight">\(\text{FFFFTTT}\)</span>, making it a sorted Boolean array. In this setup,
‚Äúfinding the first True‚Äù indeed corresponds to ‚Äúfinding the target element.‚Äù</p>
</section>
</div><p>The problem of finding a target number in a sorted array is a ‚Äúminimize k s.t.
condition(k) is True‚Äù problem because you‚Äôre essentially looking for the
smallest (left-most) index <code class="docutils literal notranslate"><span class="pre">k</span></code> where the condition ‚Äúarray value at <code class="docutils literal notranslate"><span class="pre">k</span></code> is
greater than or equal to the target‚Äù is True.</p>
<p>In other words, you‚Äôre trying to find the minimum <code class="docutils literal notranslate"><span class="pre">k</span></code> such that
<code class="docutils literal notranslate"><span class="pre">nums[k]</span> <span class="pre">&gt;=</span> <span class="pre">target</span></code>. This can either be the first occurrence of the target in
the array (if the target exists in the array) or the position where the target
could be inserted to maintain the sorted order of the array (if the target does
not exist in the array).</p>
<p>This fits the structure of ‚Äúminimize k s.t. condition(k) is True‚Äù because you
are minimizing the index <code class="docutils literal notranslate"><span class="pre">k</span></code> subject to a condition (i.e., <code class="docutils literal notranslate"><span class="pre">nums[k]</span> <span class="pre">&gt;=</span> <span class="pre">target</span></code>).</p>
<p>In the binary search template, this is implemented as the <code class="docutils literal notranslate"><span class="pre">condition(mid)</span></code>
function. The binary search algorithm keeps adjusting the search boundaries
(i.e., <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>) based on whether the condition is met at the
mid-point, and keeps narrowing down to the smallest <code class="docutils literal notranslate"><span class="pre">k</span></code> (left-most position)
where the condition is True. This is why this problem fits into the ‚Äúminimize k
s.t. condition(k) is True‚Äù structure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos"> 2</span>    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos"> 3</span>        <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">target</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span>    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
<span class="linenos"> 6</span>    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
<span class="linenos"> 7</span>        <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
<span class="linenos"> 8</span>        <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">mid</span><span class="p">,</span> <span class="n">nums</span><span class="o">=</span><span class="n">nums</span><span class="p">):</span>
<span class="linenos"> 9</span>            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span>
<span class="linenos">10</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">11</span>            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
<span class="linenos">12</span>    <span class="k">return</span> <span class="n">left</span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="c1"># Example 1</span>
<span class="linenos">15</span><span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="linenos">16</span><span class="n">target</span> <span class="o">=</span> <span class="mi">3</span>
<span class="linenos">17</span><span class="n">result</span> <span class="o">=</span> <span class="n">binary_search</span><span class="p">(</span><span class="n">nums</span><span class="o">=</span><span class="n">array</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
<span class="linenos">18</span><span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<p>So you essentially combined the two steps of finding the target and finding the
left-most occurrence of the target into one step.</p>
</section>
<section id="references-and-further-readings">
<h2><a class="toc-backref" href="#id68" role="doc-backlink">References and Further Readings</a><a class="headerlink" href="#references-and-further-readings" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://leetcode.com/explore/learn/card/binary-search/125/template-i/">LeetCode: Binary Search</a></p></li>
<li><p><a class="reference external" href="https://leetcode.com/problems/binary-search/editorial/">LeetCode: Binary Search Editorial</a></p></li>
<li><p><a class="reference external" href="https://www.geeksforgeeks.org/binary-search/">GeeksforGeeks: Binary Search</a></p></li>
<li><p><a class="reference external" href="https://runestone.academy/ns/books/published/pythonds3/SortSearch/TheBinarySearch.html">Runestone Academy: The Binary Search</a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Wikipedia: Binary Search Algorithm</a></p></li>
<li><p><a class="reference external" href="https://algo.monster/problems/binary_search_intro">Algomonster: Binary Search</a></p></li>
<li><p><a class="reference external" href="https://leetcode.com/problems/koko-eating-bananas/solutions/769702/python-clear-explanation-powerful-ultimate-binary-search-template-solved-many-problems/">Generic Template from Leetcode User</a></p></li>
<li><p><a class="reference external" href="http://www.cs.cornell.edu/courses/cs211/2006sp/Lectures/L06-Induction/binary_search.html">Strong Induction - Binary Search Correctness</a></p></li>
</ol>
<hr class="footnotes docutils" />
<aside class="footnote brackets" id="average-case" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">1</a><span class="fn-bracket">]</span></span>
<p>The average case is about the same as the worst case, but if you want to be
pedantic, there is a mathematical derivation in
<a class="reference external" href="https://en.wikipedia.org/wiki/Binary_search_algorithm#Derivation_of_average_case">Wikipedia</a>.</p>
</aside>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./dsa/searching_algorithms/binary_search"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="intro.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Binary Search</p>
      </div>
    </a>
    <a class="right-next"
       href="problems/875-koko-eating-bananas.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Koko Eating Bananas</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#definition">Definition</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithm-iterative-exact-match">Algorithm (Iterative + Exact Match)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pseudocode-iterative">Pseudocode (Iterative)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-representation-recursive">Mathematical Representation (Recursive)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#explanation">Explanation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#correctness">Correctness</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#example">Example</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualization">Visualization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Explanation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#intuition">Intuition</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#assumptions">Assumptions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#constraints">Constraints</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-left-right-2-may-cause-overflow">Why Left + Right // 2 May Cause Overflow?</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#test-cases">Test Cases</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#edge-cases">Edge Cases</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-iterative-find-the-exact-value">Solution (Iterative - Find the Exact Value)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Intuition</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">Visualization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithm">Algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#claim">Claim</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proof">Proof</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implementation">Implementation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tests">Tests</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#time-complexity">Time Complexity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#space-complexity">Space Complexity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#input-space-complexity">Input Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#auxiliary-space-complexity">Auxiliary Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#total-space-complexity">Total Space Complexity</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-recursive-find-the-exact-value">Solution (Recursive - Find the Exact Value)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">Intuition</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">Visualization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">Algorithm</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pseudocode">Pseudocode</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-representation">Mathematical Representation</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">Claim</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">Proof</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">Implementation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">Tests</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">Time Complexity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#master-theorem">Master Theorem</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#repeated-substitution">Repeated Substitution</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">Space Complexity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">Input Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">Auxiliary Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">Total Space Complexity</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#when-to-use-binary-search">When to use Binary Search?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-minimize-k-s-t-condition-k-is-true">Solution (Minimize <span class="math notranslate nohighlight">\(k\)</span>, <span class="math notranslate nohighlight">\(s.t.\)</span> condition(<span class="math notranslate nohighlight">\(k\)</span>) is True)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references-and-further-readings">References and Further Readings</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Gao Hongnan
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      ¬© Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=365ca57ee442770a23c6"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=365ca57ee442770a23c6"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>