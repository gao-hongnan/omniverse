

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Koko Eating Bananas &#8212; Omniverse</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script src="../../../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'dsa/searching_algorithms/binary_search/problems/875-koko-eating-bananas';</script>
    <link rel="canonical" href="https://www.gaohongnan.com/dsa/searching_algorithms/binary_search/problems/875-koko-eating-bananas.html" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Preliminaries" href="../../../../linear_algebra/01_preliminaries/intro.html" />
    <link rel="prev" title="Concept" href="../concept.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../../_static/logo.png" class="logo__image only-light" alt="Omniverse - Home"/>
    <script>document.write(`<img src="../../../../_static/logo.png" class="logo__image only-dark" alt="Omniverse - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Transformers - Attention is All You Need</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../transformer/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../transformer/notations.html">Notations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../transformer/concept.html">Concept</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../transformer/decoder/shakespeare.html">Shakespeare</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Deep Learning</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../deep_learning/training_chronicles/intro.html">Training Chronicles</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../deep_learning/training_chronicles/loss.html">The Loss Landscape</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Software Engineering</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../software_engineering/devops/continuous-integration/styling.html">Styling, Formatting, and Linting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../software_engineering/design_patterns/dependency-inversion-principle.html">Dependency Inversion Principle</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../software_engineering/concurrency_parallelism_asynchronous/intro.html">Concurrency, Parallelism and Asynchronous Programming</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../software_engineering/concurrency_parallelism_asynchronous/generator_yield.html">A Rudimentary Introduction to Generator and Yield in Python</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../software_engineering/serving/restful_api/intro.html">RESTful API</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../software_engineering/serving/restful_api/application_banking.html">Application: Designing a RESTful Banking API with FastAPI and SQLAlchemy</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Computer Science</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../computer_science/type_theory/intro.html">Type Theory, A Very Rudimentary Introduction</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../computer_science/type_theory/01-subtypes.html">Subtypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../computer_science/type_theory/02-type-safety.html">Type Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../computer_science/type_theory/03-subsumption.html">Subsumption</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../computer_science/type_theory/04-generics.html">Generics and Type Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../computer_science/type_theory/05-typevar-bound-constraints.html">Bound and Constraint in Generics and Type Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../computer_science/type_theory/06-invariance-covariance-contravariance.html">Invariance, Covariance and Contravariance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../computer_science/type_theory/07-pep-3124-overloading.html">Function Overloading</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../computer_science/type_theory/08-pep-661-sentinel-values.html">Sentinel Types</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Data Structures and Algorithms</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../complexity_analysis/intro.html">Complexity Analysis</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../complexity_analysis/master_theorem.html">Master Theorem </a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../stack/intro.html">Stack</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../stack/concept.html">Concept</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../linear_search/intro.html">Linear Search</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../linear_search/concept.html">Concept</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../intro.html">Binary Search</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../concept.html">Concept</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Koko Eating Bananas</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Linear Algebra</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../linear_algebra/01_preliminaries/intro.html">Preliminaries</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../linear_algebra/01_preliminaries/01-fields.html">Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../linear_algebra/01_preliminaries/02-systems-of-linear-equations.html">Systems of Linear Equations</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../linear_algebra/02_vectors/intro.html">Vectors</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../linear_algebra/02_vectors/01-vector-definition.html">Vector and Its Definition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../linear_algebra/02_vectors/02-vector-operation.html">Vector and Its Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../linear_algebra/02_vectors/03-vector-norm.html">Vector Norm and Distance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../linear_algebra/02_vectors/04-vector-products.html">A First Look at Vector Products</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References, Resources and Roadmap</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../bibliography.html">Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../../_sources/dsa/searching_algorithms/binary_search/problems/875-koko-eating-bananas.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Koko Eating Bananas</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#learning-objectives">Learning Objectives</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-statement">Problem Statement</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#theoretical-foundations-and-practical-implications">Theoretical Foundations and Practical Implications</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analogy-job-scheduling-in-data-centers">Analogy: Job Scheduling in Data Centers</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#breaking-it-down">Breaking it Down</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-intuition">Problem Intuition</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-naive-approach">A Naive Approach</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reducing-the-search-space">Reducing the Search Space</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#example">Example</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-1-iterative-approach">Example 1: Iterative Approach</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-2-pigeonhole-principle">Example 2: Pigeonhole Principle</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#assumptions-and-constraints">Assumptions and Constraints</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#assumptions">Assumptions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#constraints">Constraints</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#test-cases">Test Cases</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#standard-cases">Standard Cases</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#edge-cases">Edge Cases</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#theoretical-best-time-space-complexity-and-space-time-tradeoff">Theoretical Best Time/Space Complexity and Space-Time Tradeoff</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#theoretical-best-time-complexity">Theoretical Best Time Complexity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#theoretical-best-space-complexity">Theoretical Best Space Complexity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#space-time-tradeoff">Space-Time Tradeoff</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-formulation">Mathematical Formulation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#definitions">Definitions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-binary-search">Solution: Binary Search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-intuition">Solution Intuition</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-precondition-for-binary-search">The Precondition for Binary Search</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#framing-the-problem-as-a-sorted-boolean-array">Framing the Problem as a Sorted Boolean Array</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#feasibility-function">Feasibility Function</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#monotonicity">Monotonicity</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#translating-to-a-first-true-in-a-sorted-boolean-array-problem">Translating to a First True in a Sorted Boolean Array Problem</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualization">Visualization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithm">Algorithm</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#whiteboarding">Whiteboarding</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pseudocode">Pseudocode</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-representation">Mathematical Representation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#correctness">Correctness</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implementation">Implementation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tests">Tests</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#time-complexity">Time Complexity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#function-feasible">Function <code class="docutils literal notranslate"><span class="pre">feasible</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#function-total-hours-to-finish-eating">Function <code class="docutils literal notranslate"><span class="pre">total_hours_to_finish_eating</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#function-mineatingspeed">Function <code class="docutils literal notranslate"><span class="pre">minEatingSpeed</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#best-worst-and-average-case-analysis">Best, Worst, and Average Case Analysis</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#space-complexity">Space Complexity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#input-space-complexity">Input Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#auxiliary-space-complexity">Auxiliary Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#total-space-complexity">Total Space Complexity</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references-and-further-readings">References and Further Readings</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="koko-eating-bananas">
<h1>Koko Eating Bananas<a class="headerlink" href="#koko-eating-bananas" title="Permalink to this heading">#</a></h1>
<p><a class="reference external" href="https://twitter.com/gaohongnan"><img alt="Twitter Handle" src="https://img.shields.io/badge/Twitter-&#64;gaohongnan-blue?style=social&amp;logo=twitter" /></a>
<a class="reference external" href="https://linkedin.com/in/gao-hongnan"><img alt="LinkedIn Profile" src="https://img.shields.io/badge/&#64;gaohongnan-blue?style=social&amp;logo=linkedin" /></a>
<a class="reference external" href="https://colab.research.google.com/github/gao-hongnan/omniverse/blob/main/omniverse/dsa/searching_algorithms/binary_search/problems/875-koko-eating-bananas.ipynb"><img alt="Open in Colab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a>
<a class="reference external" href="https://leetcode.com/problems/koko-eating-bananas/"><img alt="Question Number" src="https://img.shields.io/badge/Question-875-blue" /></a>
<img alt="Difficulty" src="https://img.shields.io/badge/Difficulty-Medium-yellow" />
<img alt="Tag" src="https://img.shields.io/badge/Tag-Array-orange" />
<img alt="Tag" src="https://img.shields.io/badge/Tag-BinarySearch-orange" /></p>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#learning-objectives" id="id4">Learning Objectives</a></p></li>
<li><p><a class="reference internal" href="#introduction" id="id5">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#problem-statement" id="id6">Problem Statement</a></p></li>
<li><p><a class="reference internal" href="#theoretical-foundations-and-practical-implications" id="id7">Theoretical Foundations and Practical Implications</a></p></li>
<li><p><a class="reference internal" href="#analogy-job-scheduling-in-data-centers" id="id8">Analogy: Job Scheduling in Data Centers</a></p>
<ul>
<li><p><a class="reference internal" href="#breaking-it-down" id="id9">Breaking it Down</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#problem-intuition" id="id10">Problem Intuition</a></p>
<ul>
<li><p><a class="reference internal" href="#a-naive-approach" id="id11">A Naive Approach</a></p></li>
<li><p><a class="reference internal" href="#reducing-the-search-space" id="id12">Reducing the Search Space</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#example" id="id13">Example</a></p>
<ul>
<li><p><a class="reference internal" href="#example-1-iterative-approach" id="id14">Example 1: Iterative Approach</a></p></li>
<li><p><a class="reference internal" href="#example-2-pigeonhole-principle" id="id15">Example 2: Pigeonhole Principle</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#assumptions-and-constraints" id="id16">Assumptions and Constraints</a></p>
<ul>
<li><p><a class="reference internal" href="#assumptions" id="id17">Assumptions</a></p></li>
<li><p><a class="reference internal" href="#constraints" id="id18">Constraints</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#test-cases" id="id19">Test Cases</a></p>
<ul>
<li><p><a class="reference internal" href="#standard-cases" id="id20">Standard Cases</a></p></li>
<li><p><a class="reference internal" href="#edge-cases" id="id21">Edge Cases</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#theoretical-best-time-space-complexity-and-space-time-tradeoff" id="id22">Theoretical Best Time/Space Complexity and Space-Time Tradeoff</a></p>
<ul>
<li><p><a class="reference internal" href="#theoretical-best-time-complexity" id="id23">Theoretical Best Time Complexity</a></p></li>
<li><p><a class="reference internal" href="#theoretical-best-space-complexity" id="id24">Theoretical Best Space Complexity</a></p></li>
<li><p><a class="reference internal" href="#space-time-tradeoff" id="id25">Space-Time Tradeoff</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mathematical-formulation" id="id26">Mathematical Formulation</a></p></li>
<li><p><a class="reference internal" href="#definitions" id="id27">Definitions</a></p></li>
<li><p><a class="reference internal" href="#solution-binary-search" id="id28">Solution: Binary Search</a></p>
<ul>
<li><p><a class="reference internal" href="#solution-intuition" id="id29">Solution Intuition</a></p>
<ul>
<li><p><a class="reference internal" href="#the-precondition-for-binary-search" id="id30">The Precondition for Binary Search</a></p></li>
<li><p><a class="reference internal" href="#framing-the-problem-as-a-sorted-boolean-array" id="id31">Framing the Problem as a Sorted Boolean Array</a></p>
<ul>
<li><p><a class="reference internal" href="#feasibility-function" id="id32">Feasibility Function</a></p></li>
<li><p><a class="reference internal" href="#monotonicity" id="id33">Monotonicity</a></p></li>
<li><p><a class="reference internal" href="#translating-to-a-first-true-in-a-sorted-boolean-array-problem" id="id34">Translating to a First True in a Sorted Boolean Array Problem</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#visualization" id="id35">Visualization</a></p></li>
<li><p><a class="reference internal" href="#algorithm" id="id36">Algorithm</a></p>
<ul>
<li><p><a class="reference internal" href="#whiteboarding" id="id37">Whiteboarding</a></p></li>
<li><p><a class="reference internal" href="#pseudocode" id="id38">Pseudocode</a></p></li>
<li><p><a class="reference internal" href="#mathematical-representation" id="id39">Mathematical Representation</a></p></li>
<li><p><a class="reference internal" href="#correctness" id="id40">Correctness</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#implementation" id="id41">Implementation</a></p></li>
<li><p><a class="reference internal" href="#tests" id="id42">Tests</a></p></li>
<li><p><a class="reference internal" href="#time-complexity" id="id43">Time Complexity</a></p>
<ul>
<li><p><a class="reference internal" href="#function-feasible" id="id44">Function <code class="docutils literal notranslate"><span class="pre">feasible</span></code></a></p></li>
<li><p><a class="reference internal" href="#function-total-hours-to-finish-eating" id="id45">Function <code class="docutils literal notranslate"><span class="pre">total_hours_to_finish_eating</span></code></a></p></li>
<li><p><a class="reference internal" href="#function-mineatingspeed" id="id46">Function <code class="docutils literal notranslate"><span class="pre">minEatingSpeed</span></code></a></p></li>
<li><p><a class="reference internal" href="#best-worst-and-average-case-analysis" id="id47">Best, Worst, and Average Case Analysis</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#space-complexity" id="id48">Space Complexity</a></p>
<ul>
<li><p><a class="reference internal" href="#input-space-complexity" id="id49">Input Space Complexity</a></p></li>
<li><p><a class="reference internal" href="#auxiliary-space-complexity" id="id50">Auxiliary Space Complexity</a></p></li>
<li><p><a class="reference internal" href="#total-space-complexity" id="id51">Total Space Complexity</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#references-and-further-readings" id="id52">References and Further Readings</a></p></li>
</ul>
</nav>
<section id="learning-objectives">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Learning Objectives</a><a class="headerlink" href="#learning-objectives" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Understand the problem statement and its significance.</p></li>
<li><p>Develop an intuition for the problem.</p></li>
<li><p>Identify the assumptions and constraints.</p></li>
<li><p>Formulate the problem mathematically.</p></li>
<li><p>Identify the appropriate algorithmic approach.</p></li>
<li><p>Implement the solution and test cases.</p></li>
<li><p>Analyze the time and space complexity.</p></li>
<li><p>Identify the tradeoffs between different approaches (if any).</p></li>
</ul>
</section>
<section id="introduction">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this heading">#</a></h2>
<section id="problem-statement">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Problem Statement</a><a class="headerlink" href="#problem-statement" title="Permalink to this heading">#</a></h3>
<p>Koko loves to eat bananas. There are <code class="docutils literal notranslate"><span class="pre">N</span></code> piles of bananas, the <code class="docutils literal notranslate"><span class="pre">n-th</span></code> pile has
piles <code class="docutils literal notranslate"><span class="pre">piles[n]</span></code> bananas. The guards have gone and will come back in <code class="docutils literal notranslate"><span class="pre">h</span></code> hours.</p>
<p>Koko can decide her bananas-per-hour eating speed of <code class="docutils literal notranslate"><span class="pre">k</span></code>. Each hour, she chooses
some pile of bananas and eats <code class="docutils literal notranslate"><span class="pre">k</span></code> bananas from that pile. If the pile has less
than <code class="docutils literal notranslate"><span class="pre">k</span></code> bananas, she eats all of them instead and will not eat any more bananas
during this hour.</p>
<p>Koko likes to eat slowly but still wants to finish eating all the bananas before
the guards return.</p>
<p>Return the <em>minimum</em> integer <code class="docutils literal notranslate"><span class="pre">k</span></code> such that she can eat all the bananas within
<code class="docutils literal notranslate"><span class="pre">h</span></code> hours.</p>
</section>
<section id="theoretical-foundations-and-practical-implications">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Theoretical Foundations and Practical Implications</a><a class="headerlink" href="#theoretical-foundations-and-practical-implications" title="Permalink to this heading">#</a></h3>
<p>The <strong>Koko Eating Bananas</strong> problem serves as a captivating example of
<a class="reference external" href="https://en.wikipedia.org/wiki/Optimization_problem">optimization problems</a> in
computer science. At a high level, it tackles the challenge of resource
allocation under time constraints. The narrative may involve a monkey and her
bananas, but the core issue is universally relatable: <em>how to perform a set of
tasks in the most efficient manner possible given limited time?</em></p>
<p>If we peel back the layers of this seemingly whimsical problem, we find a
scenario not unlike those encountered in areas like <em>network bandwidth
optimization</em>,
<a class="reference external" href="https://en.wikipedia.org/wiki/Job_shop_scheduling">job scheduling</a> in
multi-core processors, or even time-management strategies in day-to-day
activities. The bananas can be thought of as data packets needing to be
processed, and Koko’s eating speed is akin to a processor’s clock speed.</p>
<p>For readers interested in broader contexts, this problem can be viewed as a
specific case within
<a class="reference external" href="https://en.wikipedia.org/wiki/Combinatorial_optimization">combinatorial optimization</a>
and <a class="reference external" href="https://en.wikipedia.org/wiki/Decision_theory">decision theory</a>. Both are
fields that provide general frameworks for making optimal choices from a finite
set of possibilities.</p>
<p>Solving this problem doesn’t just offer a method for optimizing a peculiar
banana-eating scenario. It provides a framework for tackling a wide range of
real-world optimization challenges. Thus, understanding its solution has both
<em>theoretical</em> and <em>practical</em> significance.</p>
</section>
<section id="analogy-job-scheduling-in-data-centers">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Analogy: Job Scheduling in Data Centers</a><a class="headerlink" href="#analogy-job-scheduling-in-data-centers" title="Permalink to this heading">#</a></h3>
<p>Imagine a <strong><a class="reference external" href="https://en.wikipedia.org/wiki/Data_center">data center</a></strong> where
multiple tasks (akin to the piles of bananas <code class="docutils literal notranslate"><span class="pre">piles</span></code>) need to be processed by a
single server (akin to Koko). The task of the data center manager (akin to the
algorithm <code class="docutils literal notranslate"><span class="pre">minEatingSpeed</span></code> you’re trying to design) is to determine the
<strong>minimum processing power</strong> (<em>speed</em> <code class="docutils literal notranslate"><span class="pre">k</span></code>) each server must have to complete all
tasks within a prescribed time frame (<em>hours</em> <code class="docutils literal notranslate"><span class="pre">h</span></code>).</p>
<section id="breaking-it-down">
<h4><a class="toc-backref" href="#id9" role="doc-backlink">Breaking it Down</a><a class="headerlink" href="#breaking-it-down" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Tasks in Data Center</strong>: These are equivalent to the piles of bananas. Each
task could require different amounts of processing, just as piles can have
different numbers of bananas.</p></li>
<li><p><strong>Processing Power of the Server</strong>: This is akin to the <em>speed</em> <span class="math notranslate nohighlight">\(k\)</span> at which
Koko eats bananas. The faster the processing power, the quicker the tasks get
done.</p></li>
<li><p><strong>Time Frame</strong>: Just as Koko has a deadline <span class="math notranslate nohighlight">\(h\)</span>, the data center has a
<em>service level agreement</em>
(<a class="reference external" href="https://en.wikipedia.org/wiki/Service-level_agreement">SLA</a>) specifying the
maximum time in which all tasks must be completed.</p></li>
<li><p><strong>Optimization</strong>: The challenge lies in finding the <em>minimum server speed</em>
that will allow all tasks to be completed within the time stipulated by the
SLA, much like finding the <em>minimum</em> <span class="math notranslate nohighlight">\(k\)</span> in our problem.</p></li>
</ol>
<p>This is a <strong>real-world issue</strong> with significant implications. Inefficient job
scheduling can lead to increased electricity costs, lower throughput, and
ultimately, less satisfied clients. Thus, solving this problem efficiently has
both <strong>theoretical</strong> and <strong>practical significance</strong> (as mentioned earlier).</p>
<p>By understanding the Koko Eating Bananas problem, you gain insights into how you
might approach job scheduling optimization in a data center, a concept that has
far-reaching applications in the world of
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Cloud_computing">cloud computing</a></strong> and
<strong><a class="reference external" href="https://en.wikipedia.org/wiki/Distributed_computing">distributed systems</a></strong>.</p>
</section>
</section>
</section>
<section id="problem-intuition">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Problem Intuition</a><a class="headerlink" href="#problem-intuition" title="Permalink to this heading">#</a></h2>
<p>In any computational or mathematical endeavor, <strong>intuition</strong> serves as the
<em>compass</em> that guides the journey from problem formulation to solution. While
<strong>assumptions</strong> lay the groundwork and <strong>constraints</strong> define the limits,
intuition enlightens us on the <strong><em>why</em></strong> behind a problem. It acts as the mental
model that helps us navigate the complexities, making the abstract concrete and
the intractable approachable.</p>
<p>Understanding the intuition behind a problem is akin to grasping the motivations
behind a story—it provides <em>context</em>, illuminates <em>significance</em>, and reveals
<em>underlying patterns</em>. It shapes our strategic approach, helping us decide which
algorithms to employ or what data structures would be most effective.</p>
<p>In essence, intuition corresponds to the <strong><em>why</em></strong> that breathes life into the
<strong><em>how</em></strong> and <strong><em>what</em></strong> of problem-solving. Just as a seasoned chess player
instinctively knows which moves lead to victory, a nuanced understanding of
problem intuition equips us with the foresight to make <strong>informed decisions</strong>
and <strong>optimize solutions</strong>.</p>
<section id="a-naive-approach">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">A Naive Approach</a><a class="headerlink" href="#a-naive-approach" title="Permalink to this heading">#</a></h3>
<p>The <strong>straightforward method</strong> to solve this problem is to initialize <span class="math notranslate nohighlight">\(k = 1\)</span>
and incrementally test each value of <span class="math notranslate nohighlight">\(k\)</span> to see if Koko can finish all the
bananas within <span class="math notranslate nohighlight">\(h\)</span> hours.</p>
<p><strong>Why?</strong></p>
<p>This makes sense because we are interested in finding the <strong><em>minimum <span class="math notranslate nohighlight">\(k\)</span></em></strong> that
allows Koko to meet the time constraint. The algorithm proceeds by <em>iteratively
increasing <span class="math notranslate nohighlight">\(k\)</span></em> and stops at the <strong>first <span class="math notranslate nohighlight">\(k\)</span></strong> that allows Koko to consume all
the bananas in <span class="math notranslate nohighlight">\(h\)</span> or <strong><em>fewer</em></strong> hours. This “<em>first</em> <span class="math notranslate nohighlight">\(k\)</span>” will be the
<strong>minimum <span class="math notranslate nohighlight">\(k\)</span></strong> satisfying the given condition.</p>
<p>This <strong>naive approach</strong> has a time complexity of
<span class="math notranslate nohighlight">\(\mathcal{O}(k_{\text{min}} \times N)\)</span>, where <span class="math notranslate nohighlight">\(k_{\text{min}}\)</span> is the <em>smallest
speed</em> at which Koko can consume all the bananas within <span class="math notranslate nohighlight">\(h\)</span> hours, and <span class="math notranslate nohighlight">\(N\)</span> is
the number of piles. Since <span class="math notranslate nohighlight">\(k_{\text{min}}\)</span> is not known in advance and could be
large, this approach can be <strong>computationally expensive</strong> for large datasets or
<strong>tight time constraints</strong>. Therefore, the <strong>crux of the problem</strong> is to find
this <em>optimal <span class="math notranslate nohighlight">\(k\)</span></em> without resorting to such a linear search through all
potential speeds.</p>
</section>
<section id="reducing-the-search-space">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Reducing the Search Space</a><a class="headerlink" href="#reducing-the-search-space" title="Permalink to this heading">#</a></h3>
<p>The observant reader should notice that actually the <span class="math notranslate nohighlight">\(k_{\text{min}}\)</span> is
<strong><em>upper bounded</em></strong> by the <strong>maximum number of bananas in a pile</strong>:</p>
<div class="math notranslate nohighlight">
\[
k_{\text{min}} \leq M := \max(\text{piles})
\]</div>
<p><strong>Why?</strong></p>
<p>Because we know from the <em>constraints</em> that <code class="docutils literal notranslate"><span class="pre">piles.length</span> <span class="pre">&lt;=</span> <span class="pre">h</span></code>. This is an
important observation because it allows us to <strong><em>reduce the search space</em></strong> from
<span class="math notranslate nohighlight">\([1, \infty)\)</span> to <span class="math notranslate nohighlight">\([1, M]\)</span>. We will always yield a solution if Koko is allowed to
eat at a speed of <span class="math notranslate nohighlight">\(M\)</span> bananas per hour. She will always be able to finish all
the bananas in <span class="math notranslate nohighlight">\(h\)</span> hours or fewer. Therefore, we can <strong><em>discard all speeds
greater than</em></strong> <span class="math notranslate nohighlight">\(M\)</span>. So our time complexity for the naive approach becomes
<span class="math notranslate nohighlight">\(\mathcal{O}(M \times N)\)</span> since we will at most iterate through <span class="math notranslate nohighlight">\(M\)</span> speeds.</p>
<p>We will show later that we can further optimize this time complexity to
<span class="math notranslate nohighlight">\(\mathcal{O}(M \log N)\)</span> via a binary search approach.</p>
</section>
</section>
<section id="example">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Example</a><a class="headerlink" href="#example" title="Permalink to this heading">#</a></h2>
<p>In this section, we go through some small example(s) to illustrate the problem.</p>
<section id="example-1-iterative-approach">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Example 1: Iterative Approach</a><a class="headerlink" href="#example-1-iterative-approach" title="Permalink to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span> <span class="p">:</span>
   <span class="n">piles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span>
   <span class="n">h</span>     <span class="o">=</span> <span class="mi">8</span>
<span class="n">Output</span><span class="p">:</span>    <span class="mi">4</span>
</pre></div>
</div>
<p>The question at hand is: What is the minimum speed at which Koko can eat all the
bananas in the piles within <code class="docutils literal notranslate"><span class="pre">h</span></code> hours?</p>
<p>Let’s look at each pile individually and calculate the hours it would take for
Koko to finish each pile at different speeds:</p>
<ul class="simple">
<li><p>At speed 1: Koko would take 3, 6, 7, and 11 hours respectively for each
pile, which sums up to 27 hours in total. This is more than 8 hours, so the
speed is too slow.</p></li>
<li><p>At speed 2: Koko would take 2, 3, 4, and 6 hours respectively for each pile,
which sums up to 15 hours in total. This is still more than 8 hours, so the
speed is still too slow.</p></li>
<li><p>At speed 3: Koko would take 1, 2, 3, and 4 hours respectively for each pile,
which sums up to 10 hours in total. This is still more than 8 hours, so the
speed is still too slow.</p></li>
<li><p>At speed 4: Koko would take 1, 2, 2, and 3 hours respectively for each pile,
which sums up to 8 hours in total. This is exactly the number of hours
available, so the speed is just right.</p></li>
</ul>
<p>Hence, the minimum speed at which Koko can eat all the bananas in the piles
within <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">8</span></code> hours is <code class="docutils literal notranslate"><span class="pre">4</span></code>.</p>
</section>
<section id="example-2-pigeonhole-principle">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Example 2: Pigeonhole Principle</a><a class="headerlink" href="#example-2-pigeonhole-principle" title="Permalink to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span> <span class="p">:</span>
   <span class="n">piles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">20</span><span class="p">],</span>
   <span class="n">h</span>     <span class="o">=</span> <span class="mi">5</span>
<span class="n">Output</span><span class="p">:</span>    <span class="mi">30</span>
</pre></div>
</div>
<p>Again, we are looking for the minimum speed at which Koko can eat all the
bananas in the piles within <code class="docutils literal notranslate"><span class="pre">h</span></code> hours.</p>
<p>Given that there are only 5 hours available and one of the piles itself has 30
bananas, the minimum speed at which Koko must eat to finish just that pile in
time is 30 bananas per hour. Since no pile has more than 30 bananas, a speed of
30 bananas per hour will also suffice for all other piles.</p>
<p><strong>Why?</strong></p>
<p>In the scenario described, Koko has 5 hours to eat all the bananas from 5 piles,
and the largest pile contains 30 bananas. The
<a class="reference external" href="https://en.wikipedia.org/wiki/Pigeonhole_principle"><strong>pigeonhole principle</strong></a>
in this context dictates that each hour must be allocated to a single pile, as
there are exactly as many piles as there are hours.</p>
<p>Since Koko can only eat from one pile each hour and one of those piles has 30
bananas, she must eat at a rate of at least 30 bananas per hour to finish just
that pile in time. If her eating speed were any slower, she would not be able to
finish the largest pile within the allotted hour.</p>
<p>Moreover, because no pile has more than 30 bananas, a speed of 30 bananas per
hour is sufficient for Koko to eat any of the piles within an hour. Therefore,
30 bananas per hour is both a necessary and sufficient speed for Koko to eat all
the bananas from all the piles within the 5 hours.</p>
</section>
</section>
<section id="assumptions-and-constraints">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Assumptions and Constraints</a><a class="headerlink" href="#assumptions-and-constraints" title="Permalink to this heading">#</a></h2>
<p>The relationship between assumptions and constraints in a research or
problem-solving context is akin to the interplay between axioms and theorems in
a mathematical framework. Assumptions serve as the foundational elements upon
which the rest of the work is constructed. They provide the initial conditions
or premises that guide the problem-solving approach. On the other hand,
constraints are often the derived limitations or boundary conditions that
naturally arise from these assumptions.</p>
<div class="proof remark admonition" id="875-koko-eating-bananas-externally-derived-constraints">
<p class="admonition-title"><span class="caption-number">Remark 11 </span> (Externally Derived Constraints)</p>
<section class="remark-content" id="proof-content">
<p>It’s important to understand that constraints can also be externally imposed or
arise from specific practical considerations, rather than being directly derived
from the problem’s assumptions. In such cases, these constraints serve as
additional rules or limitations that must be adhered to when seeking a solution.</p>
</section>
</div><section id="assumptions">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Assumptions</a><a class="headerlink" href="#assumptions" title="Permalink to this heading">#</a></h3>
<p>Assumptions set the stage for problem-solving by defining the initial
conditions, parameters, or rules that are accepted without direct evidence. They
simplify complex situations, making them more manageable and tractable for
analysis or computational modeling.</p>
<p>In the <strong>Koko Eating Bananas</strong> problem, we make the following assumptions:</p>
<ol class="arabic simple">
<li><p><strong>Constant Eating Rate</strong>: Koko can only eat a constant number of bananas per
hour (<code class="docutils literal notranslate"><span class="pre">k</span></code>), from a single pile.</p></li>
<li><p><strong>One Pile at a Time</strong>: Koko will start a new pile only after finishing the
current one.</p></li>
<li><p><strong>Quantized Eating Periods</strong>: If a pile has fewer bananas than <code class="docutils literal notranslate"><span class="pre">k</span></code>, Koko will
take less than an hour to finish that pile but won’t start another pile
within the same hour. This implicitly implies that Koko will not eat any more
bananas from other piles in the same hour even if she finishes eating the
current pile in less than an hour.</p></li>
<li><p><strong>Existence of Solution</strong>: We assume there exists a solution to the problem.
In other words, we assume that there exists a speed <code class="docutils literal notranslate"><span class="pre">k</span></code> such that Koko can
eat all the bananas in <code class="docutils literal notranslate"><span class="pre">h</span></code> hours or fewer.</p></li>
</ol>
</section>
<section id="constraints">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Constraints</a><a class="headerlink" href="#constraints" title="Permalink to this heading">#</a></h3>
<p>These assumptions lead to certain constraints (in no particular order):</p>
<ol class="arabic simple">
<li><p><strong>Minimum Speed</strong>: Koko can’t have a speed of zero; she must eat at least one
banana per hour.</p></li>
<li><p><strong>Time Constraint</strong>: Koko has only <code class="docutils literal notranslate"><span class="pre">h</span></code> hours, a hard deadline to finish
eating all bananas.</p></li>
<li><p><strong>Integer Hours</strong>: Time is quantized in hours. Even if Koko takes less than
an hour to finish a pile, she can’t start another one within the same hour.</p></li>
<li><p><strong>Existence of Solution</strong>: The number of piles is less than or equal to the
number of hours. This is because if the number of piles is greater than the
number of hours, then it is impossible for Koko to eat all the bananas in <code class="docutils literal notranslate"><span class="pre">h</span></code>
hours or fewer.</p></li>
</ol>
<p>In addition, leetcode provides the following constraints:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(1 \leq \text{piles.length} \leq 10^4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{piles.length} \leq h \leq 10^9\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(1 \leq \text{piles[i]} \leq 10^9\)</span></p></li>
</ul>
<p>The additional constraints from LeetCode serve the following purposes:</p>
<ol class="arabic simple">
<li><p><strong>Computational Feasibility</strong>: Limiting the array length and the value of <code class="docutils literal notranslate"><span class="pre">h</span></code>
ensures that the problem can be solved within reasonable computational time,
given the algorithmic techniques that candidates are expected to use.</p></li>
<li><p><strong>Problem Scope</strong>: By setting minimum and maximum values, they define the
problem’s scope more precisely, thereby allowing for standardized assessment
of solutions.</p></li>
<li><p><strong>Avoiding Edge Cases</strong>: Constraints like <span class="math notranslate nohighlight">\(1 \leq \text{piles[i]} \leq 10^9\)</span>
help in removing trivial or degenerate cases, focusing the problem on
meaningful scenarios.</p></li>
<li><p><strong>Algorithmic Complexity</strong>: The constraints provide bounds that can guide the
choice of algorithm, helping one discern whether an <span class="math notranslate nohighlight">\(\mathcal{O}(N \log N)\)</span>
or <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span> algorithm is appropriate, for example.</p></li>
</ol>
</section>
</section>
<section id="test-cases">
<h2><a class="toc-backref" href="#id19" role="doc-backlink">Test Cases</a><a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h2>
<section id="standard-cases">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Standard Cases</a><a class="headerlink" href="#standard-cases" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p><strong>Multiple Piles, Limited Time</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Input:</span> <span class="pre">piles</span> <span class="pre">=</span> <span class="pre">[30,</span> <span class="pre">11,</span> <span class="pre">23,</span> <span class="pre">4,</span> <span class="pre">20],</span> <span class="pre">h</span> <span class="pre">=</span> <span class="pre">6</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Output:</span> <span class="pre">23</span></code></p></li>
<li><p><strong>Explanation</strong>: Koko needs a minimum speed of 23 bananas/hour to finish
all bananas in 6 hours or fewer.</p></li>
</ul>
</li>
</ol>
</section>
<section id="edge-cases">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">Edge Cases</a><a class="headerlink" href="#edge-cases" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p><strong>Single Pile and Minimum Possible Input</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Input:</span> <span class="pre">piles</span> <span class="pre">=</span> <span class="pre">[1],</span> <span class="pre">h</span> <span class="pre">=</span> <span class="pre">1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Output:</span> <span class="pre">1</span></code></p></li>
<li><p><strong>Explanation</strong>: This is the simplest case where the pile has the minimum
number of bananas and Koko has the least amount of time. The speed is also
1 banana/hour.</p></li>
</ul>
</li>
<li><p><strong>Highly Skewed Piles</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Input:</span> <span class="pre">piles</span> <span class="pre">=</span> <span class="pre">[100,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1],</span> <span class="pre">h</span> <span class="pre">=</span> <span class="pre">4</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Output:</span> <span class="pre">100</span></code></p></li>
<li><p><strong>Explanation</strong>: The large pile dictates Koko’s minimum eating speed. Koko
needs to eat at 100 bananas/hour to finish all bananas in 4 hours.</p></li>
</ul>
</li>
<li><p><strong>Large Data Set</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Input:</span> <span class="pre">piles</span> <span class="pre">=</span> <span class="pre">[8]*10^6,</span> <span class="pre">h</span> <span class="pre">=</span> <span class="pre">10^6</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Output:</span> <span class="pre">8</span></code></p></li>
<li><p><strong>Explanation</strong>: This tests the algorithm’s ability to handle
<strong>large-scale scenarios</strong> efficiently. Koko would need to eat at least 8
bananas/hour.</p></li>
</ul>
</li>
</ol>
</section>
</section>
<section id="theoretical-best-time-space-complexity-and-space-time-tradeoff">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">Theoretical Best Time/Space Complexity and Space-Time Tradeoff</a><a class="headerlink" href="#theoretical-best-time-space-complexity-and-space-time-tradeoff" title="Permalink to this heading">#</a></h2>
<p>This section presents a conundrum. Before delving into the algorithmic method,
it’s often
<a class="reference external" href="https://www.techinterviewhandbook.org/software-engineering-interview-guide/"><em>recommended</em></a>
to have a rough intuition on the optimal time and space complexities and their
inherent tradeoffs. However, having this foundational knowledge upfront can
guide us away from futile attempts at chasing an elusive optimal strategy. It
essentially sets a lower boundary for our optimization efforts.</p>
<section id="theoretical-best-time-complexity">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Theoretical Best Time Complexity</a><a class="headerlink" href="#theoretical-best-time-complexity" title="Permalink to this heading">#</a></h3>
<p>In the “Koko Eating Bananas” problem, the goal is to minimize the eating speed
<span class="math notranslate nohighlight">\(k\)</span> such that all bananas are eaten within <span class="math notranslate nohighlight">\(h\)</span> hours. One common algorithmic
approach to solve this problem is using binary search on <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>The binary search would operate on the speed range <span class="math notranslate nohighlight">\([1, M]\)</span>, and for each
candidate speed, we need to traverse all the piles to check if Koko can finish
eating in <span class="math notranslate nohighlight">\(h\)</span> hours. This traversal takes <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span> time where <span class="math notranslate nohighlight">\(N\)</span> is the
length of the <code class="docutils literal notranslate"><span class="pre">piles</span></code> array. Thus, the best theoretical time complexity for
solving this problem would be <span class="math notranslate nohighlight">\(\mathcal{O}(N \log M)\)</span>, where <span class="math notranslate nohighlight">\(M\)</span> is the maximum
number of bananas in a pile.</p>
</section>
<section id="theoretical-best-space-complexity">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">Theoretical Best Space Complexity</a><a class="headerlink" href="#theoretical-best-space-complexity" title="Permalink to this heading">#</a></h3>
<p>For the binary search algorithm, we only need a constant amount of extra space
to store variables such as the low, high, and mid points of the search, as well
as a counter for the total hours Koko would take for a given <span class="math notranslate nohighlight">\(k\)</span>. Therefore, the
space complexity is <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>, which is the best you can achieve for this
problem assuming that the input size is not counted towards the space
complexity.</p>
</section>
<section id="space-time-tradeoff">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">Space-Time Tradeoff</a><a class="headerlink" href="#space-time-tradeoff" title="Permalink to this heading">#</a></h3>
<p>In this specific problem, there’s limited scope for a space-time tradeoff. The
time complexity is primarily determined by the need to iterate over all the
piles for each candidate <span class="math notranslate nohighlight">\(k\)</span>, and this is not something that can be pre-computed
or stored to save time later. Similarly, the space complexity is already at its
theoretical minimum <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>, so there isn’t room for optimization by
using more space.</p>
<p>To sum up, this problem doesn’t offer much room for a space-time tradeoff, given
its constraints and the nature of its optimal solution.</p>
</section>
</section>
<section id="mathematical-formulation">
<h2><a class="toc-backref" href="#id26" role="doc-backlink">Mathematical Formulation</a><a class="headerlink" href="#mathematical-formulation" title="Permalink to this heading">#</a></h2>
<p>First, we will introduce some mathematical notations and definitions to help us
formulate the problem and solution in a more concise manner.</p>
<hr class="docutils" />
<p>Given a sequence of piles,</p>
<div class="math notranslate nohighlight">
\[
\mathcal{P} = \left\{ p_1, p_2, \ldots, p_N \,|\, 1 \leq n \leq N \right\},
\]</div>
<p>each containing a non-negative integer number of bananas, and a positive integer
<span class="math notranslate nohighlight">\(h\)</span> representing the total number of hours available, our goal is to find the
minimum constant integer eating speed <span class="math notranslate nohighlight">\(k\)</span> such that Koko can finish all the
bananas in <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> within <span class="math notranslate nohighlight">\(h\)</span> hours.</p>
<p>For reasons meantioned earlier and in the constraints, we can specify the search
space for <span class="math notranslate nohighlight">\(k\)</span> as:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{K} = \left\{ k \in \mathbb{Z}^+ \,|\, 1 \leq k \leq \max_{n \in [1,N]} p_n \right\}.
\]</div>
<p>For convenience, we also define a shorthand notation for the maximum number of
bananas in a pile:</p>
<div class="math notranslate nohighlight">
\[
M \stackrel{\text{def}}{=} \max_{n \in [1,N]} p_n
\]</div>
<p>In this setting, we define the time <span class="math notranslate nohighlight">\(\mathcal{T}(k, p_n)\)</span> it takes Koko to eat a
pile <span class="math notranslate nohighlight">\(p_n\)</span> at speed <span class="math notranslate nohighlight">\(k\)</span> as:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{T}(k, p_n) = \left \lceil \frac{p_n}{k} \right \rceil
\]</div>
<p>where <span class="math notranslate nohighlight">\(\lceil \cdot \rceil\)</span> is the ceiling function, which rounds a real number
<span class="math notranslate nohighlight">\(x\)</span> <strong><em>up</em></strong> to the nearest integer. For example, <span class="math notranslate nohighlight">\(\lceil 2.3 \rceil = 3\)</span>.</p>
<div class="proof remark admonition" id="875-koko-eating-bananas-why-ceiling">
<p class="admonition-title"><span class="caption-number">Remark 12 </span> (Why ceiling?)</p>
<section class="remark-content" id="proof-content">
<p>Because Koko can only eat a constant number of bananas per hour, so she will
always take at least <span class="math notranslate nohighlight">\(\lceil \frac{p_n}{k} \rceil\)</span> hours to finish a pile <span class="math notranslate nohighlight">\(p_n\)</span>.
Consider <span class="math notranslate nohighlight">\(k=3\)</span> and the pile <span class="math notranslate nohighlight">\(p_n=5\)</span>. Then Koko will take <span class="math notranslate nohighlight">\(2\)</span> hours to finish
this pile. This is because <span class="math notranslate nohighlight">\(\frac{5}{3} = 1.6667\)</span>, which rounds up to <span class="math notranslate nohighlight">\(2\)</span> (of
course you cannot round down).</p>
</section>
</div><p>Consequently, the total time <span class="math notranslate nohighlight">\(\mathcal{H}(k, \mathcal{P})\)</span> required to eat all
the bananas in <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> at speed <span class="math notranslate nohighlight">\(k\)</span> can be expressed as:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{H}\left(k, \mathcal{P}\right) = \sum_{n=1}^{N} \mathcal{T}(k, p_n)
\]</div>
<p>The optimization problem can thus be formally stated as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp; \text{minimize}  &amp;&amp; k \in \mathcal{K} \\
&amp; \text{s.t.}      &amp;&amp; \mathcal{H}\left(k, \mathcal{P}\right) \leq h \\
&amp; \text{where}     &amp;&amp; k, h \in \mathbb{Z}^+, \; \mathcal{K} \subset \mathbb{Z}^+, \; 1 \leq k \leq M
\end{aligned}
\end{split}\]</div>
<p>or equivalently:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp; k^* = \arg\min_{k \in \mathcal{K}} k \\
&amp; \text{s.t.}  \quad &amp; \mathcal{H}\left(k, \mathcal{P}\right) \leq h \\
&amp; \text{where} \quad &amp; k, h \in \mathbb{Z}^+, \; \mathcal{K} \subset \mathbb{Z}^+
\end{aligned}
\end{split}\]</div>
</section>
<section id="definitions">
<h2><a class="toc-backref" href="#id27" role="doc-backlink">Definitions</a><a class="headerlink" href="#definitions" title="Permalink to this heading">#</a></h2>
<p>The definitions of this problem are fairly straightforward and self-contained.
The previous section already introduced most of the necessary definitions.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(p_n\)</span> is the number of bananas in the <span class="math notranslate nohighlight">\(n\)</span>th pile</p></li>
<li><p><span class="math notranslate nohighlight">\(k\)</span> is the speed at which Koko eats bananas</p></li>
<li><p><span class="math notranslate nohighlight">\(h\)</span> is the number of hours Koko has to eat all the bananas</p></li>
<li><p><span class="math notranslate nohighlight">\(N\)</span> is the number of piles</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal{T}(k, p_n) = \left\lceil \frac{p_n}{k} \right\rceil\)</span> is the number
of hours it takes Koko to eat the <span class="math notranslate nohighlight">\(n\)</span>th pile</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal{H}(k, \mathcal{P}) = \sum_{n=1}^{N} \left\lceil \frac{p_n}{k} \right\rceil\)</span>
is the total number of hours it takes Koko to eat all the bananas.</p></li>
<li><p><span class="math notranslate nohighlight">\(M\)</span> is the maximum number of bananas in a pile <span class="math notranslate nohighlight">\(\max_{n \in [1,N]} p_n\)</span>.
This is the upper bound of the search space for <span class="math notranslate nohighlight">\(k\)</span>.</p></li>
</ul>
<p>We include two more definitions here for completeness since we will use it
later.</p>
<ul>
<li><p><strong>Feasibility Function <span class="math notranslate nohighlight">\(\mathcal{F}(\mathcal{P}, k, h)\)</span></strong>: A binary function
indicating whether it is possible to eat all bananas within <span class="math notranslate nohighlight">\(h\)</span> hours at
speed <span class="math notranslate nohighlight">\(k\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
    \mathcal{F}(k, \mathcal{P}, h) =
    \begin{cases}
    1, &amp; \text{if } \mathcal{H}\left(k, \mathcal{P}\right) \leq h \\
    0, &amp; \text{otherwise}
    \end{cases}
    \end{split}\]</div>
</li>
<li><p><strong>Optimal Eating Speed <span class="math notranslate nohighlight">\(k^*\)</span></strong>: The minimum constant integer eating speed
that satisfies the problem’s constraints.</p>
<div class="math notranslate nohighlight">
\[
    k^* = \min \{ k \in \mathcal{K} \,|\, \mathcal{H}\left(k, \mathcal{P}\right) \leq h \}
    \]</div>
</li>
</ul>
</section>
<section id="solution-binary-search">
<h2><a class="toc-backref" href="#id28" role="doc-backlink">Solution: Binary Search</a><a class="headerlink" href="#solution-binary-search" title="Permalink to this heading">#</a></h2>
<p>In solving this problem, the objective is to efficiently identify the minimum
eating speed <span class="math notranslate nohighlight">\(k\)</span> that allows Koko to consume all the bananas in <span class="math notranslate nohighlight">\(h\)</span> hours. A
straightforward method is to iterate over all potential speeds <span class="math notranslate nohighlight">\(k\)</span> in the range
<span class="math notranslate nohighlight">\(1 \leq k \leq M\)</span><a class="footnote-reference brackets" href="#max-of-piles-is-m" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> and evaluate if
<span class="math notranslate nohighlight">\(\mathcal{H}\left(k, \mathcal{P}\right) \leq h\)</span>, where
<span class="math notranslate nohighlight">\(\mathcal{H}\left(k, \mathcal{P}\right)\)</span> represents the hours needed to eat all
bananas at speed <span class="math notranslate nohighlight">\(k\)</span>. This naive approach results in a time complexity of
<span class="math notranslate nohighlight">\(\mathcal{O}(N \times M)\)</span>, which could be computationally prohibitive when <span class="math notranslate nohighlight">\(N\)</span>,
the number of piles, <strong><em>and/or</em></strong> <span class="math notranslate nohighlight">\(M\)</span>, the maximum size of a pile, is large.
However, we can improve this to <span class="math notranslate nohighlight">\(\mathcal{O}(N \log M)\)</span> by employing a binary
search technique.</p>
<section id="solution-intuition">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">Solution Intuition</a><a class="headerlink" href="#solution-intuition" title="Permalink to this heading">#</a></h3>
<p>The first question that arises is, how can we be sure that binary search is an
appropriate technique for solving this problem? The answer often depends on
one’s level of experience. However, beyond experience, there is an underlying
intuition that experienced programmers have developed. This intuition allows
them to instantly recognize problems that are well-suited for binary search. So,
what constitutes this intuition, and how can it be developed? In general, if a
specific type of algorithm adheres to a recognizable pattern or template, then
that pattern serves as the intuition behind choosing that algorithm.</p>
<p>Main intuition following the binary search framework.</p>
<blockquote>
<div><p>Minimize <span class="math notranslate nohighlight">\(k\)</span> such that koko can <em>eat all the bananas within <span class="math notranslate nohighlight">\(h\)</span> hours</em>.</p>
</div></blockquote>
<section id="the-precondition-for-binary-search">
<h4><a class="toc-backref" href="#id30" role="doc-backlink">The Precondition for Binary Search</a><a class="headerlink" href="#the-precondition-for-binary-search" title="Permalink to this heading">#</a></h4>
<p>The main precondition for applying binary search to this problem is the property
of <strong>monotonicity</strong> in the <strong>feasibility</strong>
function<a class="footnote-reference brackets" href="#precondition-of-binary-search" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. If a <strong>feasibility</strong> function
<span class="math notranslate nohighlight">\(\mathcal{F}(\cdot)\)</span> is <strong>monotonic</strong>, then the problem lends itself well to a
binary search solution. Here, the feasible function <span class="math notranslate nohighlight">\(\mathcal{F}(\cdot)\)</span> is a
boolean function that returns either <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, or <code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> since we
want to talk about monotonicity, which is better understood if the output is a
“number”.</p>
<p>The second precondition is implicit. The search space <span class="math notranslate nohighlight">\(\mathcal{K}\)</span> must be
inherently <strong>ordered</strong> in which you can sort it (sortable). This is because
binary search requires the search space to be sorted.</p>
<p>Consequently, the domain of the feasibility function <span class="math notranslate nohighlight">\(\mathcal{F}(\cdot)\)</span> is the
search space <span class="math notranslate nohighlight">\(\mathcal{K}\)</span>, and the range is <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>.</p>
<p>But why is having this monotonicity property important? Why is it that we need
this feasibility function to be monotonic? The reason is that we want to be able
to discard half of the search space at each step. This is the key to binary
search. The connection is that monotonicity implies there is a tipping point.
There exists a <span class="math notranslate nohighlight">\(k\)</span> such that if <span class="math notranslate nohighlight">\(\mathcal{F}(k) = 1\)</span>, then <span class="math notranslate nohighlight">\(\mathcal{F}(k') = 1\)</span>
for all <span class="math notranslate nohighlight">\(k' &gt; k\)</span>.</p>
<p>Understanding the problem through the lens of feasibility and monotonicity lends
itself to the concept of a <em>sorted boolean
array</em><a class="footnote-reference brackets" href="#first-true-in-a-sorted-boolean-array" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> where we can easily apply binary
search!</p>
<p>The only difficulty lies in defining the feasibility function
<span class="math notranslate nohighlight">\(\mathcal{F}(\cdot)\)</span>.</p>
</section>
<section id="framing-the-problem-as-a-sorted-boolean-array">
<h4><a class="toc-backref" href="#id31" role="doc-backlink">Framing the Problem as a Sorted Boolean Array</a><a class="headerlink" href="#framing-the-problem-as-a-sorted-boolean-array" title="Permalink to this heading">#</a></h4>
<section id="feasibility-function">
<h5><a class="toc-backref" href="#id32" role="doc-backlink">Feasibility Function</a><a class="headerlink" href="#feasibility-function" title="Permalink to this heading">#</a></h5>
<p>First, we define the feasibility function formally.</p>
<div class="proof definition admonition" id="875-koko-eating-bananas-feasibility-function">
<p class="admonition-title"><span class="caption-number">Definition 17 </span> (Feasibility Function)</p>
<section class="definition-content" id="proof-content">
<p>The feasibility function <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> is a mapping from a decision variable
<span class="math notranslate nohighlight">\(k \in \mathcal{K}\)</span> and a set of parameters <span class="math notranslate nohighlight">\(\Theta\)</span> to a binary outcome,
subject to a set of constraints <span class="math notranslate nohighlight">\(C\)</span>.</p>
<div class="math notranslate nohighlight">
\[
\mathcal{F}: \mathcal{K} \times \Theta \to \{0, 1\}
\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\mathcal{K}\)</span> is the domain of possible values for the decision variable,
<span class="math notranslate nohighlight">\(\Theta\)</span> represents other relevant parameters, and <span class="math notranslate nohighlight">\(C\)</span> represents the set of
constraints.</p>
<p>The function is defined as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathcal{F}(k, \Theta) = \begin{cases}
1, &amp; \text{if } C(k, \Theta) \text{ is true} \\
0, &amp; \text{otherwise} \end{cases}
\end{split}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(C(k, \Theta)\)</span> is a function that returns <code class="docutils literal notranslate"><span class="pre">True</span></code> (<span class="math notranslate nohighlight">\(1\)</span>) or <code class="docutils literal notranslate"><span class="pre">False</span></code> (<span class="math notranslate nohighlight">\(0\)</span>)
based on whether all constraints are satisfied for the given <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(\Theta\)</span>.</p>
</section>
</div><p>For our problem, the decision variable is <span class="math notranslate nohighlight">\(k\)</span>, the set of parameters is
<span class="math notranslate nohighlight">\(\Theta = \{ \mathcal{P}, h \}\)</span>, and the constraints is just whether Koko can
finish eating all the bananas in <span class="math notranslate nohighlight">\(h\)</span> hours or fewer.</p>
<div class="proof definition admonition" id="875-koko-eating-bananas-feasibility-function-for-koko-eating-bananas">
<p class="admonition-title"><span class="caption-number">Definition 18 </span> (Feasibility Function for Koko Eating Bananas)</p>
<section class="definition-content" id="proof-content">
<p>The feasibility function <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> for the Koko Eating Bananas problem is
defined as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathcal{F}(k, \mathcal{P}, h) = \begin{cases}
1, &amp; \text{if } \mathcal{H}\left(k, \mathcal{P}\right) \leq h \\
0, &amp; \text{otherwise}
\end{cases}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{H}\left(k, \mathcal{P}\right)\)</span> is the total number of hours it
takes Koko to eat all the bananas at speed <span class="math notranslate nohighlight">\(k\)</span>.</p>
</section>
</div><p>This feasibility function looks reasonable, we remain to verify if this function
is monotonic on the search space <span class="math notranslate nohighlight">\(\mathcal{K}\)</span>.</p>
</section>
<section id="monotonicity">
<h5><a class="toc-backref" href="#id33" role="doc-backlink">Monotonicity</a><a class="headerlink" href="#monotonicity" title="Permalink to this heading">#</a></h5>
<p>Here we first define the concept of monotonicity formally.</p>
<div class="proof definition admonition" id="875-koko-eating-bananas-monotonicity">
<p class="admonition-title"><span class="caption-number">Definition 19 </span> (Monotonicity)</p>
<section class="definition-content" id="proof-content">
<p>In the context of a binary search problem, if the feasibility function
<span class="math notranslate nohighlight">\(\mathcal{F}: \mathcal{K} \to \{0, 1\}\)</span> is monotonic over the search space
<span class="math notranslate nohighlight">\(\mathcal{K}\)</span>, it would satisfy one of the following conditions:</p>
<ol class="arabic simple">
<li><p>For all <span class="math notranslate nohighlight">\(k_1, k_2 \in \mathcal{K}\)</span> such that <span class="math notranslate nohighlight">\(k_1 \leq k_2\)</span>, it holds that
<span class="math notranslate nohighlight">\(\mathcal{F}(k_1) \leq \mathcal{F}(k_2)\)</span> (Monotonically Increasing).</p></li>
<li><p>For all <span class="math notranslate nohighlight">\(k_1, k_2 \in \mathcal{K}\)</span> such that <span class="math notranslate nohighlight">\(k_1 \leq k_2\)</span>, it holds that
<span class="math notranslate nohighlight">\(\mathcal{F}(k_1) \geq \mathcal{F}(k_2)\)</span> (Monotonically Decreasing).</p></li>
</ol>
</section>
</div><p>We claim that the feasibility function <span class="math notranslate nohighlight">\(\mathcal{F}(k, \mathcal{P}, h)\)</span> is
<strong><em>monotonically increasing</em></strong>. If Koko can eat all bananas in <span class="math notranslate nohighlight">\(h\)</span> hours at a
speed <span class="math notranslate nohighlight">\(k_1\)</span>, then she can surely do so at any greater speed <span class="math notranslate nohighlight">\(k_2 &gt; k_1\)</span>. Note
that the total number of hours to finish,
<span class="math notranslate nohighlight">\(\mathcal{H}\left(k, \mathcal{P}\right)\)</span>, however, is <strong><em>monotonically
decreasing</em></strong> with respect to <span class="math notranslate nohighlight">\(k\)</span> because if Koko eats faster, she will take
fewer hours to finish.</p>
<p>More concretely:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{F}(\mathcal{P}, k_1, h) = 1 \Rightarrow \mathcal{F}(\mathcal{P},
k_2, h) = 1 \quad \text{for all} \quad k_2 &gt; k_1
\]</div>
<p>The logic</p>
<div class="dropdown admonition">
<p class="admonition-title">Proof</p>
<div class="proof admonition" id="proof">
<p>Proof. We start off by a claim:</p>
<p><strong>Claim</strong>:
<span class="math notranslate nohighlight">\(\mathcal{F}(k_1, \mathcal{P}, h) \leq \mathcal{F}(k_2, \mathcal{P}, h)\)</span> for all
<span class="math notranslate nohighlight">\(k_1 &lt; k_2\)</span>.</p>
<p>In other words, if <span class="math notranslate nohighlight">\(\mathcal{F}(k_1, \mathcal{P}, h) = 1\)</span>, then
<span class="math notranslate nohighlight">\(\mathcal{F}(k_2, \mathcal{P}, h) = 1\)</span> for all <span class="math notranslate nohighlight">\(k_2 &gt; k_1\)</span>.</p>
<p><strong>Proof</strong>:</p>
<p>Given that <span class="math notranslate nohighlight">\(\mathcal{F}(k_1, \mathcal{P}, h) = 1\)</span>, we have:</p>
<div class="math notranslate nohighlight">
\[
\sum_{n=1}^{N} \left \lceil \frac{p_n}{k_1} \right \rceil \leq h
\]</div>
<p>We aim to prove:</p>
<div class="math notranslate nohighlight">
\[
\sum_{n=1}^{N} \left \lceil \frac{p_n}{k_2} \right \rceil \leq h
\]</div>
<p>Since <span class="math notranslate nohighlight">\(k_1 &lt; k_2\)</span>, <span class="math notranslate nohighlight">\(\frac{p_n}{k_1} \geq \frac{p_n}{k_2}\)</span> for all <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>This implies that
<span class="math notranslate nohighlight">\(\left \lceil \frac{p_n}{k_1} \right \rceil \geq \left \lceil \frac{p_n}{k_2} \right \rceil\)</span>
for all <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Hence, if <span class="math notranslate nohighlight">\(\sum_{n=1}^{N} \left \lceil \frac{p_n}{k_1} \right \rceil \leq h\)</span>,
then <span class="math notranslate nohighlight">\(\sum_{n=1}^{N} \left \lceil \frac{p_n}{k_2} \right \rceil \leq h\)</span>.</p>
<p>This concludes the proof that <span class="math notranslate nohighlight">\(\mathcal{F}(k, \mathcal{P}, h)\)</span> is monotonically
increasing with respect to <span class="math notranslate nohighlight">\(k\)</span>.</p>
</div>
</div>
</section>
<section id="translating-to-a-first-true-in-a-sorted-boolean-array-problem">
<h5><a class="toc-backref" href="#id34" role="doc-backlink">Translating to a First True in a Sorted Boolean Array Problem</a><a class="headerlink" href="#translating-to-a-first-true-in-a-sorted-boolean-array-problem" title="Permalink to this heading">#</a></h5>
<p>Given the monotonic property of <span class="math notranslate nohighlight">\(\mathcal{F}\)</span>, we can effectively sort the
boolean outputs of <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> across the search space <span class="math notranslate nohighlight">\(\mathcal{K}\)</span>. That is,
as we traverse <span class="math notranslate nohighlight">\(\mathcal{K}\)</span> from the slowest to the fastest eating speed, the
function <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> will transition from returning <code class="docutils literal notranslate"><span class="pre">False</span></code> to returning
<code class="docutils literal notranslate"><span class="pre">True</span></code>. Our objective is to find the smallest <span class="math notranslate nohighlight">\(k\)</span> for which <span class="math notranslate nohighlight">\(\mathcal{F}\)</span>
returns <code class="docutils literal notranslate"><span class="pre">True</span></code>. Essentially, we have transformed the problem into a <strong><em>first
true in a sorted boolean array</em></strong> problem.</p>
<p>To rigorously connect these ideas, consider the feasibility function
<span class="math notranslate nohighlight">\(\mathcal{F}\)</span> as a sequence
<span class="math notranslate nohighlight">\(\mathcal{F} = \{ \mathcal{F}(\mathcal{P}, k_1, h), \mathcal{F}(\mathcal{P}, k_2, h), \ldots \}\)</span>
where <span class="math notranslate nohighlight">\(k_1 &lt; k_2 &lt; \ldots\)</span> are the sorted eating speeds in <span class="math notranslate nohighlight">\(\mathcal{K}\)</span>. The
sequence <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> is essentially a “Sorted Boolean Array”. Given the
monotonic property of <span class="math notranslate nohighlight">\(\mathcal{F}\)</span>, <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> is a sorted boolean sequence
with a threshold point where it transitions from <code class="docutils literal notranslate"><span class="pre">False</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>. Finding this
point is equivalent to solving the original problem, and binary search is the
efficient way to do it.</p>
<p>Thus, we can see that the Koko Eating Bananas problem is fundamentally a “First
True in a Sorted Boolean Array” problem, revealed through the lens of
feasibility and its monotonic properties:</p>
<ol class="arabic simple">
<li><p><strong>Ordered Search Space</strong>: The space of all possible eating speeds <span class="math notranslate nohighlight">\(k\)</span> is
well-defined and ordered (from 1 to <span class="math notranslate nohighlight">\(M\)</span>).</p></li>
<li><p><strong>Monotonicity of Feasibility</strong>: The problem exhibits a monotonic property
with respect to feasibility; if Koko can finish all the bananas in <span class="math notranslate nohighlight">\(h\)</span> hours
at speed <span class="math notranslate nohighlight">\(k\)</span>, she can also finish them at any speed greater than <span class="math notranslate nohighlight">\(
k\)</span>.</p></li>
<li><p><strong>First True in Sorted Boolean Array</strong>: With the above properties, one can
treat the search space <span class="math notranslate nohighlight">\(\mathcal{K}\)</span> as a sorted boolean array defined by the
feasibility function <span class="math notranslate nohighlight">\(\mathcal{F}\)</span>. The problem reduces to finding the “first
true” in this sorted boolean array.</p></li>
</ol>
<p>To this end, we can reframe the earlier minimization statement:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp; \text{minimize}  &amp;&amp; k \in \mathcal{K} \\
&amp; \text{s.t.}      &amp;&amp; \mathcal{H}\left(k, \mathcal{P}\right) \leq h \\
&amp; \text{where}     &amp;&amp; k, h \in \mathbb{Z}^+, \; \mathcal{K} \subset \mathbb{Z}^+, \; 1 \leq k \leq M
\end{aligned}
\end{split}\]</div>
<p>to</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp; \text{minimize}  &amp;&amp; k \in \mathcal{K} \\
&amp; \text{s.t.}      &amp;&amp; \mathcal{F}(k, \mathcal{P}, h) = 1 \\
&amp; \text{where}     &amp;&amp; k, h \in \mathbb{Z}^+, \; \mathcal{K} \subset \mathbb{Z}^+, \; 1 \leq k \leq M
\end{aligned}
\end{split}\]</div>
</section>
</section>
</section>
<section id="visualization">
<h3><a class="toc-backref" href="#id35" role="doc-backlink">Visualization</a><a class="headerlink" href="#visualization" title="Permalink to this heading">#</a></h3>
<p>Visual representation of the problem and solution (if applicable).</p>
<p>I do not have any visualization, here’s an image of a monkey eating bananas
generated by OpenAI’s DALL·E 3 model xd.</p>
<figure class="align-default" id="koko-eating-bananas-visualization-1">
<img alt="../../../../_images/875-koko-eating-bananas-1.png" src="../../../../_images/875-koko-eating-bananas-1.png" />
<figcaption>
<p><span class="caption-number">Fig. 7 </span><span class="caption-text">Prompt: “Depict Koko, a monkey, voraciously consuming heaps of bananas given to
her, all the while exhibiting signs of trepidation about the guards’ premature
return to apprehend her.” - <strong><em>DALL·E 3</em></strong></span><a class="headerlink" href="#koko-eating-bananas-visualization-1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="algorithm">
<h3><a class="toc-backref" href="#id36" role="doc-backlink">Algorithm</a><a class="headerlink" href="#algorithm" title="Permalink to this heading">#</a></h3>
<section id="whiteboarding">
<h4><a class="toc-backref" href="#id37" role="doc-backlink">Whiteboarding</a><a class="headerlink" href="#whiteboarding" title="Permalink to this heading">#</a></h4>
<p>The domain of our search space is defined as <span class="math notranslate nohighlight">\(k \in [1, \max(\text{{piles}})]\)</span>:</p>
<ul class="simple">
<li><p>The lower bound <span class="math notranslate nohighlight">\(k = 1\)</span> is set because Koko cannot eat 0 bananas per hour.</p></li>
<li><p>The upper bound <span class="math notranslate nohighlight">\(k = \max(\text{{piles}})\)</span> is chosen based on the constraint
that eating at a faster rate than the largest pile is unproductive since
Koko can only eat from one pile at a time.</p></li>
</ul>
<p>The problem lends itself to a binary search approach due to its inherent
monotonicity. To illustrate, consider an example with <code class="docutils literal notranslate"><span class="pre">piles</span> <span class="pre">=</span> <span class="pre">[3,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">11]</span></code>
and <span class="math notranslate nohighlight">\(h = 8\)</span>. The initial search space spans from <span class="math notranslate nohighlight">\(k = 1\)</span> to <span class="math notranslate nohighlight">\(k = 11\)</span>, with a
mid-point at <span class="math notranslate nohighlight">\(k = 6\)</span>.</p>
<p>We then evaluate whether Koko can consume all the bananas within <span class="math notranslate nohighlight">\(h = 8\)</span> hours
at a speed of <span class="math notranslate nohighlight">\(k = 6\)</span> bananas per hour. The answer is affirmative, requiring
<code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">2]</span></code> hours for the respective piles. Consequently, all speeds
<span class="math notranslate nohighlight">\(k' &gt; k = 6\)</span> must also satisfy this condition. This enables us to discard the
right half of the search space, focusing our search on <span class="math notranslate nohighlight">\(k' \leq k = 6\)</span>.</p>
<p>Conversely, if we arrive at an insufficient speed, say <span class="math notranslate nohighlight">\(k = 3\)</span>, then all speeds
<span class="math notranslate nohighlight">\(k' &lt; k = 3\)</span> will also be insufficient. Therefore, we can discard the left half
of the search space, concentrating our search on <span class="math notranslate nohighlight">\(k' \geq k = 3\)</span>.</p>
<p>The monotonic property guarantees that if a speed <span class="math notranslate nohighlight">\(k\)</span> enables Koko to consume
all bananas within <span class="math notranslate nohighlight">\(h\)</span> hours, all speeds <span class="math notranslate nohighlight">\(k' &gt; k\)</span> will also satisfy this
condition. Hence, the binary search can be efficiently employed to halve the
search space iteratively until the minimum <span class="math notranslate nohighlight">\(k\)</span> that meets the requirement is
found.</p>
</section>
<section id="pseudocode">
<h4><a class="toc-backref" href="#id38" role="doc-backlink">Pseudocode</a><a class="headerlink" href="#pseudocode" title="Permalink to this heading">#</a></h4>
<div class="proof algorithm admonition" id="875-koko-eating-bananas-binary-search-pseudocode">
<p class="admonition-title"><span class="caption-number">Algorithm 8 </span> (Binary Search Pseudocode)</p>
<section class="algorithm-content" id="proof-content">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Algorithm</span><span class="p">:</span> <span class="n">min_eating_speed</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

    <span class="n">Input</span><span class="p">:</span> <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="n">p_1</span><span class="p">,</span> <span class="n">p_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">p_N</span><span class="p">]</span> <span class="p">(</span><span class="nb">list</span> <span class="n">of</span> <span class="n">piles</span><span class="p">),</span>
           <span class="n">h</span> <span class="p">(</span><span class="n">total</span> <span class="n">hours</span> <span class="n">available</span><span class="p">),</span>
           <span class="n">M</span> <span class="p">(</span><span class="n">maximum</span> <span class="n">number</span> <span class="n">of</span> <span class="n">bananas</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">pile</span><span class="p">)</span>
    <span class="n">Output</span><span class="p">:</span> <span class="n">k</span><span class="o">*</span> <span class="p">(</span><span class="n">optimal</span> <span class="n">eating</span> <span class="n">speed</span><span class="p">)</span>

    <span class="mi">1</span><span class="p">:</span> <span class="n">Initialize</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="mi">2</span><span class="p">:</span> <span class="n">Initialize</span> <span class="n">r</span> <span class="o">=</span> <span class="n">M</span>

    <span class="mi">3</span><span class="p">:</span> <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="n">do</span>
        <span class="mi">4</span><span class="p">:</span>    <span class="n">m</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="mi">5</span><span class="p">:</span>    <span class="k">if</span> <span class="n">feasible</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="n">then</span>
        <span class="mi">6</span><span class="p">:</span>        <span class="n">r</span> <span class="o">=</span> <span class="n">m</span>
        <span class="mi">7</span><span class="p">:</span>    <span class="k">else</span>
        <span class="mi">8</span><span class="p">:</span>        <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="mi">9</span><span class="p">:</span>    <span class="n">end</span> <span class="k">if</span>

       <span class="mi">10</span><span class="p">:</span> <span class="n">end</span> <span class="k">while</span>

    <span class="mi">11</span><span class="p">:</span> <span class="k">return</span> <span class="n">l</span>
</pre></div>
</div>
</section>
</div></section>
<section id="mathematical-representation">
<h4><a class="toc-backref" href="#id39" role="doc-backlink">Mathematical Representation</a><a class="headerlink" href="#mathematical-representation" title="Permalink to this heading">#</a></h4>
<p>Given the search space <span class="math notranslate nohighlight">\(\mathcal{K}\)</span> and the feasibility function
<span class="math notranslate nohighlight">\(\mathcal{F}(k, \mathcal{P}, h)\)</span>, we seek to find the optimal eating speed <span class="math notranslate nohighlight">\(k^*\)</span>
by exploring <span class="math notranslate nohighlight">\(\mathcal{K}\)</span> via binary search.</p>
<p>We employ binary search in <span class="math notranslate nohighlight">\(\mathcal{K}\)</span>, the search space defined as:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{K} = \{ k \in \mathbb{Z}^+ \,|\, 1 \leq k \leq M \}
\]</div>
<p>The algorithm initiates with the lower bound as <span class="math notranslate nohighlight">\(l = 1\)</span> and the upper bound as
<span class="math notranslate nohighlight">\(r = M\)</span>, and iteratively updates these bounds until <span class="math notranslate nohighlight">\(l \geq r\)</span>. Let <span class="math notranslate nohighlight">\(m_t\)</span> be the
candidate speed at iteration <span class="math notranslate nohighlight">\(t\)</span> calculated as
<span class="math notranslate nohighlight">\(m_t = \left\lfloor \frac{l_t + r_t}{2} \right\rfloor\)</span>.</p>
<p>The algorithm uses these bounds to iteratively tighten the search space.</p>
<ol class="arabic simple">
<li><p><strong>Initialization</strong>:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(l = 1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r = M\)</span></p></li>
</ol>
</li>
<li><p><strong>Iterative Procedure</strong>: For <span class="math notranslate nohighlight">\(k = m_t\)</span>:</p>
<ul class="simple">
<li><p>Compute <span class="math notranslate nohighlight">\(\mathcal{F}(\mathcal{P}, k, h)\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\mathcal{F}(\mathcal{P}, k, h) = 1\)</span>, then <span class="math notranslate nohighlight">\(r_{t+1} = m_t\)</span>.</p></li>
<li><p>Otherwise, <span class="math notranslate nohighlight">\(l_{t+1} = m_t + 1\)</span>.</p></li>
</ul>
</li>
<li><p><strong>Termination</strong>: The algorithm terminates when <span class="math notranslate nohighlight">\(l_{t+1} \geq r_{t+1}\)</span>. The
optimal eating speed <span class="math notranslate nohighlight">\(k^* = l\)</span>.</p></li>
</ol>
</section>
<section id="correctness">
<h4><a class="toc-backref" href="#id40" role="doc-backlink">Correctness</a><a class="headerlink" href="#correctness" title="Permalink to this heading">#</a></h4>
<p>Proving the correctness of a binary search algorithm typically involves
demonstrating two properties: invariance and termination.</p>
<div class="proof admonition" id="proof">
<p>Proof. We prove both properties here.</p>
<p><strong>Invariant</strong>: At each iteration of the binary search, we maintain the invariant
that the optimal eating speed <span class="math notranslate nohighlight">\(k^*\)</span> must lie within the interval <span class="math notranslate nohighlight">\([l, r]\)</span>. This
is because we only adjust <span class="math notranslate nohighlight">\(l\)</span> or <span class="math notranslate nohighlight">\(r\)</span> based on the feasibility function, which
correctly tells us whether a certain speed is too slow (and thus, the optimal
speed must be higher) or feasible (and thus, the optimal speed could be lower or
equal).</p>
<ol class="arabic simple">
<li><p><strong>Initialization</strong>: At the start, <span class="math notranslate nohighlight">\(l = 1\)</span> and <span class="math notranslate nohighlight">\(r = M\)</span>. Clearly, <span class="math notranslate nohighlight">\(k^*\)</span> must
lie within this range because it’s defined to be a positive integer that’s no
greater than <span class="math notranslate nohighlight">\(M\)</span>.</p></li>
<li><p><strong>Maintenance</strong>: At each step, we calculate
<span class="math notranslate nohighlight">\(m = \left\lfloor \frac{l + r}{2} \right\rfloor\)</span>. Then, based on
<span class="math notranslate nohighlight">\(\mathcal{F}(\mathcal{P}, m, h)\)</span>, we either set <span class="math notranslate nohighlight">\(r = m\)</span> or <span class="math notranslate nohighlight">\(l = m + 1\)</span>.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(\mathcal{F}(\mathcal{P}, m, h) = 1\)</span>, meaning that eating speed <span class="math notranslate nohighlight">\(m\)</span> is
feasible, we set <span class="math notranslate nohighlight">\(r = m\)</span>. This is correct because if <span class="math notranslate nohighlight">\(m\)</span> is feasible, then
any speed greater than <span class="math notranslate nohighlight">\(m\)</span> might also be feasible, but the optimal speed
(the smallest feasible speed) must be less than or equal to <span class="math notranslate nohighlight">\(m\)</span>. Hence, we
adjust the interval to <span class="math notranslate nohighlight">\([l, m]\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\mathcal{F}(\mathcal{P}, m, h) = 0\)</span>, meaning that eating speed <span class="math notranslate nohighlight">\(m\)</span> is
not feasible, we set <span class="math notranslate nohighlight">\(l = m + 1\)</span>. This is correct because if <span class="math notranslate nohighlight">\(m\)</span> is not
feasible, then any speed less than <span class="math notranslate nohighlight">\(m\)</span> is also not feasible. Hence, the
optimal speed must be greater than <span class="math notranslate nohighlight">\(m\)</span>, and we adjust the interval to
<span class="math notranslate nohighlight">\([m + 1, r]\)</span>.</p></li>
</ul>
</li>
</ol>
<p>By updating <span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(r\)</span> in this manner, we ensure that the interval <span class="math notranslate nohighlight">\([l, r]\)</span>
always contains <span class="math notranslate nohighlight">\(k^*\)</span>.</p>
<p><strong>Termination</strong>: The algorithm terminates when <span class="math notranslate nohighlight">\(l \geq r\)</span>. Due to the properties
of the floor function and the update rules for <span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(r\)</span>, this condition will
eventually be met. At this point, the interval has been narrowed down to a
single point, <span class="math notranslate nohighlight">\(l\)</span>, which must be the optimal eating speed <span class="math notranslate nohighlight">\(k^*\)</span>. This follows
from the invariant; since <span class="math notranslate nohighlight">\(k^*\)</span> was always within the interval, and the interval
has been reduced to a single point, that point must be <span class="math notranslate nohighlight">\(k^*\)</span>.</p>
</div>
<p>This completes the proof of correctness for the binary search algorithm in the
context of the Koko eating bananas problem. The invariance ensures that the
optimal solution is never excluded from the search space, and the termination
condition guarantees that the algorithm will converge to the optimal solution.</p>
</section>
</section>
<section id="implementation">
<h3><a class="toc-backref" href="#id41" role="doc-backlink">Implementation</a><a class="headerlink" href="#implementation" title="Permalink to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
<span class="linenos"> 2</span>    <span class="k">def</span> <span class="nf">feasible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">piles</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">speed</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos"> 3</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_hours_to_finish_eating</span><span class="p">(</span><span class="n">piles</span><span class="p">,</span> <span class="n">speed</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">h</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span>    <span class="k">def</span> <span class="nf">total_hours_to_finish_eating</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">piles</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">speed</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos"> 6</span>        <span class="n">total_hours</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos"> 7</span>        <span class="k">for</span> <span class="n">pile</span> <span class="ow">in</span> <span class="n">piles</span><span class="p">:</span>
<span class="linenos"> 8</span>            <span class="n">hours</span> <span class="o">=</span> <span class="n">pile</span> <span class="o">/</span> <span class="n">speed</span>  <span class="c1"># num_bananas / speed -&gt; hours needed to finish eating</span>
<span class="linenos"> 9</span>            <span class="n">hours</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">hours</span><span class="p">)</span>  <span class="c1"># if hours = 2.5, it counts at 3</span>
<span class="linenos">10</span>            <span class="n">total_hours</span> <span class="o">+=</span> <span class="n">hours</span>
<span class="linenos">11</span>        <span class="k">return</span> <span class="n">total_hours</span>
<span class="linenos">12</span>
<span class="linenos">13</span>    <span class="k">def</span> <span class="nf">minEatingSpeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">piles</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">h</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">14</span>        <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">piles</span><span class="p">)</span>
<span class="linenos">15</span>
<span class="linenos">16</span>        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
<span class="linenos">17</span>            <span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
<span class="linenos">18</span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">feasible</span><span class="p">(</span><span class="n">piles</span><span class="p">,</span> <span class="n">speed</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">):</span>
<span class="linenos">19</span>                <span class="n">r</span> <span class="o">=</span> <span class="n">m</span>
<span class="linenos">20</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">21</span>                <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
<span class="linenos">22</span>
<span class="linenos">23</span>        <span class="k">return</span> <span class="n">l</span>
</pre></div>
</div>
</div>
</div>
<p>It is worth noting to readers that this approach corresponds more closely to the
<a class="reference external" href="https://leetcode.com/problems/binary-search/editorial/"><strong>approach 3: find lower bound</strong></a>
in Leetcode’s Binary Search editorial.</p>
<p>In binary search and other algorithms, the “lower bound” refers to the smallest
value in a range that meets a specified criterion. This criterion is not
necessarily about being the minimum value in a numerical sense, but rather the
first value in a sorted sequence that satisfies a certain condition. So if we
again look at the problem via the first true in a sorted boolean array lens, the
lower bound is the first <code class="docutils literal notranslate"><span class="pre">True</span></code> value in the sorted boolean array.</p>
</section>
<section id="tests">
<h3><a class="toc-backref" href="#id42" role="doc-backlink">Tests</a><a class="headerlink" href="#tests" title="Permalink to this heading">#</a></h3>
<p>Set of tests for validating the algorithm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># Initialize the TestFramework class</span>
<span class="linenos"> 2</span><span class="n">tf</span> <span class="o">=</span> <span class="n">TestFramework</span><span class="p">()</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="n">minimum_speed</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">minEatingSpeed</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="nd">@tf</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="s2">&quot;Testing minimum_speed function for Koko Eating Bananas&quot;</span><span class="p">)</span>
<span class="linenos"> 7</span><span class="k">def</span> <span class="nf">test_minimum_speed</span><span class="p">():</span>
<span class="linenos"> 8</span>    <span class="nd">@tf</span><span class="o">.</span><span class="n">individual_test</span><span class="p">(</span><span class="s2">&quot;Multiple Piles, Limited Time&quot;</span><span class="p">)</span>
<span class="linenos"> 9</span>    <span class="k">def</span> <span class="nf">_</span><span class="p">():</span>
<span class="linenos">10</span>        <span class="n">tf</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span>
<span class="linenos">11</span>            <span class="n">minimum_speed</span><span class="p">([</span><span class="mi">30</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="mi">6</span><span class="p">),</span>
<span class="linenos">12</span>            <span class="mi">23</span><span class="p">,</span>
<span class="linenos">13</span>            <span class="s2">&quot;Should return 23&quot;</span><span class="p">,</span>
<span class="linenos">14</span>        <span class="p">)</span>
<span class="linenos">15</span>
<span class="linenos">16</span>    <span class="nd">@tf</span><span class="o">.</span><span class="n">individual_test</span><span class="p">(</span><span class="s2">&quot;Single Pile and Minimum Possible Input&quot;</span><span class="p">)</span>
<span class="linenos">17</span>    <span class="k">def</span> <span class="nf">_</span><span class="p">():</span>
<span class="linenos">18</span>        <span class="n">tf</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span><span class="n">minimum_speed</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Should return 1&quot;</span><span class="p">)</span>
<span class="linenos">19</span>
<span class="linenos">20</span>    <span class="nd">@tf</span><span class="o">.</span><span class="n">individual_test</span><span class="p">(</span><span class="s2">&quot;Highly Skewed Piles&quot;</span><span class="p">)</span>
<span class="linenos">21</span>    <span class="k">def</span> <span class="nf">_</span><span class="p">():</span>
<span class="linenos">22</span>        <span class="n">tf</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span><span class="n">minimum_speed</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">100</span><span class="p">,</span> <span class="s2">&quot;Should return 100&quot;</span><span class="p">)</span>
<span class="linenos">23</span>
<span class="linenos">24</span>    <span class="nd">@tf</span><span class="o">.</span><span class="n">individual_test</span><span class="p">(</span><span class="s2">&quot;Large Data Set&quot;</span><span class="p">)</span>
<span class="linenos">25</span>    <span class="k">def</span> <span class="nf">_</span><span class="p">():</span>
<span class="linenos">26</span>        <span class="n">tf</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span><span class="n">minimum_speed</span><span class="p">([</span><span class="mi">8</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">),</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&quot;Should return 8.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><span style='color: blue;'>Description: Testing minimum_speed function for Koko Eating Bananas</span></div><div class="output text_html"><span style='color: green;'>  [Pass]</span> Multiple Piles, Limited Time</div><div class="output text_html"><span style='color: green;'>  [Pass]</span> Single Pile and Minimum Possible Input</div><div class="output text_html"><span style='color: green;'>  [Pass]</span> Highly Skewed Piles</div><div class="output text_html"><span style='color: green;'>  [Pass]</span> Large Data Set</div></div>
</div>
</section>
<section id="time-complexity">
<h3><a class="toc-backref" href="#id43" role="doc-backlink">Time Complexity</a><a class="headerlink" href="#time-complexity" title="Permalink to this heading">#</a></h3>
<div class="proof definition admonition" id="time-complexity">
<p class="admonition-title"><span class="caption-number">Definition 20 </span> (Time Complexity)</p>
<section class="definition-content" id="proof-content">
<p>The Big O notation <span class="math notranslate nohighlight">\(\mathcal{O}(g(n))\)</span> represents a set of functions.
Specifically, a function <span class="math notranslate nohighlight">\(f(n)\)</span> is in <span class="math notranslate nohighlight">\(\mathcal{O}(g(n))\)</span> if there exist
positive constants <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(n_0\)</span> such that for all <span class="math notranslate nohighlight">\(n \geq n_0\)</span>, the inequality
<span class="math notranslate nohighlight">\(f(n) \leq C \cdot g(n)\)</span> holds.</p>
<p>In set notation, <span class="math notranslate nohighlight">\(\mathcal{O}(g(n))\)</span> can be rigorously defined as:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{O}(g(n)) = \{ f(n) : \exists C &gt; 0, \exists n_0 \in \mathbb{N}, \forall n \geq n_0, 0 \leq f(n) \leq C \cdot g(n) \}
\]</div>
<p>In this definition:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(f(n)\)</span> is any function that represents the actual running time of an algorithm
for an input of size <span class="math notranslate nohighlight">\(n\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(g(n)\)</span> is a function that represents the upper bound on the growth rate of
<span class="math notranslate nohighlight">\(f(n)\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(C\)</span> is a constant multiplier that shows <span class="math notranslate nohighlight">\(f(n)\)</span>’s growth rate is at most as
fast as <span class="math notranslate nohighlight">\(C \cdot g(n)\)</span> for sufficiently large <span class="math notranslate nohighlight">\(n\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(n_0\)</span> is a threshold beyond which the inequality <span class="math notranslate nohighlight">\(f(n) \leq C \cdot g(n)\)</span>
consistently holds.</p></li>
</ul>
<p>If an actual time complexity function <span class="math notranslate nohighlight">\(f(n)\)</span> falls within the set defined by
<span class="math notranslate nohighlight">\(\mathcal{O}(g(n))\)</span>, we say that <span class="math notranslate nohighlight">\(f(n)\)</span> is in <span class="math notranslate nohighlight">\(\mathcal{O}(g(n))\)</span>, indicating
that the growth rate of <span class="math notranslate nohighlight">\(f(n)\)</span> is asymptotically upper bounded by <span class="math notranslate nohighlight">\(g(n)\)</span> times
some constant factor.</p>
</section>
</div><p>To analyze the time complexity of the given code, we will break down each
function and its operations. We will denote <span class="math notranslate nohighlight">\(N\)</span> as the length of the <code class="docutils literal notranslate"><span class="pre">piles</span></code>
list.</p>
<p>In our context, <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> represents the function that computes the total
time taken for Koko to finish eating the bananas given a particular eating
speed, while <span class="math notranslate nohighlight">\(\mathcal{J}\)</span> represents the function that determines the minimum
eating speed Koko must have to finish the bananas within <span class="math notranslate nohighlight">\(h\)</span> hours.</p>
<p>Let’s redefine <span class="math notranslate nohighlight">\(\mathcal{T}_{\mathcal{H}}(N)\)</span> and <span class="math notranslate nohighlight">\(\mathcal{T}_{\mathcal{J}}(N)\)</span>
to represent the time complexities of the functions <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> and
<span class="math notranslate nohighlight">\(\mathcal{J}\)</span>, respectively.</p>
<ol class="arabic">
<li><p><strong>Time Complexity Function <span class="math notranslate nohighlight">\(\mathcal{T}(N)\)</span></strong>: This notation represents the
<strong>exact time complexity</strong> or <strong>actual running time</strong> of an algorithm as a
function of the input size <span class="math notranslate nohighlight">\(N\)</span>. It quantifies the precise number of steps or
operations an algorithm takes in relation to the size of its input. For
example, if an algorithm requires <span class="math notranslate nohighlight">\(3N + 5\)</span> operations for an input of size
<span class="math notranslate nohighlight">\(N\)</span>, then its time complexity function is expressed as
<span class="math notranslate nohighlight">\(\mathcal{T}(N) = 3N + 5\)</span>.</p></li>
<li><p><strong>Big O Notation <span class="math notranslate nohighlight">\(\mathcal{O}(g(N))\)</span></strong>: In contrast, Big O notation is used
in <strong>asymptotic analysis</strong> to describe an <strong>upper bound</strong> on the growth rate
of a function. It is defined as a set of functions that grow no faster than
<span class="math notranslate nohighlight">\(g(N)\)</span> times a constant factor for sufficiently large <span class="math notranslate nohighlight">\(N\)</span>. It provides a
simplified description of the algorithm’s behavior for large inputs, focusing
on the dominant term and ignoring lower-order terms and constant factors. For
example, if <span class="math notranslate nohighlight">\(\mathcal{T}(N) = 3N + 5\)</span>, we would say
<span class="math notranslate nohighlight">\(\mathcal{T}(N) \in \mathcal{O}(N)\)</span> because for large <span class="math notranslate nohighlight">\(N\)</span>, the term <span class="math notranslate nohighlight">\(3N\)</span>
dominates, and the running time grows linearly with <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>To formalize, a function <span class="math notranslate nohighlight">\(f(N)\)</span> is in <span class="math notranslate nohighlight">\(\mathcal{O}(g(N))\)</span> if there exist
positive constants <span class="math notranslate nohighlight">\(C\)</span> (the constant factor) and <span class="math notranslate nohighlight">\(N_0\)</span> (the threshold beyond
which the bound holds) such that for all <span class="math notranslate nohighlight">\(N \geq N_0\)</span>, the inequality
<span class="math notranslate nohighlight">\(f(N) \leq C \cdot g(N)\)</span> is satisfied.</p>
</li>
</ol>
<p>Applying this to the example given, if the time complexity function of an
algorithm is <span class="math notranslate nohighlight">\(\mathcal{T}(N) = 3N + 5\)</span>, we identify <span class="math notranslate nohighlight">\(f(N)\)</span> as <span class="math notranslate nohighlight">\(\mathcal{T}(N)\)</span>
and <span class="math notranslate nohighlight">\(g(N)\)</span> as <span class="math notranslate nohighlight">\(N\)</span> in the Big O definition. We can then say that <span class="math notranslate nohighlight">\(\mathcal{T}(N)\)</span>
is in <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span> (or <span class="math notranslate nohighlight">\(\mathcal{T}(N) \in \mathcal{O}(N)\)</span>) because there
exist constants <span class="math notranslate nohighlight">\(C\)</span> (in this case, <span class="math notranslate nohighlight">\(C\)</span> could be <span class="math notranslate nohighlight">\(3\)</span> or any larger number) and
<span class="math notranslate nohighlight">\(N_0\)</span> (which could be <span class="math notranslate nohighlight">\(1\)</span> or any positive integer) such that for all
<span class="math notranslate nohighlight">\(N \geq N_0\)</span>, the running time <span class="math notranslate nohighlight">\(\mathcal{T}(N)\)</span> is bounded above by <span class="math notranslate nohighlight">\(C \cdot N\)</span>.
This indicates that the algorithm’s running time grows linearly or slower as the
input size <span class="math notranslate nohighlight">\(N\)</span> increases.</p>
<blockquote>
<div><p>In essence, <span class="math notranslate nohighlight">\(\mathcal{T}(N)\)</span> gives a precise, often more detailed description
of an algorithm’s running time, while <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span> provides an asymptotic
upper bound that captures the dominant growth behavior for large input sizes.</p>
</div></blockquote>
<section id="function-feasible">
<h4><a class="toc-backref" href="#id44" role="doc-backlink">Function <code class="docutils literal notranslate"><span class="pre">feasible</span></code></a><a class="headerlink" href="#function-feasible" title="Permalink to this heading">#</a></h4>
<p>This function simply calls another function <code class="docutils literal notranslate"><span class="pre">total_hours_to_finish_eating</span></code> and
compares its output to <span class="math notranslate nohighlight">\(h\)</span>. Thus, the time complexity of <code class="docutils literal notranslate"><span class="pre">feasible</span></code> is the same
as that of <code class="docutils literal notranslate"><span class="pre">total_hours_to_finish_eating</span></code>.</p>
</section>
<section id="function-total-hours-to-finish-eating">
<h4><a class="toc-backref" href="#id45" role="doc-backlink">Function <code class="docutils literal notranslate"><span class="pre">total_hours_to_finish_eating</span></code></a><a class="headerlink" href="#function-total-hours-to-finish-eating" title="Permalink to this heading">#</a></h4>
<p>Let <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> be the function representing the computation performed by
<code class="docutils literal notranslate"><span class="pre">total_hours_to_finish_eating</span></code>. This function iterates over each element of
<code class="docutils literal notranslate"><span class="pre">piles</span></code> once and performs a constant number of operations for each pile.</p>
<p>For each pile, there are essentially three operations: division, ceiling, and
addition. Let’s assume the division and ceiling together take a constant time of
2 units (since they are constant-time operations), and the addition takes 1 unit
of time. This leads to a total of 3 operations per pile.</p>
<p>Therefore, the time complexity <span class="math notranslate nohighlight">\(\mathcal{T}_{\mathcal{H}}(N)\)</span> can be expressed
as:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{T}_{\mathcal{H}}(N) = 3N
\]</div>
<p>Therefore, the <strong><em>actual</em></strong> time complexity of <span class="math notranslate nohighlight">\(\mathcal{H}\)</span>, denoted as
<span class="math notranslate nohighlight">\(\mathcal{T}_{\mathcal{H}}(N) \)</span>, is linear in terms of the number of
piles <span class="math notranslate nohighlight">\(N\)</span>,
or in an abuse of notation, <span class="math notranslate nohighlight">\(\mathcal{T}_{\mathcal{H}}(N) = \mathcal{O}(N)\)</span>.</p>
<p>We can further state formally that
<span class="math notranslate nohighlight">\(\mathcal{T}_{\mathcal{H}}(N) \in \mathcal{O}(g(N))\)</span> where</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathcal{O}(g(N)) &amp;= \{ f(N) : \exists C &gt; 0, \exists N_0 \in \mathbb{N}, \forall N \geq N_0, 0 \leq f(N) \leq C \cdot g(N) \} \\
                  &amp;= \{ f(N) : \exists C &gt; 0, \exists N_0 \in \mathbb{N}, \forall N \geq N_0, 0 \leq \mathcal{T}_{\mathcal{H}}(N) \leq C \cdot N \}
\end{aligned}
\end{split}\]</div>
<p>and <span class="math notranslate nohighlight">\(g(N) = N\)</span> is the growth rate of the input size <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>This is also equivalent to saying that</p>
<div class="math notranslate nohighlight">
\[
\mathcal{T}_{\mathcal{H}}(N) \leq C \cdot g(N) \quad \forall N \geq N_0
\]</div>
<p>for some suitable choice of <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(N_0\)</span>.</p>
<p>We can further prove this by finding a suitable <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(N_0\)</span> that satisfies the
inequality.</p>
<p>Proof that <span class="math notranslate nohighlight">\(\mathcal{T}_{\mathcal{H}}(N) = 3N\)</span> is in <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span>:</p>
<div class="proof admonition" id="proof">
<p>Proof. We note that <span class="math notranslate nohighlight">\(g(N) = N\)</span>. We choose <span class="math notranslate nohighlight">\(C = 3\)</span> and <span class="math notranslate nohighlight">\(N_0 = 1\)</span> (since the relation
holds for all positive integers <span class="math notranslate nohighlight">\(N\)</span>). For all <span class="math notranslate nohighlight">\(N \geq N_0\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned} 0 \leq \mathcal{T}_{\mathcal{H}}(N) &amp;= 3N \\ &amp;\leq 3 \cdot N \\
&amp;= C \cdot g(N) \end{aligned}
\end{split}\]</div>
<p>Hence, we have demonstrated that <span class="math notranslate nohighlight">\(\mathcal{T}_{\mathcal{H}}(N) = 3N\)</span> is bounded
above by <span class="math notranslate nohighlight">\(C \cdot g(N)\)</span>, confirming that <span class="math notranslate nohighlight">\(\mathcal{T}_{\mathcal{H}}(N) = O(N)\)</span>.
This shows that the time complexity of the <code class="docutils literal notranslate"><span class="pre">total_hours_to_finish_eating</span></code>
function grows linearly with the number of piles <span class="math notranslate nohighlight">\(N\)</span> and is bounded by a factor
of 3.</p>
</div>
</section>
<section id="function-mineatingspeed">
<h4><a class="toc-backref" href="#id46" role="doc-backlink">Function <code class="docutils literal notranslate"><span class="pre">minEatingSpeed</span></code></a><a class="headerlink" href="#function-mineatingspeed" title="Permalink to this heading">#</a></h4>
<p>This function uses a binary search to find the minimum feasible speed. The
binary search will operate by repeatedly halving the search interval. The
maximum possible number of bananas in a pile, denoted as <span class="math notranslate nohighlight">\(M\)</span>, defines the
initial search space, ranging from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(M\)</span>. Each iteration of the while loop
cuts the search space in half, and the total number of iterations needed will be
<span class="math notranslate nohighlight">\(\log_2 M\)</span>.</p>
<p>Within each iteration of the while loop, the function <code class="docutils literal notranslate"><span class="pre">feasible</span></code> is called,
which in turn calls <code class="docutils literal notranslate"><span class="pre">total_hours_to_finish_eating</span></code>. As we established, the time
complexity for <code class="docutils literal notranslate"><span class="pre">total_hours_to_finish_eating</span></code> is <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span>. Therefore,
the total time complexity for <code class="docutils literal notranslate"><span class="pre">minEatingSpeed</span></code> (we now denote this function as
<span class="math notranslate nohighlight">\(\mathcal{T}_{\mathcal{J}}(M, N)\)</span>) is the product of the number of binary search
iterations and the time complexity of the function called within each iteration:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathcal{T}_{\mathcal{J}}(M, N) &amp;\in \log_2 M \cdot \mathcal{O}(N) \\
                                &amp;=   \mathcal{O}(\log_2 M \cdot N)
\end{aligned}
\end{split}\]</div>
</section>
<section id="best-worst-and-average-case-analysis">
<h4><a class="toc-backref" href="#id47" role="doc-backlink">Best, Worst, and Average Case Analysis</a><a class="headerlink" href="#best-worst-and-average-case-analysis" title="Permalink to this heading">#</a></h4>
<p>In a typical binary search problem, the best, worst, and average case time
complexities are presented below. Please note the <span class="math notranslate nohighlight">\(N\)</span> below is the length of the
search space, in contrast to our <span class="math notranslate nohighlight">\(M\)</span> (so don’t get confused).</p>
<table class="table" id="koko-eating-bananas-best-worst-average-case-analysis-of-binary-search">
<caption><span class="caption-number">Table 14 </span><span class="caption-text">Best, Worst, and Average Case Analysis of Binary Search</span><a class="headerlink" href="#koko-eating-bananas-best-worst-average-case-analysis-of-binary-search" title="Permalink to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Case</p></th>
<th class="head"><p>Worst Case</p></th>
<th class="head"><p>Average Case</p></th>
<th class="head"><p>Best Case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Element is in the list</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{O}(\log_2 N)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{O}(\log_2 N)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Element is not in the list</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{O}(\log_2 N)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{O}(\log_2 N)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{O}(\log_2 N)\)</span></p></td>
</tr>
</tbody>
</table>
<p>In our Koko problem, the element is always in the list. Therefore, we can ignore
the “element is not in the list” case. Furthermore, in each iteration of the
binary search, we need to spend <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span> time to check if the speed is
feasible. Therefore, the best, worst, and average case time complexities for
Koko eating bananas are as follows:</p>
<table class="table" id="koko-eating-bananas-best-worst-average-case-analysis-of-koko-eating-bananas">
<caption><span class="caption-number">Table 15 </span><span class="caption-text">Best, Worst, and Average Case Analysis of Koko Eating Bananas</span><a class="headerlink" href="#koko-eating-bananas-best-worst-average-case-analysis-of-koko-eating-bananas" title="Permalink to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Case</p></th>
<th class="head"><p>Worst Case</p></th>
<th class="head"><p>Average Case</p></th>
<th class="head"><p>Best Case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Element is in the list</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{O}(\log_2 M \cdot N)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{O}(\log_2 M \cdot N)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span></p></td>
</tr>
</tbody>
</table>
<p>In a typical binary search, the best case occurs when the element is at the
midpoint of the search space, resulting in an <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span> complexity since
no further searching is required. The worst and average cases involve more
searching and have a complexity of <span class="math notranslate nohighlight">\(\mathcal{O}(\log_2 N)\)</span>, as you’ve noted.</p>
<p>For the Koko eating bananas problem, however, each iteration of the binary
search involves checking the entire list of piles to see if Koko can eat all the
bananas at a certain rate within <span class="math notranslate nohighlight">\(h\)</span> hours. This checking process has a time
complexity of <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span>. Even in the best case, where the ideal rate is
found in the first try, you still need to perform this check once. Therefore,
the best case complexity would be <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span>, as you need to check every
pile at least once.</p>
</section>
</section>
<section id="space-complexity">
<h3><a class="toc-backref" href="#id48" role="doc-backlink">Space Complexity</a><a class="headerlink" href="#space-complexity" title="Permalink to this heading">#</a></h3>
<p>The space complexity can be broken down into two components: input space
complexity and auxiliary space complexity.</p>
<section id="input-space-complexity">
<h4><a class="toc-backref" href="#id49" role="doc-backlink">Input Space Complexity</a><a class="headerlink" href="#input-space-complexity" title="Permalink to this heading">#</a></h4>
<p>The input for the Koko eating bananas problem is the list of banana piles. This
input occupies <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span> space, where <span class="math notranslate nohighlight">\(N\)</span> is the number of piles. The
speed <span class="math notranslate nohighlight">\(k\)</span> and the hours <span class="math notranslate nohighlight">\(h\)</span> are just integers, so they occupy constant space.</p>
</section>
<section id="auxiliary-space-complexity">
<h4><a class="toc-backref" href="#id50" role="doc-backlink">Auxiliary Space Complexity</a><a class="headerlink" href="#auxiliary-space-complexity" title="Permalink to this heading">#</a></h4>
<p>Auxiliary space refers to the extra space used by an algorithm, not including
the space taken up by the inputs. For the Koko problem, if we are implementing
the binary search iteratively, the auxiliary space complexity would be constant,
<span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>, because we only need a fixed number of variables: one for the
low end of our search space (<code class="docutils literal notranslate"><span class="pre">l</span></code>), one for the high end (<code class="docutils literal notranslate"><span class="pre">r</span></code>), and occasionally
one for the midpoint (<code class="docutils literal notranslate"><span class="pre">m</span></code>) during each iteration of the binary search.</p>
<p>The algorithm does not use any dynamic data structures, like lists or arrays,
that grow with the input size, and there is no recursive stack space to consider
since it’s an iterative approach.</p>
</section>
<section id="total-space-complexity">
<h4><a class="toc-backref" href="#id51" role="doc-backlink">Total Space Complexity</a><a class="headerlink" href="#total-space-complexity" title="Permalink to this heading">#</a></h4>
<p>Total space complexity is the sum of input and auxiliary space complexities.
Since the input space complexity is <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span> and the auxiliary space
complexity is <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>, the total space complexity for the Koko eating
bananas problem is <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span> when considering the input space. If we
choose not to consider the input space, the space complexity remains
<span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>.</p>
<p>In summary, the algorithm for solving the Koko eating bananas problem is
space-efficient, requiring only constant auxiliary space. The total space
complexity is primarily determined by the input size.</p>
</section>
</section>
</section>
<section id="references-and-further-readings">
<h2><a class="toc-backref" href="#id52" role="doc-backlink">References and Further Readings</a><a class="headerlink" href="#references-and-further-readings" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://usaco.guide/silver/binary-search">USACO Guide: Silver Binary Search</a></p></li>
<li><p><a class="reference external" href="https://ramandeepsingh.hashnode.dev/binary-search-identifying-monotonic-patterns">Binary Search: Identifying Monotonic Patterns</a></p></li>
<li><p><a class="reference external" href="https://www.thealgorists.com/Algo/BinarySearch/AdvancedBinarySearch">The Algorists: Advanced Binary Search</a></p></li>
<li><p><a class="reference external" href="https://algo.monster/problems/binary-search-monotonic">Algo Monster: Binary Search Monotonic</a></p></li>
</ul>
<hr class="footnotes docutils" />
<aside class="footnote brackets" id="max-of-piles-is-m" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Recall <span class="math notranslate nohighlight">\(\max(\mathcal{P}) = M\)</span></p>
</aside>
<aside class="footnote brackets" id="precondition-of-binary-search" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>See
<a class="reference external" href="https://usaco.guide/silver/binary-search">Identifying Binary Search Problems</a>
for a detailed discussion on the precondition for binary search.</p>
</aside>
<aside class="footnote brackets" id="first-true-in-a-sorted-boolean-array" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://algo.monster/problems/binary_search_boundary"><strong>First True in a Sorted Boolean Array</strong></a></p>
</aside>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./dsa/searching_algorithms/binary_search/problems"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../concept.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Concept</p>
      </div>
    </a>
    <a class="right-next"
       href="../../../../linear_algebra/01_preliminaries/intro.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Preliminaries</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#learning-objectives">Learning Objectives</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-statement">Problem Statement</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#theoretical-foundations-and-practical-implications">Theoretical Foundations and Practical Implications</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analogy-job-scheduling-in-data-centers">Analogy: Job Scheduling in Data Centers</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#breaking-it-down">Breaking it Down</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-intuition">Problem Intuition</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-naive-approach">A Naive Approach</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reducing-the-search-space">Reducing the Search Space</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#example">Example</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-1-iterative-approach">Example 1: Iterative Approach</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-2-pigeonhole-principle">Example 2: Pigeonhole Principle</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#assumptions-and-constraints">Assumptions and Constraints</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#assumptions">Assumptions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#constraints">Constraints</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#test-cases">Test Cases</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#standard-cases">Standard Cases</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#edge-cases">Edge Cases</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#theoretical-best-time-space-complexity-and-space-time-tradeoff">Theoretical Best Time/Space Complexity and Space-Time Tradeoff</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#theoretical-best-time-complexity">Theoretical Best Time Complexity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#theoretical-best-space-complexity">Theoretical Best Space Complexity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#space-time-tradeoff">Space-Time Tradeoff</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-formulation">Mathematical Formulation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#definitions">Definitions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-binary-search">Solution: Binary Search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-intuition">Solution Intuition</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-precondition-for-binary-search">The Precondition for Binary Search</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#framing-the-problem-as-a-sorted-boolean-array">Framing the Problem as a Sorted Boolean Array</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#feasibility-function">Feasibility Function</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#monotonicity">Monotonicity</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#translating-to-a-first-true-in-a-sorted-boolean-array-problem">Translating to a First True in a Sorted Boolean Array Problem</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualization">Visualization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithm">Algorithm</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#whiteboarding">Whiteboarding</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pseudocode">Pseudocode</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-representation">Mathematical Representation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#correctness">Correctness</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implementation">Implementation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tests">Tests</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#time-complexity">Time Complexity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#function-feasible">Function <code class="docutils literal notranslate"><span class="pre">feasible</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#function-total-hours-to-finish-eating">Function <code class="docutils literal notranslate"><span class="pre">total_hours_to_finish_eating</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#function-mineatingspeed">Function <code class="docutils literal notranslate"><span class="pre">minEatingSpeed</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#best-worst-and-average-case-analysis">Best, Worst, and Average Case Analysis</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#space-complexity">Space Complexity</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#input-space-complexity">Input Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#auxiliary-space-complexity">Auxiliary Space Complexity</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#total-space-complexity">Total Space Complexity</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references-and-further-readings">References and Further Readings</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Gao Hongnan
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>