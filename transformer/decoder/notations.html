
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Notations &#8212; Omniverse</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=bb35926c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script src="../../_static/tabs.js?v=3ee01567"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-MYW5YKC2WF"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-MYW5YKC2WF');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-MYW5YKC2WF');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'transformer/decoder/notations';</script>
    <link rel="canonical" href="https://www.gaohongnan.com/transformer/decoder/notations.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="The Concept of Generative Pre-trained Transformers (GPT)" href="concept.html" />
    <link rel="prev" title="Generative Pre-trained Transformers" href="intro.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Omniverse - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="Omniverse - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    üåå Omniverse: A Journey Through Knowledge
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Notations</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../notations/machine_learning.html">Machine Learning Notations</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Generative Pre-trained Transformer</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="intro.html">Generative Pre-trained Transformers</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="concept.html">The Concept of Generative Pre-trained Transformers (GPT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="implementation.html">The Implementation of Generative Pre-trained Transformers (GPT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="adder.html">Training a Mini-GPT to Learn Two-Digit Addition</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Playbook</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../playbook/how_to_calculate_flops_in_gpt2.html">How to Calculate the Number of FLOPs in GPT-2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../playbook/how_to_inspect_function_and_class_signatures.html">How to Inspect Function and Class Signatures in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../playbook/why_cosine_annealing_warmup_stabilize_training.html">Why Does Cosine Annealing With Warmup Stabilize Training?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../playbook/why_softmax_preserves_order_translation_invariant_not_invariant_scaling.html">Softmax Preserves Order, Is Translation Invariant But Not Invariant Under Scaling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../playbook/how_to_finetune_gpt2.html">How To Fine-Tune GPT-2 To Classify Text</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Deep Learning</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../deep_learning/training_chronicles/intro.html">Training Chronicles</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../deep_learning/training_chronicles/loss.html">The Loss Landscape</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Software Engineering</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../software_engineering/devops/continuous-integration/concept.html">Continuous Integration (CI) Workflow</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../software_engineering/devops/continuous-integration/styling.html">Styling, Formatting, and Linting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../software_engineering/devops/continuous-integration/testing.html">Testing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../software_engineering/design_patterns/dependency-inversion-principle.html">Dependency Inversion Principle</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../software_engineering/concurrency_parallelism_asynchronous/intro.html">Concurrency, Parallelism and Asynchronous Programming</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../software_engineering/concurrency_parallelism_asynchronous/generator_yield.html">A Rudimentary Introduction to Generator and Yield in Python</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../software_engineering/serving/restful_api/intro.html">RESTful API</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../software_engineering/serving/restful_api/application_banking.html">Application: Designing a RESTful Banking API with FastAPI and SQLAlchemy</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Computer Science</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../computer_science/type_theory/intro.html">Type Theory, A Very Rudimentary Introduction</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../computer_science/type_theory/01-subtypes.html">Subtypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../computer_science/type_theory/02-type-safety.html">Type Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../computer_science/type_theory/03-subsumption.html">Subsumption</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../computer_science/type_theory/04-generics.html">Generics and Type Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../computer_science/type_theory/05-typevar-bound-constraints.html">Bound and Constraint in Generics and Type Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../computer_science/type_theory/06-invariance-covariance-contravariance.html">Invariance, Covariance and Contravariance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../computer_science/type_theory/07-pep-3124-overloading.html">Function Overloading</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../computer_science/type_theory/08-pep-661-sentinel-values.html">Sentinel Types</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Data Structures and Algorithms</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../dsa/complexity_analysis/intro.html">Complexity Analysis</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../dsa/complexity_analysis/master_theorem.html">Master Theorem </a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../dsa/stack/intro.html">Stack</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../dsa/stack/concept.html">Concept</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../dsa/searching_algorithms/linear_search/intro.html">Linear Search</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../dsa/searching_algorithms/linear_search/concept.html">Concept</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../dsa/searching_algorithms/binary_search/intro.html">Binary Search</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../dsa/searching_algorithms/binary_search/concept.html">Concept</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dsa/searching_algorithms/binary_search/problems/875-koko-eating-bananas.html">Koko Eating Bananas</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Linear Algebra</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../linear_algebra/01_preliminaries/intro.html">Preliminaries</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../linear_algebra/01_preliminaries/01-fields.html">Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../linear_algebra/01_preliminaries/02-systems-of-linear-equations.html">Systems of Linear Equations</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../linear_algebra/02_vectors/intro.html">Vectors</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-12"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../linear_algebra/02_vectors/01-vector-definition.html">Vector and Its Definition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../linear_algebra/02_vectors/02-vector-operation.html">Vector and Its Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../linear_algebra/02_vectors/03-vector-norm.html">Vector Norm and Distance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../linear_algebra/02_vectors/04-vector-products.html">A First Look at Vector Products</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References, Resources and Roadmap</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../citations.html">IEEE (Style) Citations</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../api/reproducibility.html">API Reference</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/gao-hongnan/omniverse" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/gao-hongnan/omniverse/issues/new?title=Issue%20on%20page%20%2Ftransformer/decoder/notations.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/transformer/decoder/notations.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Notations</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dimensions-and-indexing">Dimensions and Indexing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#general-notations">General Notations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#elementwise-and-vectorwise-operations">Elementwise and Vectorwise Operations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vocabulary">Vocabulary</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#input-sequence">Input Sequence</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#batched-input-sequences">Batched Input Sequences</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#token-to-index-and-index-to-token-mappings">Token to Index, and Index to Token Mappings</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#string-to-index-mapping">String-to-Index Mapping</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#index-to-string-mapping">Index-to-String Mapping</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#one-hot-representation-of-input-sequence-mathbf-x">One-Hot Representation of Input Sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#definition">Definition</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#one-hot-encoding-process">One-Hot Encoding Process</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#batched">Batched</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#weights-and-embeddings">Weights And Embeddings</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matrix-multiplication-primer">Matrix Multiplication Primer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mathbf-x-output-of-the-embedding-layer"><span class="math notranslate nohighlight">\(\mathbf{X}\)</span>: Output of the Embedding Layer</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Definition</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lookup">Lookup</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#semantic-representation">Semantic Representation</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mathbf-w-e-embedding-matrix"><span class="math notranslate nohighlight">\(\mathbf{W}_{e}\)</span>: Embedding Matrix</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pe-positional-encoding-layer"><span class="math notranslate nohighlight">\(PE\)</span>: Positional Encoding Layer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tilde-mathbf-x-output-of-the-positional-encoding-layer"><span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span>: Output of the Positional Encoding Layer</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#layer-normalization">Layer Normalization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#attention-notations">Attention Notations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dimensions">Dimensions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#query-key-and-values">Query, Key and Values</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#general-attention-mechanism">General Attention Mechanism</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-head-attention-for-layer-ell">Multi-Head Attention for Layer <span class="math notranslate nohighlight">\(\ell\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#masked-multi-head-attention-for-decoder-layer-ell">Masked Multi-Head Attention for Decoder Layer <span class="math notranslate nohighlight">\(\ell\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#updated-matrix-description-table-with-batch-and-head-dimensions">Updated Matrix Description Table with Batch and Head Dimensions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#positionwise-feed-forward-networks">Positionwise Feed-Forward Networks</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#independent-processing">Independent Processing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#identical-application">Identical Application</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Definition</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#projection-to-a-higher-dimension-space">Projection to a Higher Dimension Space</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gaussian-error-linear-unit-gelu">Gaussian Error Linear Unit (GELU)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-full-workflow">The Full Workflow</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#autoregressive-self-supervised-learning-paradigm">Autoregressive Self-Supervised Learning Paradigm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#steps">Steps</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iterative-process-through-l-decoder-blocks">Iterative Process Through L Decoder Blocks</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#for-the-first-decoder-block-ell-1">For the First Decoder Block (<span class="math notranslate nohighlight">\(\ell = 1\)</span>)</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#for-subsequent-blocks-ell-1">For Subsequent Blocks (<span class="math notranslate nohighlight">\(\ell &gt; 1\)</span>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#head">Head</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#table">Table</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="notations">
<h1>Notations<a class="headerlink" href="#notations" title="Link to this heading">#</a></h1>
<p><a class="reference external" href="https://twitter.com/gaohongnan"><img alt="Twitter Handle" src="https://img.shields.io/badge/Twitter-&#64;gaohongnan-blue?style=social&amp;logo=twitter" /></a>
<a class="reference external" href="https://linkedin.com/in/gao-hongnan"><img alt="LinkedIn Profile" src="https://img.shields.io/badge/&#64;gaohongnan-blue?style=social&amp;logo=linkedin" /></a>
<a class="reference external" href="https://github.com/gao-hongnan"><img alt="GitHub Profile" src="https://img.shields.io/badge/GitHub-gao--hongnan-lightgrey?style=social&amp;logo=github" /></a>
<img alt="Tag" src="https://img.shields.io/badge/Tag-Organized_Chaos-orange" /></p>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#dimensions-and-indexing" id="id5">Dimensions and Indexing</a></p></li>
<li><p><a class="reference internal" href="#general-notations" id="id6">General Notations</a></p>
<ul>
<li><p><a class="reference internal" href="#elementwise-and-vectorwise-operations" id="id7">Elementwise and Vectorwise Operations</a></p></li>
<li><p><a class="reference internal" href="#vocabulary" id="id8">Vocabulary</a></p></li>
<li><p><a class="reference internal" href="#input-sequence" id="id9">Input Sequence</a></p>
<ul>
<li><p><a class="reference internal" href="#batched-input-sequences" id="id10">Batched Input Sequences</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#token-to-index-and-index-to-token-mappings" id="id11">Token to Index, and Index to Token Mappings</a></p>
<ul>
<li><p><a class="reference internal" href="#string-to-index-mapping" id="id12">String-to-Index Mapping</a></p></li>
<li><p><a class="reference internal" href="#index-to-string-mapping" id="id13">Index-to-String Mapping</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#one-hot-representation-of-input-sequence-mathbf-x" id="id14">One-Hot Representation of Input Sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span></a></p>
<ul>
<li><p><a class="reference internal" href="#definition" id="id15">Definition</a></p></li>
<li><p><a class="reference internal" href="#one-hot-encoding-process" id="id16">One-Hot Encoding Process</a></p></li>
<li><p><a class="reference internal" href="#batched" id="id17">Batched</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#weights-and-embeddings" id="id18">Weights And Embeddings</a></p>
<ul>
<li><p><a class="reference internal" href="#matrix-multiplication-primer" id="id19">Matrix Multiplication Primer</a></p></li>
<li><p><a class="reference internal" href="#mathbf-x-output-of-the-embedding-layer" id="id20"><span class="math notranslate nohighlight">\(\mathbf{X}\)</span>: Output of the Embedding Layer</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id21">Definition</a></p></li>
<li><p><a class="reference internal" href="#lookup" id="id22">Lookup</a></p></li>
<li><p><a class="reference internal" href="#semantic-representation" id="id23">Semantic Representation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mathbf-w-e-embedding-matrix" id="id24"><span class="math notranslate nohighlight">\(\mathbf{W}_{e}\)</span>: Embedding Matrix</a></p></li>
<li><p><a class="reference internal" href="#pe-positional-encoding-layer" id="id25"><span class="math notranslate nohighlight">\(PE\)</span>: Positional Encoding Layer</a></p></li>
<li><p><a class="reference internal" href="#tilde-mathbf-x-output-of-the-positional-encoding-layer" id="id26"><span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span>: Output of the Positional Encoding Layer</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#layer-normalization" id="id27">Layer Normalization</a></p></li>
<li><p><a class="reference internal" href="#attention-notations" id="id28">Attention Notations</a></p>
<ul>
<li><p><a class="reference internal" href="#dimensions" id="id29">Dimensions</a></p></li>
<li><p><a class="reference internal" href="#query-key-and-values" id="id30">Query, Key and Values</a></p></li>
<li><p><a class="reference internal" href="#general-attention-mechanism" id="id31">General Attention Mechanism</a></p></li>
<li><p><a class="reference internal" href="#multi-head-attention-for-layer-ell" id="id32">Multi-Head Attention for Layer <span class="math notranslate nohighlight">\(\ell\)</span></a></p></li>
<li><p><a class="reference internal" href="#masked-multi-head-attention-for-decoder-layer-ell" id="id33">Masked Multi-Head Attention for Decoder Layer <span class="math notranslate nohighlight">\(\ell\)</span></a></p></li>
<li><p><a class="reference internal" href="#updated-matrix-description-table-with-batch-and-head-dimensions" id="id34">Updated Matrix Description Table with Batch and Head Dimensions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#positionwise-feed-forward-networks" id="id35">Positionwise Feed-Forward Networks</a></p>
<ul>
<li><p><a class="reference internal" href="#independent-processing" id="id36">Independent Processing</a></p></li>
<li><p><a class="reference internal" href="#identical-application" id="id37">Identical Application</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id38">Definition</a></p></li>
<li><p><a class="reference internal" href="#projection-to-a-higher-dimension-space" id="id39">Projection to a Higher Dimension Space</a></p></li>
<li><p><a class="reference internal" href="#gaussian-error-linear-unit-gelu" id="id40">Gaussian Error Linear Unit (GELU)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-full-workflow" id="id41">The Full Workflow</a></p>
<ul>
<li><p><a class="reference internal" href="#autoregressive-self-supervised-learning-paradigm" id="id42">Autoregressive Self-Supervised Learning Paradigm</a></p></li>
<li><p><a class="reference internal" href="#steps" id="id43">Steps</a></p></li>
<li><p><a class="reference internal" href="#iterative-process-through-l-decoder-blocks" id="id44">Iterative Process Through L Decoder Blocks</a></p>
<ul>
<li><p><a class="reference internal" href="#for-the-first-decoder-block-ell-1" id="id45">For the First Decoder Block (<span class="math notranslate nohighlight">\(\ell = 1\)</span>)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#for-subsequent-blocks-ell-1" id="id46">For Subsequent Blocks (<span class="math notranslate nohighlight">\(\ell &gt; 1\)</span>)</a></p></li>
<li><p><a class="reference internal" href="#head" id="id47">Head</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#table" id="id48">Table</a></p></li>
<li><p><a class="reference internal" href="#references" id="id49">References</a></p></li>
</ul>
</nav>
<section id="dimensions-and-indexing">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Dimensions and Indexing</a><a class="headerlink" href="#dimensions-and-indexing" title="Link to this heading">#</a></h2>
<p>This section outlines the common dimensions and indexing conventions utilized in
the Transformer model.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathcal{B}\)</span>: The minibatch size.</p></li>
<li><p><span class="math notranslate nohighlight">\(D\)</span>: Embedding dimension. In the original Transformer paper, this is
represented as <span class="math notranslate nohighlight">\(d_{\text{model}}\)</span>.</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(d\)</span>: Index within the embedding vector, where <span class="math notranslate nohighlight">\(0 \leq d &lt; D\)</span>.</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(T\)</span>: Sequence length.</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(t\)</span>: Positional index of a token within the sequence, where
<span class="math notranslate nohighlight">\(0 \leq t &lt; T\)</span>.</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(V\)</span>: Size of the vocabulary.</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(j\)</span>: Index of a word in the vocabulary, where <span class="math notranslate nohighlight">\(0 \leq j &lt; V\)</span>.</p></li>
</ul>
</li>
</ul>
</section>
<section id="general-notations">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">General Notations</a><a class="headerlink" href="#general-notations" title="Link to this heading">#</a></h2>
<section id="elementwise-and-vectorwise-operations">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Elementwise and Vectorwise Operations</a><a class="headerlink" href="#elementwise-and-vectorwise-operations" title="Link to this heading">#</a></h3>
<p>Element-wise operations like dropout or activation functions are applied to each
element of a tensor independently. For example, applying the ReLU activation
function to a tensor <span class="math notranslate nohighlight">\(\mathbf{X} \in \mathbb{R}^{B \times T \times D}\)</span> results
in a tensor of the same shape, where the ReLU function is applied to each
element of <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> independently (i.e. you can think of it as applying the
ReLU a total of <span class="math notranslate nohighlight">\(B \times T \times D\)</span> times).</p>
<p>For vector-wise operations, the operation is applied to each vector along a
specific <em>dimension</em> or <em>axis</em> of the tensor. For example, applying layer
normalization to a tensor <span class="math notranslate nohighlight">\(\mathbf{X} \in \mathbb{R}^{B \times T \times D}\)</span> will
apply the normalization operation to each vector along the feature dimension <span class="math notranslate nohighlight">\(D\)</span>
independently. This means that the normalization operation is applied to each
vector of size <span class="math notranslate nohighlight">\(D\)</span> independently across all batches and sequence positions. You
can then think of the normalization operation as being applied a total of
<span class="math notranslate nohighlight">\(B \times T\)</span> times.</p>
</section>
<section id="vocabulary">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Vocabulary</a><a class="headerlink" href="#vocabulary" title="Link to this heading">#</a></h3>
<p><span class="math notranslate nohighlight">\(\mathcal{V}\)</span>: The set of all unique words in the vocabulary, defined as:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{V} = \{w_1, w_2, \ldots, w_V\}
\]</div>
<p>where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(V\)</span> (denoted as <span class="math notranslate nohighlight">\(|\mathcal{V}|\)</span>): The size of the vocabulary.</p></li>
<li><p><span class="math notranslate nohighlight">\(w_j\)</span>: A unique word in the vocabulary <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>, where
<span class="math notranslate nohighlight">\(w_j \in \mathcal{V}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(j\)</span>: The index of a word in <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>, explicitly defined as
<span class="math notranslate nohighlight">\(0 \leq j \leq V\)</span>.</p></li>
</ul>
<p>For example, consider the following sentences in the training set:</p>
<ul class="simple">
<li><p>‚Äúcat eat mouse‚Äù</p></li>
<li><p>‚Äúdog chase cat‚Äù</p></li>
<li><p>‚Äúmouse eat cheese‚Äù</p></li>
</ul>
<p>The resulting vocabulary <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> is:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{V} = \{\text{cat}, \text{eat}, \text{mouse}, \text{dog}, \text{chase}, \text{cheese}\}
\]</div>
<p>where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(V = 6\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(w_1 = \text{cat}, w_2 = \text{eat}, w_3 = \text{mouse}, w_4 = \text{dog}, w_5 = \text{chase}, w_6 = \text{cheese}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(j = 1, 2, \ldots, 6\)</span>.</p></li>
</ul>
<p>Note: Depending on the transformer model, special tokens (e.g., <code class="docutils literal notranslate"><span class="pre">[PAD]</span></code>,
<code class="docutils literal notranslate"><span class="pre">[CLS]</span></code>, <code class="docutils literal notranslate"><span class="pre">[BOS]</span></code>, <code class="docutils literal notranslate"><span class="pre">[EOS]</span></code>, <code class="docutils literal notranslate"><span class="pre">[UNK]</span></code>, etc.) may also be included in <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>.</p>
</section>
<section id="input-sequence">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Input Sequence</a><a class="headerlink" href="#input-sequence" title="Link to this heading">#</a></h3>
<p>The input sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> for a GPT model is defined as a sequence of <span class="math notranslate nohighlight">\(T\)</span>
tokens. Each token in this sequence is typically represented as an integer that
corresponds to a position in the vocabulary set <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>. The sequence is
represented as:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x} = (x_1, x_2, \ldots, x_T) \in \mathbb{Z}^{1 \times T}
\]</div>
<p>where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T\)</span>: Total length of the sequence. It denotes the number of tokens in the
sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(x_t\)</span>: Represents a token at position <span class="math notranslate nohighlight">\(t\)</span> within the sequence. Each token
<span class="math notranslate nohighlight">\(x_t\)</span> is an integer where <span class="math notranslate nohighlight">\(0 \leq x_t &lt; V\)</span>. Here, <span class="math notranslate nohighlight">\(V\)</span> is the size of the
vocabulary, and each integer corresponds to a unique word or symbol in
<span class="math notranslate nohighlight">\(\mathcal{V}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(t\)</span>: The index of a token within the sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>, where
<span class="math notranslate nohighlight">\(1 \leq t \leq T\)</span>.</p></li>
</ul>
<section id="batched-input-sequences">
<h4><a class="toc-backref" href="#id10" role="doc-backlink">Batched Input Sequences</a><a class="headerlink" href="#batched-input-sequences" title="Link to this heading">#</a></h4>
<p>In practice, GPT models are often trained on batches of sequences to improve
computational efficiency. A batched input is represented as
<span class="math notranslate nohighlight">\(\mathbf{x}^{\mathcal{B}}\)</span>, where <span class="math notranslate nohighlight">\(\mathcal{B}\)</span> denotes the batch size. The
batched input <span class="math notranslate nohighlight">\(\mathbf{x}^{\mathcal{B}}\)</span> can be visualized as a matrix:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{x}^{\mathcal{B}} = \begin{bmatrix}
x_{1,1} &amp; x_{1,2} &amp; \cdots &amp; x_{1,T} \\
x_{2,1} &amp; x_{2,2} &amp; \cdots &amp; x_{2,T} \\
\vdots  &amp; \vdots  &amp; \ddots &amp; \vdots  \\
x_{\mathcal{B},1} &amp; x_{\mathcal{B},2} &amp; \cdots &amp; x_{\mathcal{B},T}
\end{bmatrix} \in \mathbb{Z}^{\mathcal{B} \times T}
\end{split}\]</div>
<p>In this matrix:</p>
<ul class="simple">
<li><p>Each row corresponds to a sequence in the batch.</p></li>
<li><p>Each column corresponds to a token position across all sequences in the
batch.</p></li>
<li><p><span class="math notranslate nohighlight">\(x_{b,t}\)</span> refers to the token at position <span class="math notranslate nohighlight">\(t\)</span> in sequence <span class="math notranslate nohighlight">\(b\)</span>, with
<span class="math notranslate nohighlight">\(1 \leq b \leq \mathcal{B}\)</span> and <span class="math notranslate nohighlight">\(1 \leq t \leq T\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(V\)</span> are as defined previously.</p></li>
</ul>
</section>
</section>
<section id="token-to-index-and-index-to-token-mappings">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Token to Index, and Index to Token Mappings</a><a class="headerlink" href="#token-to-index-and-index-to-token-mappings" title="Link to this heading">#</a></h3>
<section id="string-to-index-mapping">
<h4><a class="toc-backref" href="#id12" role="doc-backlink">String-to-Index Mapping</a><a class="headerlink" href="#string-to-index-mapping" title="Link to this heading">#</a></h4>
<div class="math notranslate nohighlight">
\[
f_{\text{stoi}} : \mathcal{V} \to \{0, 1, \ldots, V-1\}
\]</div>
<ul class="simple">
<li><p><strong>Function</strong>: <span class="math notranslate nohighlight">\(f_{\text{stoi}}\)</span></p></li>
<li><p><strong>Domain</strong>: <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>, the set of all tokens in the vocabulary.</p></li>
<li><p><strong>Codomain</strong>: <span class="math notranslate nohighlight">\(\{0, 1, \ldots, V-1\}\)</span>, where <span class="math notranslate nohighlight">\(V\)</span> is the size of the
vocabulary.</p></li>
<li><p><strong>Purpose</strong>: This function maps each token (word) from the vocabulary to a
unique index. For a token <span class="math notranslate nohighlight">\(w \in \mathcal{V}\)</span>, the value
<span class="math notranslate nohighlight">\(f_{\text{stoi}}(w) = j\)</span> indicates that the token <span class="math notranslate nohighlight">\(w\)</span> corresponds to the
<span class="math notranslate nohighlight">\(j\)</span>-th position in the vocabulary <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>.</p></li>
<li><p><strong>Example</strong>: If <span class="math notranslate nohighlight">\(\mathcal{V} = \{\text{cat}, \text{dog}, \text{mouse}\}\)</span> and
<span class="math notranslate nohighlight">\(V = 3\)</span>, then <span class="math notranslate nohighlight">\(f_{\text{stoi}}(\text{cat}) = 0\)</span>,
<span class="math notranslate nohighlight">\(f_{\text{stoi}}(\text{dog}) = 1\)</span>, and <span class="math notranslate nohighlight">\(f_{\text{stoi}}(\text{mouse}) = 2\)</span>.</p></li>
</ul>
</section>
<section id="index-to-string-mapping">
<h4><a class="toc-backref" href="#id13" role="doc-backlink">Index-to-String Mapping</a><a class="headerlink" href="#index-to-string-mapping" title="Link to this heading">#</a></h4>
<div class="math notranslate nohighlight">
\[
f_{\text{itos}} : \{0, 1, \ldots, V-1\} \to \mathcal{V}
\]</div>
<ul class="simple">
<li><p><strong>Function</strong>: <span class="math notranslate nohighlight">\(f_{\text{itos}}\)</span></p></li>
<li><p><strong>Domain</strong>: <span class="math notranslate nohighlight">\(\{0, 1, \ldots, V-1\}\)</span></p></li>
<li><p><strong>Codomain</strong>: <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>, the set of all tokens in the vocabulary.</p></li>
<li><p><strong>Purpose</strong>: This function maps each index back to its corresponding token
(word) in the vocabulary. For an index <span class="math notranslate nohighlight">\(j\)</span>, the value
<span class="math notranslate nohighlight">\(f_{\text{itos}}(j) = w\)</span> indicates that the index <span class="math notranslate nohighlight">\(j\)</span> corresponds to the
token <span class="math notranslate nohighlight">\(w\)</span> in the vocabulary <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>.</p></li>
<li><p><strong>Example</strong>: Continuing the previous example,
<span class="math notranslate nohighlight">\(f_{\text{itos}}(0) = \text{cat}\)</span>, <span class="math notranslate nohighlight">\(f_{\text{itos}}(1) = \text{dog}\)</span>, and
<span class="math notranslate nohighlight">\(f_{\text{itos}}(2) = \text{mouse}\)</span>.</p></li>
</ul>
</section>
</section>
<section id="one-hot-representation-of-input-sequence-mathbf-x">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">One-Hot Representation of Input Sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span></a><a class="headerlink" href="#one-hot-representation-of-input-sequence-mathbf-x" title="Link to this heading">#</a></h3>
<p>The one-hot representation of the input sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is denoted as
<span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span>. This representation converts each token in the
sequence to a one-hot encoded vector, where each vector has a length equal to
the size of the vocabulary <span class="math notranslate nohighlight">\(V\)</span>.</p>
<section id="definition">
<h4><a class="toc-backref" href="#id15" role="doc-backlink">Definition</a><a class="headerlink" href="#definition" title="Link to this heading">#</a></h4>
<p>The one-hot encoded matrix <span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{X}^{\text{ohe}} = \begin{bmatrix}
o_{1,1} &amp; o_{1,2} &amp; \cdots &amp; o_{1,V} \\
o_{2,1} &amp; o_{2,2} &amp; \cdots &amp; o_{2,V} \\
\vdots  &amp; \vdots  &amp; \ddots &amp; \vdots  \\
o_{T,1} &amp; o_{T,2} &amp; \cdots &amp; o_{T,V}
\end{bmatrix} \in \{0, 1\}^{T \times V}
\end{split}\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T\)</span>: Total length of the sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(V\)</span>: Size of the vocabulary <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(o_{t,j}\)</span>: Element of the one-hot encoded matrix <span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span>
at row <span class="math notranslate nohighlight">\(t\)</span> and column <span class="math notranslate nohighlight">\(j\)</span>.</p></li>
</ul>
<p>In addition, we have:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span> is a <span class="math notranslate nohighlight">\(T \times V\)</span> matrix.</p></li>
<li><p>Elements of <span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span> are binary, i.e., they belong to
<span class="math notranslate nohighlight">\(\{0, 1\}\)</span>.</p></li>
<li><p>The row vector <span class="math notranslate nohighlight">\(\mathbf{o}_{t, :}\)</span> represents the one-hot encoded vector for
the token at position <span class="math notranslate nohighlight">\(t\)</span> in the sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>.</p></li>
</ul>
</section>
<section id="one-hot-encoding-process">
<h4><a class="toc-backref" href="#id16" role="doc-backlink">One-Hot Encoding Process</a><a class="headerlink" href="#one-hot-encoding-process" title="Link to this heading">#</a></h4>
<p>For each token <span class="math notranslate nohighlight">\(x_t\)</span> at position <span class="math notranslate nohighlight">\(t\)</span> in the sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>
(<span class="math notranslate nohighlight">\(1 \leq t \leq T\)</span>), the corresponding row vector <span class="math notranslate nohighlight">\(\mathbf{o}_{t, :}\)</span> in
<span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{o}_{t, j} = \begin{cases}
1 &amp; \text{if } f_{\text{stoi}}(x_t) = j-1\\
0 &amp; \text{otherwise}
\end{cases}
\end{split}\]</div>
<p>for <span class="math notranslate nohighlight">\(j = 1, 2, \ldots, V\)</span>.</p>
<p>Here, <span class="math notranslate nohighlight">\(f_{\text{stoi}}(x_t)\)</span> maps the token <span class="math notranslate nohighlight">\(x_t\)</span> to its index <span class="math notranslate nohighlight">\(j-1\)</span> in the
vocabulary <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>, the <span class="math notranslate nohighlight">\(j-1\)</span> is because zero-based indexing used in
python (where <span class="math notranslate nohighlight">\(0 \leq j-1 &lt; V\)</span>). Each row <span class="math notranslate nohighlight">\(\mathbf{o}_{t, :}\)</span> in
<span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span> contains a single ‚Äò1‚Äô at the column <span class="math notranslate nohighlight">\(j\)</span> corresponding
to the vocabulary index of <span class="math notranslate nohighlight">\(x_t\)</span>, and ‚Äò0‚Äôs elsewhere.</p>
<div class="proof example admonition" id="gpt-notations-one-hot-example">
<p class="admonition-title"><span class="caption-number">Example 1 </span> (Example)</p>
<section class="example-content" id="proof-content">
<p>For example, if the vocabulary
<span class="math notranslate nohighlight">\(\mathcal{V} = \{\text{cat}, \text{dog}, \text{mouse}\}\)</span> and the sequence
<span class="math notranslate nohighlight">\(\mathbf{x} = (\text{mouse}, \text{dog})\)</span>, then the one-hot encoded matrix
<span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span> will be:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{X}^{\text{ohe}} = \begin{bmatrix}
0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0
\end{bmatrix} \in \{0, 1\}^{2 \times 3}
\end{split}\]</div>
<p>In this example:</p>
<ul class="simple">
<li><p>The sequence length <span class="math notranslate nohighlight">\(T = 2\)</span>.</p></li>
<li><p>The vocabulary size <span class="math notranslate nohighlight">\(V = 3\)</span>.</p></li>
<li><p>‚Äúmouse‚Äù corresponds to the third position in the vocabulary, and ‚Äúdog‚Äù to
the second, which is seen in their respective one-hot vectors.</p></li>
</ul>
</section>
</div></section>
<section id="batched">
<h4><a class="toc-backref" href="#id17" role="doc-backlink">Batched</a><a class="headerlink" href="#batched" title="Link to this heading">#</a></h4>
<p>The batched one-hot encoded matrix <span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe, }\mathcal{B}}\)</span> for a
batch of size <span class="math notranslate nohighlight">\(\mathcal{B}\)</span> is defined as a three-dimensional tensor, where each
‚Äúslice‚Äù (or matrix) along the first dimension corresponds to the one-hot encoded
representation of a sequence in the batch:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{X}^{\text{ohe, }\mathcal{B}} = \begin{bmatrix}
\mathbf{X}^{\text{ohe}}_1 \\
\mathbf{X}^{\text{ohe}}_2 \\
\vdots \\
\mathbf{X}^{\text{ohe}}_{\mathcal{B}}
\end{bmatrix} \in \{0, 1\}^{\mathcal{B} \times T \times V}
\end{split}\]</div>
<p>Here:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathcal{B}\)</span>: Batch size, the number of sequences processed together.</p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span>: Length of each sequence, assumed uniform across the batch.</p></li>
<li><p><span class="math notranslate nohighlight">\(V\)</span>: Size of the vocabulary.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}_b\)</span>: One-hot encoded matrix of the <span class="math notranslate nohighlight">\(b^{th}\)</span> sequence
in the batch.</p></li>
</ul>
</section>
</section>
</section>
<section id="weights-and-embeddings">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Weights And Embeddings</a><a class="headerlink" href="#weights-and-embeddings" title="Link to this heading">#</a></h2>
<section id="matrix-multiplication-primer">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Matrix Multiplication Primer</a><a class="headerlink" href="#matrix-multiplication-primer" title="Link to this heading">#</a></h3>
<p>See
<a class="reference external" href="https://math.stackexchange.com/questions/2063241/matrix-multiplication-notation">source</a>.</p>
<blockquote>
<div><p>If <span class="math notranslate nohighlight">\(A=(a_{ij})\in M_{mn}(\Bbb F), B=(b_{ij})\in M_{np}(\Bbb F)\)</span> then
<span class="math notranslate nohighlight">\(C=A\times B=(c_{ij})\in M_{mp}(\Bbb F)\)</span>. <span class="math notranslate nohighlight">\(c_{ij}=\sum_{k=1}^{n} a_{ik}b_{kj}\)</span>
where <span class="math notranslate nohighlight">\(i=1,...m, j=1,...p\)</span></p>
</div></blockquote>
<p>Let‚Äôs take a look at one specific element in the product <span class="math notranslate nohighlight">\(C=AB\)</span>, namely the
element on position <span class="math notranslate nohighlight">\((i,j)\)</span>, i.e. in the <span class="math notranslate nohighlight">\(i\)</span>th row and <span class="math notranslate nohighlight">\(j\)</span>th column.</p>
<p>To obtain this element, you:</p>
<ul class="simple">
<li><p>first <strong>multiply</strong> all elements of the <em><span class="math notranslate nohighlight">\(i\)</span>th row</em> of the matrix <span class="math notranslate nohighlight">\(A\)</span>
<em>pairwise</em> with all the elements of the <em><span class="math notranslate nohighlight">\(j\)</span>th column</em> of the matrix <span class="math notranslate nohighlight">\(B\)</span>;</p></li>
<li><p>and then you <strong>add</strong> these <span class="math notranslate nohighlight">\(n\)</span> products.</p></li>
</ul>
<p>You have to repeat this procedure for every element of <span class="math notranslate nohighlight">\(C\)</span>, but let‚Äôs zoom in on
that one specific (but arbitrary) element on position <span class="math notranslate nohighlight">\((i,j)\)</span> for now:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
a_{11} &amp;\ldots  &amp;a_{1n}\\
\vdots&amp; \ddots &amp;\vdots\\
\color{blue}{\mathbf{a_{i1}}} &amp;\color{blue}{\rightarrow}  &amp;\color{blue}{\mathbf{a_{in}}}\\
\vdots&amp;  \ddots &amp;\vdots\\
a_{m1} &amp;\ldots &amp;a_{mn}
\end{pmatrix}
\cdot
\begin{pmatrix}
b_{11}&amp;\ldots &amp;\color{red}{\mathbf{b_{1j}}} &amp;\ldots &amp;b_{1p}\\
\vdots&amp; \ddots &amp;\color{red}{\downarrow} &amp;  \ddots  &amp;\vdots\\
b_{n1}&amp;\ldots &amp;\color{red}{\mathbf{b_{nj}}}&amp;\ldots &amp;b_{np}
\end{pmatrix}
=
\begin{pmatrix}
c_{11}&amp;\ldots&amp; c_{1j} &amp;\ldots &amp;c_{1p}\\
\vdots&amp;  \ddots &amp; &amp; &amp;\vdots\\
c_{i1}&amp; &amp; \color{purple}{\mathbf{c_{ij}}} &amp; &amp;c_{ip}\\
\vdots&amp; &amp;  &amp; \ddots &amp;\vdots\\
c_{m1} &amp;\ldots&amp; c_{mj} &amp;\ldots &amp;c_{mp}
\end{pmatrix}
\end{split}\]</div>
<p>with element <span class="math notranslate nohighlight">\(\color{purple}{\mathbf{c_{ij}}}\)</span> equal to:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{\color{purple}{c_{ij}}  =  \color{blue}{a_{i1}} \color{red}{b_{1j}}  + \color{blue}{a_{i2}} \color{red}{b_{2j}}  +  \cdots  + \color{blue}{a_{in}} \color{red}{b_{nj}}}
\]</div>
<p>Now notice that in the sum above, the left outer index is always <span class="math notranslate nohighlight">\(i\)</span> (<span class="math notranslate nohighlight">\(i\)</span>th row
of <span class="math notranslate nohighlight">\(A\)</span>) and the right outer index is always <span class="math notranslate nohighlight">\(j\)</span> (<span class="math notranslate nohighlight">\(j\)</span>th column of <span class="math notranslate nohighlight">\(B\)</span>). The inner
indices run from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(n\)</span> so you can introduce a summation index <span class="math notranslate nohighlight">\(k\)</span> and write
this sum compactly using summation notation:</p>
<div class="math notranslate nohighlight">
\[
\color{purple}{\mathbf{c_{ij}}}=\sum_{k=1}^{n} \color{blue}{\mathbf{a_{ik}}}\color{red}{\mathbf{b_{kj}}}
\]</div>
<p>The formule above thus gives you the element on position <span class="math notranslate nohighlight">\((i,j)\)</span> in the product
matrix <span class="math notranslate nohighlight">\(C=AB\)</span> and therefore completely defines <span class="math notranslate nohighlight">\(C\)</span> by letting <span class="math notranslate nohighlight">\(i=1,...,m\)</span> and
<span class="math notranslate nohighlight">\(j=1,...,p\)</span>.</p>
</section>
<section id="mathbf-x-output-of-the-embedding-layer">
<h3><a class="toc-backref" href="#id20" role="doc-backlink"><span class="math notranslate nohighlight">\(\mathbf{X}\)</span>: Output of the Embedding Layer</a><a class="headerlink" href="#mathbf-x-output-of-the-embedding-layer" title="Link to this heading">#</a></h3>
<p>Once the one hot encoding representation <span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span> is well
defined, we can then pass it as input through our GPT model, in which the first
layer is a embedding lookup table. In the GPT model architecture, the first
layer typically involves mapping the one-hot encoded input vectors into a
lower-dimensional, dense embedding space using the embedding matrix
<span class="math notranslate nohighlight">\(\mathbf{W}_e\)</span>.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Matrix Description</p></th>
<th class="head"><p>Symbol</p></th>
<th class="head"><p>Dimensions</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>One-Hot Encoded Input Matrix</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times V\)</span></p></td>
<td><p>Each row corresponds to a one-hot encoded vector representing a token in the sequence.</p></td>
</tr>
<tr class="row-odd"><td><p>Embedding Matrix</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}_e\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(V \times D\)</span></p></td>
<td><p>Each row is the embedding vector of the corresponding token in the vocabulary.</p></td>
</tr>
<tr class="row-even"><td><p>Embedded Input Matrix</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>Each row is the embedding vector of the corresponding token in the input sequence.</p></td>
</tr>
<tr class="row-odd"><td><p>Embedding Vector for Token <span class="math notranslate nohighlight">\(t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{X}_t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(1 \times D\)</span></p></td>
<td><p>The embedding vector for the token at position <span class="math notranslate nohighlight">\(t\)</span> in the input sequence.</p></td>
</tr>
<tr class="row-even"><td><p>Batched Input Tensor</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{X}^{\mathcal{B}}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>A batched tensor containing <span class="math notranslate nohighlight">\(B\)</span> input sequences, each sequence is of shape <span class="math notranslate nohighlight">\(T \times D\)</span>.</p></td>
</tr>
</tbody>
</table>
<p>More concretely, we create an embedding matrix <span class="math notranslate nohighlight">\(\mathbf{W}_{e}\)</span> of size
<span class="math notranslate nohighlight">\(V \times D\)</span>, where <span class="math notranslate nohighlight">\(V\)</span> is the vocabulary size, <span class="math notranslate nohighlight">\(D\)</span> is the dimensions of the
embeddings, we would then matrix multiply <span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span> with
<span class="math notranslate nohighlight">\(\mathbf{W}_{e}\)</span> to get the output tensor <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>.</p>
<div class="math notranslate nohighlight">
\[
\mathbf{X} = \mathbf{X}^{\text{ohe}} \cdot \mathbf{W}_{e}
\]</div>
<section id="id1">
<h4><a class="toc-backref" href="#id21" role="doc-backlink">Definition</a><a class="headerlink" href="#id1" title="Link to this heading">#</a></h4>
<p>The embedding matrix <span class="math notranslate nohighlight">\(\mathbf{W}_{e}\)</span> is structured as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{W}_e &amp;= \left[\begin{array}{cccc}
w_{1,1} &amp; w_{1,2} &amp; \cdots &amp; w_{1, D} \\
w_{2,1} &amp; w_{2,2} &amp; \cdots &amp; w_{2, D} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
w_{V, 1} &amp; w_{V, 2} &amp; \cdots &amp; w_{V, D}
\end{array}\right] \in \mathbb{R}^{V \times D}
\end{aligned}
\end{split}\]</div>
<p>where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{w}_j = (w_{j,1}, w_{j,2}, \ldots, w_{j,D}) \in \mathbb{R}^{1 \times D}\)</span>:</p>
<ul>
<li><p>Each row vector <span class="math notranslate nohighlight">\(\mathbf{w}_j\)</span> of the matrix <span class="math notranslate nohighlight">\(\mathbf{W}_e\)</span> represents
the <span class="math notranslate nohighlight">\(D\)</span>-dimensional embedding vector for the <span class="math notranslate nohighlight">\(j\)</span>-th token in the
vocabulary <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>.</p></li>
<li><p>The subscript <span class="math notranslate nohighlight">\(j\)</span> ranges from 1 to <span class="math notranslate nohighlight">\(V\)</span>, indexing the tokens.</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(V\)</span> is the vocabulary size.</p></li>
<li><p><span class="math notranslate nohighlight">\(D\)</span> is the hidden embedding dimension.</p></li>
</ul>
<p>Here is a visual representation of how each embedding vector is selected through
matrix multiplication:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{X}^{\text{ohe}} \cdot \mathbf{W}_{e} &amp;=
\begin{bmatrix}
0 &amp; 1 &amp; \cdots &amp; 0 \\
1 &amp; 0 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; 1
\end{bmatrix}_{T \times V}
\cdot
\begin{bmatrix}
w_{1,1} &amp; w_{1,2} &amp; \cdots &amp; w_{1,D} \\
w_{2,1} &amp; w_{2,2} &amp; \cdots &amp; w_{2,D} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
w_{V,1} &amp; w_{V,2} &amp; \cdots &amp; w_{V,D}
\end{bmatrix}_{V \times D} \\
&amp;=
\begin{bmatrix}
w_{2,1} &amp; w_{2,2} &amp; \cdots &amp; w_{2,D} \\
w_{1,1} &amp; w_{1,2} &amp; \cdots &amp; w_{1,D} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
w_{T,1} &amp; w_{T,2} &amp; \cdots &amp; w_{T,D}
\end{bmatrix}_{T \times D}
\end{aligned}
\end{split}\]</div>
<p>Each row in the resulting matrix <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> is the embedding of the
corresponding token in the input sequence, picked directly from <span class="math notranslate nohighlight">\(\mathbf{W}_e\)</span>
by the one-hot vectors. In other words, the matrix <span class="math notranslate nohighlight">\(\mathbf{W}_e\)</span> can be
visualized as a table where each row corresponds to a token‚Äôs embedding vector:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{c|cccc}
\text{Token Index} &amp; \text{Dimension 1} &amp; \text{Dimension 2} &amp; \cdots &amp; \text{Dimension } D \\
\hline
1 &amp; w_{1,1} &amp; w_{1,2} &amp; \cdots &amp; w_{1,D} \\
2 &amp; w_{2,1} &amp; w_{2,2} &amp; \cdots &amp; w_{2,D} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
V &amp; w_{V,1} &amp; w_{V,2} &amp; \cdots &amp; w_{V,D} \\
\end{array}
\end{split}\]</div>
</section>
<section id="lookup">
<h4><a class="toc-backref" href="#id22" role="doc-backlink">Lookup</a><a class="headerlink" href="#lookup" title="Link to this heading">#</a></h4>
<p>When the one-hot encoded input matrix <span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span> multiplies with
the embedding matrix <span class="math notranslate nohighlight">\(\mathbf{W}_e\)</span>, each row of <span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span>
effectively selects a corresponding row from <span class="math notranslate nohighlight">\(\mathbf{W}_e\)</span>. This operation
simplifies to row selection because each row of <span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span>
contains exactly one ‚Äò1‚Äô and the rest are ‚Äò0‚Äôs.</p>
</section>
<section id="semantic-representation">
<h4><a class="toc-backref" href="#id23" role="doc-backlink">Semantic Representation</a><a class="headerlink" href="#semantic-representation" title="Link to this heading">#</a></h4>
<p>Now each row of the output tensor, indexed by <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(\mathbf{X}_{t, :}\)</span>: is the
<span class="math notranslate nohighlight">\(D\)</span> dimensional embedding vector for the token <span class="math notranslate nohighlight">\(x_t\)</span> at the <span class="math notranslate nohighlight">\(t\)</span>-th position in
the sequence. In this context, each token in the sequence is represented by a
<span class="math notranslate nohighlight">\(D\)</span> dimensional vector. So, the output tensor <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> captures the dense
representation of the sequence. Each token in the sequence is replaced by its
corresponding embedding vector from the embedding matrix <span class="math notranslate nohighlight">\(\mathbf{W}_{e}\)</span>. As
before, the output tensor <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> carries semantic information about the
tokens in the sequence. The closer two vectors are in this embedding space, the
more semantically similar they are.</p>
</section>
</section>
<section id="mathbf-w-e-embedding-matrix">
<h3><a class="toc-backref" href="#id24" role="doc-backlink"><span class="math notranslate nohighlight">\(\mathbf{W}_{e}\)</span>: Embedding Matrix</a><a class="headerlink" href="#mathbf-w-e-embedding-matrix" title="Link to this heading">#</a></h3>
<p>The embedding matrix <span class="math notranslate nohighlight">\(\mathbf{W}_{e}\)</span> is structured as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{W}_e &amp;= \left[\begin{array}{cccc}
w_{1,1} &amp; w_{1,2} &amp; \cdots &amp; w_{1, D} \\
w_{2,1} &amp; w_{2,2} &amp; \cdots &amp; w_{2, D} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
w_{V, 1} &amp; w_{V, 2} &amp; \cdots &amp; w_{V, D}
\end{array}\right] \in \mathbb{R}^{V \times D}
\end{aligned}
\end{split}\]</div>
<p>where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{w}_j = (w_{j,1}, w_{j,2}, \ldots, w_{j,D}) \in \mathbb{R}^{1 \times D}\)</span>:</p>
<ul>
<li><p>Each row vector <span class="math notranslate nohighlight">\(\mathbf{w}_j\)</span> of the matrix <span class="math notranslate nohighlight">\(\mathbf{W}_e\)</span> represents
the <span class="math notranslate nohighlight">\(D\)</span>-dimensional embedding vector for the <span class="math notranslate nohighlight">\(j\)</span>-th token in the
vocabulary <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>.</p></li>
<li><p>The subscript <span class="math notranslate nohighlight">\(j\)</span> ranges from 1 to <span class="math notranslate nohighlight">\(V\)</span>, indexing the tokens.</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(V\)</span> is the vocabulary size.</p></li>
<li><p><span class="math notranslate nohighlight">\(D\)</span> is the hidden embedding dimension.</p></li>
</ul>
</section>
<section id="pe-positional-encoding-layer">
<h3><a class="toc-backref" href="#id25" role="doc-backlink"><span class="math notranslate nohighlight">\(PE\)</span>: Positional Encoding Layer</a><a class="headerlink" href="#pe-positional-encoding-layer" title="Link to this heading">#</a></h3>
<p>For a given input matrix <span class="math notranslate nohighlight">\(\mathbf{X} \in \mathbb{R}^{T \times D}\)</span>, where <span class="math notranslate nohighlight">\(T\)</span> is
the sequence length and <span class="math notranslate nohighlight">\(D\)</span> is the embedding dimension (denoted as
<span class="math notranslate nohighlight">\(d_{\text{model}}\)</span> in typical Transformer literature), the positional encoding
<span class="math notranslate nohighlight">\(\operatorname{PE}\)</span> is applied to integrate sequence positional information into
the embeddings. The resultant matrix <span class="math notranslate nohighlight">\(\mathbf{X}'\)</span> after applying positional
encoding can be expressed as follows:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{X}' = \operatorname{PE}(\mathbf{X}),
\]</div>
<p>where each element of <span class="math notranslate nohighlight">\(\mathbf{X}'\)</span>, denoted as <span class="math notranslate nohighlight">\(x'_{i, j}\)</span>, is calculated based
on the sinusoidal function:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
x'_{i, j} =
\begin{cases}
\sin\left(\frac{i}{10000^{j/D}}\right) &amp; \text{if } j \mod 2 = 0 \\
\cos\left(\frac{i}{10000^{(j-1)/D}}\right) &amp; \text{otherwise}
\end{cases}
\end{split}\]</div>
<p>for <span class="math notranslate nohighlight">\(i = 1, \ldots, T\)</span> and <span class="math notranslate nohighlight">\(j = 1, \ldots, D\)</span>.</p>
</section>
<section id="tilde-mathbf-x-output-of-the-positional-encoding-layer">
<h3><a class="toc-backref" href="#id26" role="doc-backlink"><span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span>: Output of the Positional Encoding Layer</a><a class="headerlink" href="#tilde-mathbf-x-output-of-the-positional-encoding-layer" title="Link to this heading">#</a></h3>
<p>We can update our original embeddings tensor <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> to include positional
information:</p>
<div class="math notranslate nohighlight">
\[
\tilde{\mathbf{X}} := \mathbf{X} + \operatorname{PE}(X)
\]</div>
<p>This operation adds the positional encodings to the original embeddings, giving
the final embeddings that are passed to subsequent layers in the Transformer
model.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Matrix Description</p></th>
<th class="head"><p>Symbol</p></th>
<th class="head"><p>Dimensions</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Positional Encoding Matrix</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}_{p}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>Matrix with positional encoding vectors for each position in the sequence, computed using sinusoidal functions.</p></td>
</tr>
<tr class="row-odd"><td><p>Output of Positional Encoding Layer</p></td>
<td><p><span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>The resultant embeddings matrix after adding positional encoding <span class="math notranslate nohighlight">\(\mathbf{W}_{p}\)</span> to the embedded input matrix <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>. Each row now includes positional information.</p></td>
</tr>
<tr class="row-even"><td><p>Embedding Vector for Token <span class="math notranslate nohighlight">\(t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}_t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(1 \times D\)</span></p></td>
<td><p>The token and positional embedding vector for the token at position <span class="math notranslate nohighlight">\(t\)</span> in the input sequence.</p></td>
</tr>
<tr class="row-odd"><td><p>Batched Input Tensor</p></td>
<td><p><span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}^{\mathcal{B}}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>A batched tensor containing <span class="math notranslate nohighlight">\(B\)</span> input sequences, each sequence is of shape <span class="math notranslate nohighlight">\(T \times D\)</span>.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="layer-normalization">
<h2><a class="toc-backref" href="#id27" role="doc-backlink">Layer Normalization</a><a class="headerlink" href="#layer-normalization" title="Link to this heading">#</a></h2>
<p>Layer normalization modifies the activations within each layer to have zero mean
and unit variance across the features for each data point in a batch
independently, which helps in stabilizing the learning process. It then applies
a learnable affine transformation to each normalized activation, allowing the
network to scale and shift these values where beneficial.</p>
<p>For a given layer with inputs <span class="math notranslate nohighlight">\(\mathbf{Z} \in \mathbb{R}^{B \times T \times D}\)</span>
(where <span class="math notranslate nohighlight">\(B\)</span> is the batch size, <span class="math notranslate nohighlight">\(T\)</span> is the sequence length, and <span class="math notranslate nohighlight">\(D\)</span> is the feature
dimension or hidden dimension size), the layer normalization of <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> is
computed as follows:</p>
<ol class="arabic">
<li><p><strong>Mean and Variance Calculation</strong>: Calculate the mean <span class="math notranslate nohighlight">\(\mu_t\)</span> and variance
<span class="math notranslate nohighlight">\(\sigma_t^2\)</span> for each feature vector across the feature dimension <span class="math notranslate nohighlight">\(D\)</span>:</p>
<div class="math notranslate nohighlight">
\[
    \mu_t = \frac{1}{D} \sum_{d=1}^D \mathbf{Z}_{t, d}, \quad \sigma_t^2 = \frac{1}{D} \sum_{d=1}^D (\mathbf{Z}_{t, d} - \mu_t)^2
    \]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mu_t\)</span> and <span class="math notranslate nohighlight">\(\sigma_t^2\)</span> are computed for each token <span class="math notranslate nohighlight">\(t\)</span> across all
batches <span class="math notranslate nohighlight">\(B\)</span> and sequence positions <span class="math notranslate nohighlight">\(T\)</span>, but independently for each batch
and sequence position.</p></li>
</ul>
</li>
<li><p><strong>Normalization</strong>: Normalize the activations for each feature dimension:</p>
<div class="math notranslate nohighlight">
\[
    \hat{\mathbf{Z}}_{t, d} = \frac{\mathbf{Z}_{t, d} - \mu_t}{\sqrt{\sigma_t^2 + \epsilon}}
    \]</div>
<ul class="simple">
<li><p>Where <span class="math notranslate nohighlight">\(\epsilon\)</span> is a small constant (e.g., <span class="math notranslate nohighlight">\(10^{-5}\)</span>) added for numerical
stability.</p></li>
</ul>
</li>
<li><p><strong>Affine Transformation</strong>: Apply a learnable affine transformation to each
normalized feature:</p>
<div class="math notranslate nohighlight">
\[
    \overline{\mathbf{Z}}_{t, d} = \hat{\mathbf{Z}}_{t, d} \cdot \gamma_d + \beta_d
    \]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\gamma_d\)</span> and <span class="math notranslate nohighlight">\(\beta_d\)</span> are learnable parameters that scale and shift the
normalized feature respectively. They are of the same dimensionality <span class="math notranslate nohighlight">\(D\)</span>
as the features and are shared across all tokens and batches.</p></li>
</ul>
</li>
</ol>
<p>In practice, these operations are implemented vector-wise across the feature
dimension <span class="math notranslate nohighlight">\(D\)</span>, and can be compactly expressed as:</p>
<div class="math notranslate nohighlight">
\[
\overline{\mathbf{Z}}_t = \dfrac{\mathbf{Z}_t - \mu_t}{\sqrt{\sigma_t^2 + \epsilon}} \odot \gamma + \beta
\]</div>
<ul class="simple">
<li><p>Here, <span class="math notranslate nohighlight">\(\odot\)</span> denotes element-wise multiplication, emphasizing that <span class="math notranslate nohighlight">\(\gamma\)</span>
and <span class="math notranslate nohighlight">\(\beta\)</span> scale and shift each normalized feature dimension identically
across all tokens and batches.</p></li>
<li><p>For better understanding, we can calculate in a loop all <span class="math notranslate nohighlight">\(T\)</span> rows of
<span class="math notranslate nohighlight">\(\overline{\mathbf{Z}}_t\)</span>, and we stack them together to get the final
output tensor <span class="math notranslate nohighlight">\(\overline{\mathbf{Z}}\)</span>.</p></li>
</ul>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Input/Output</p></th>
<th class="head"><p>Shape</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\mathbf{Z}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span></p></td>
<td><p>The input tensor to the layer normalization operation.</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\overline{\mathbf{Z}}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span></p></td>
<td><p>The output tensor after applying layer normalization. The dimensionality remains the same as the input, only the scale and shift of the activations within each feature vector are adjusted.</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\operatorname{LayerNorm}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbb{R}^{B \times T \times D} \to \mathbb{R}^{B \times T \times D}\)</span></p></td>
<td><p>The layer normalization function that takes an input tensor <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> and returns the normalized tensor <span class="math notranslate nohighlight">\(\overline{\mathbf{Z}}\)</span> with the same shape.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="attention-notations">
<h2><a class="toc-backref" href="#id28" role="doc-backlink">Attention Notations</a><a class="headerlink" href="#attention-notations" title="Link to this heading">#</a></h2>
<section id="dimensions">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">Dimensions</a><a class="headerlink" href="#dimensions" title="Link to this heading">#</a></h3>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Symbol</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(H\)</span></p></td>
<td><p>Number of attention heads.</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(h\)</span></p></td>
<td><p>Index of the attention head.</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(d_k = D/H\)</span></p></td>
<td><p>Dimension of the keys. In the multi-head attention case, this would typically be <span class="math notranslate nohighlight">\(D/H\)</span> where <span class="math notranslate nohighlight">\(D\)</span> is the dimensionality of input embeddings and <span class="math notranslate nohighlight">\(H\)</span> is the number of attention heads.</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(d_q = D/H\)</span></p></td>
<td><p>Dimension of the queries. Also usually set equal to <span class="math notranslate nohighlight">\(d_k\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(d_v = D/H\)</span></p></td>
<td><p>Dimension of the values. Usually set equal to <span class="math notranslate nohighlight">\(d_k\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(L\)</span></p></td>
<td><p>Total number of decoder blocks in the GPT architecture.</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p>Index of the decoder block, ranging from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(L\)</span>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="query-key-and-values">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">Query, Key and Values</a><a class="headerlink" href="#query-key-and-values" title="Link to this heading">#</a></h3>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Matrix Description</strong></p></th>
<th class="head"><p><strong>Symbol</strong></p></th>
<th class="head"><p><strong>Dimensions</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Generic Query Matrix for All Heads</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Q}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>Contains the query representations for all tokens in the sequence using combined weights of all heads.</p></td>
</tr>
<tr class="row-odd"><td><p>Generic Key Matrix for All Heads</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{K}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>Contains the key representations for all tokens in the sequence using combined weights of all heads.</p></td>
</tr>
<tr class="row-even"><td><p>Generic Value Matrix for All Heads</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{V}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>Contains the value representations for all tokens in the sequence using combined weights of all heads.</p></td>
</tr>
<tr class="row-odd"><td><p>Query Matrix for All Heads in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Q}^{(\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>Contains the query representations for all tokens in the sequence using combined weights of all heads in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer.</p></td>
</tr>
<tr class="row-even"><td><p>Key Matrix for All Heads in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{K}^{(\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>Contains the key representations for all tokens in the sequence using combined weights of all heads in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer.</p></td>
</tr>
<tr class="row-odd"><td><p>Value Matrix for All Heads in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{V}^{(\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>Contains the value representations for all tokens in the sequence using combined weights of all heads in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer.</p></td>
</tr>
<tr class="row-even"><td><p>Query Weight Matrix for All Heads in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}^{\mathbf{Q}, (\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(D \times D\)</span></p></td>
<td><p>The query transformation matrix applicable to all heads in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer. It transforms the embeddings <span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span> into query representations.</p></td>
</tr>
<tr class="row-odd"><td><p>Key Weight Matrix for All Heads in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}^{\mathbf{K}, (\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(D \times D\)</span></p></td>
<td><p>The key transformation matrix applicable to all heads in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer. It transforms the embeddings <span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span> into key representations.</p></td>
</tr>
<tr class="row-even"><td><p>Value Weight Matrix for All Heads in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}^{\mathbf{V}, (\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(D \times D\)</span></p></td>
<td><p>The value transformation matrix applicable to all heads in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer. It transforms the embeddings <span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span> into value representations.</p></td>
</tr>
<tr class="row-odd"><td><p>Query Matrix for Head <span class="math notranslate nohighlight">\(h\)</span> in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Q}_h^{(\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times d_q\)</span></p></td>
<td><p>Contains the query representations for all tokens in the sequence specific to head <span class="math notranslate nohighlight">\(h\)</span> in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer.</p></td>
</tr>
<tr class="row-even"><td><p>Key Matrix for Head <span class="math notranslate nohighlight">\(h\)</span> in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{K}_h^{(\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times d_k\)</span></p></td>
<td><p>Contains the key representations for all tokens in the sequence specific to head <span class="math notranslate nohighlight">\(h\)</span> in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer.</p></td>
</tr>
<tr class="row-odd"><td><p>Value Matrix for Head <span class="math notranslate nohighlight">\(h\)</span> in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{V}_h^{(\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times d_v\)</span></p></td>
<td><p>Contains the value representations for all tokens in the sequence specific to head <span class="math notranslate nohighlight">\(h\)</span> in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer.</p></td>
</tr>
<tr class="row-even"><td><p>Query Weight Matrix for Head <span class="math notranslate nohighlight">\(h\)</span> in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}_h^{\mathbf{Q}, (\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(D \times d_q\)</span></p></td>
<td><p>Linear transformation matrix for queries in masked attention head <span class="math notranslate nohighlight">\(h \in \{1, \ldots, H\}\)</span> of decoder block <span class="math notranslate nohighlight">\(\ell \in \{1, \ldots, L\}\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p>Key Weight Matrix for Head <span class="math notranslate nohighlight">\(h\)</span> in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}_h^{\mathbf{K}, (\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(D \times d_k\)</span></p></td>
<td><p>Linear transformation matrix for keys in masked attention head <span class="math notranslate nohighlight">\(h \in \{1, \ldots, H\}\)</span> of decoder block <span class="math notranslate nohighlight">\(\ell \in \{1, \ldots, L\}\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p>Value Weight Matrix for Head <span class="math notranslate nohighlight">\(h\)</span> in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}_h^{\mathbf{V}, (\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(D \times d_v\)</span></p></td>
<td><p>Linear transformation matrix for values in masked attention head <span class="math notranslate nohighlight">\(h \in \{1, \ldots, H\}\)</span> of decoder block <span class="math notranslate nohighlight">\(\ell \in \{1, \ldots, L\}\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p>Projection Weight Matrix for Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}^{O, (\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(D \times D\)</span></p></td>
<td><p>The projection matrix used to combine and transform the concatenated outputs from all heads in the <span class="math notranslate nohighlight">\( \ell \)</span>-th layer back to the original dimension <span class="math notranslate nohighlight">\(D\)</span>.</p></td>
</tr>
</tbody>
</table>
<p>We will talk about the relevant shapes in the last section.</p>
</section>
<section id="general-attention-mechanism">
<h3><a class="toc-backref" href="#id31" role="doc-backlink">General Attention Mechanism</a><a class="headerlink" href="#general-attention-mechanism" title="Link to this heading">#</a></h3>
<p>To calculate the embeddings after attention in the GPT model:</p>
<div class="math notranslate nohighlight">
\[
\operatorname{Attention}(\mathbf{Q}, \mathbf{K}, \mathbf{V})=\operatorname{softmax}\left(\frac{\mathbf{Q} \mathbf{K}^{\top}}{\sqrt{d_k}}\right) \mathbf{V}
\]</div>
</section>
<section id="multi-head-attention-for-layer-ell">
<h3><a class="toc-backref" href="#id32" role="doc-backlink">Multi-Head Attention for Layer <span class="math notranslate nohighlight">\(\ell\)</span></a><a class="headerlink" href="#multi-head-attention-for-layer-ell" title="Link to this heading">#</a></h3>
<p>For the multi-head attention in layer <span class="math notranslate nohighlight">\(\ell\)</span> of the Transformer (applicable to
both encoder and decoder in architectures that have both components, but here
tailored for GPT which primarily uses decoder stacks):</p>
<div class="math notranslate nohighlight">
\[
\operatorname{MultiHead}^{(\ell)}(\mathbf{Q}, \mathbf{K}, \mathbf{V}) = \operatorname{Concat}\left(\operatorname{head}_{\ell, 1}, \operatorname{head}_{\ell, 2}, \cdots, \operatorname{head}_{\ell, H}\right) \mathbf{W}^{O, (\ell)}
\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[
\operatorname{head}_{\ell, h} = \operatorname{Attention}\left(\mathbf{Q} \mathbf{W}_{h}^{\mathbf{Q}, (\ell)}, \mathbf{K} \mathbf{W}_{h}^{\mathbf{K}, (\ell)}, \mathbf{V} \mathbf{W}_{h}^{\mathbf{V}, (\ell)}\right)
\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{W}_{h}^{\mathbf{Q}, (\ell)}, \mathbf{W}_{h}^{\mathbf{K}, (\ell)}, \mathbf{W}_{h}^{\mathbf{V}, (\ell)}\)</span>
are the weight matrices for queries, keys, and values for the <span class="math notranslate nohighlight">\(h\)</span>-th head in
the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer, respectively.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{W}^{O, (\ell)}\)</span> is the output transformation matrix for the
<span class="math notranslate nohighlight">\(\ell\)</span>-th layer.</p></li>
</ul>
</section>
<section id="masked-multi-head-attention-for-decoder-layer-ell">
<h3><a class="toc-backref" href="#id33" role="doc-backlink">Masked Multi-Head Attention for Decoder Layer <span class="math notranslate nohighlight">\(\ell\)</span></a><a class="headerlink" href="#masked-multi-head-attention-for-decoder-layer-ell" title="Link to this heading">#</a></h3>
<p>Masked multi-head attention, used in the decoder to ensure that the predictions
for position <span class="math notranslate nohighlight">\(t\)</span> can only depend on known outputs at positions less than <span class="math notranslate nohighlight">\(t\)</span>
(auto-regressive property):</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\operatorname{MaskedMultiHead}^{(\ell)}(\mathbf{Q}, \mathbf{K}, \mathbf{V}) &amp;= \operatorname{Concat}\left(\operatorname{head}_{\ell, 1}^{M}, \operatorname{head}_{\ell, 2}^{M}, \cdots, \operatorname{head}_{\ell, H}^{M}\right) \mathbf{W}^{O, M, (\ell)} \\
&amp;= \left( \operatorname{{head}_{\ell, 1}^{M}} \oplus \operatorname{{head}_{\ell, 2}^{M}} \oplus \cdots \oplus \operatorname{{head}_{\ell, H}^{M}} \right) \mathbf{W}^{O, M, (\ell)}
\end{aligned}
\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[
\operatorname{head}_{\ell, h}^{M} = \operatorname{softmax}\left(\operatorname{Mask}\left(\frac{\left(\mathbf{Q} \mathbf{W}_{h}^{\mathbf{Q}, M, (\ell)}\right)\left(\mathbf{K} \mathbf{W}_{h}^{\mathbf{K}, M, (\ell)}\right)^{\top}}{\sqrt{d_k}}\right)\right)\left(\mathbf{V} \mathbf{W}_{h}^{\mathbf{V}, M, (\ell)}\right)
\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\operatorname{Mask}(\mathbf{x})_{i, j}= \begin{cases}\mathbf{x}_{i, j} &amp; \text{if } i \geq j \\ -\infty &amp; \text{otherwise}\end{cases}
\end{split}\]</div>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(M\)</span> denotes the masked condition.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{W}_{h}^{\mathbf{Q}, M, (\ell)}, \mathbf{W}_{h}^{\mathbf{K}, M, (\ell)}, \mathbf{W}_{h}^{\mathbf{V}, M, (\ell)}\)</span>
are the masked weight matrices for queries, keys, and values for the <span class="math notranslate nohighlight">\(h\)</span>-th
head in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer, specifically used under the masked condition.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{W}^{O, M, (\ell)}\)</span> is the masked output transformation matrix for
the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer, ensuring that future tokens do not influence the
predictions of the current token in an auto-regressive manner.</p></li>
</ul>
</section>
<section id="updated-matrix-description-table-with-batch-and-head-dimensions">
<h3><a class="toc-backref" href="#id34" role="doc-backlink">Updated Matrix Description Table with Batch and Head Dimensions</a><a class="headerlink" href="#updated-matrix-description-table-with-batch-and-head-dimensions" title="Link to this heading">#</a></h3>
<p>To accurately reflect the practical shapes of the Query (Q), Key (K), and Value
(V) matrices in implementations like GPT, where batch processing and multi-head
attention are used, we should adjust the notation to include batch size <span class="math notranslate nohighlight">\(B\)</span>,
number of heads <span class="math notranslate nohighlight">\(H\)</span>, and the dimensions <span class="math notranslate nohighlight">\(d_k, d_q, d_v\)</span> corresponding to each
head.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Matrix Description</p></th>
<th class="head"><p>Symbol</p></th>
<th class="head"><p>Dimensions</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Query Matrix for All Heads in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Q}^{(\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D \rightarrow B \times T \times \underset{D}{\underbrace{H \times d_q}} \xrightarrow[]{\text{transpose 1-2}} B \times H \times T \times d_q\)</span></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>Contains the query representations for all tokens in all sequences of a batch, separated by heads in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer.</p></td>
<td><p></p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>Key Matrix for All Heads in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{K}^{(\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D \rightarrow B \times T \times \underset{D}{\underbrace{H \times d_k}} \xrightarrow[]{\text{transpose 1-2}} B \times H \times T \times d_k\)</span></p></td>
<td><p>Contains the key representations for all tokens in all sequences of a batch, separated by heads in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer.</p></td>
</tr>
<tr class="row-odd"><td><p>Value Matrix for All Heads in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{V}^{(\ell)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D \rightarrow B \times T \times \underset{D}{\underbrace{H \times d_v}} \xrightarrow[]{\text{transpose 1-2}} B \times H \times T \times d_v\)</span></p></td>
<td><p>Contains the value representations for all tokens in all sequences of a batch, separated by heads in the <span class="math notranslate nohighlight">\(\ell\)</span>-th layer.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="positionwise-feed-forward-networks">
<h2><a class="toc-backref" href="#id35" role="doc-backlink">Positionwise Feed-Forward Networks</a><a class="headerlink" href="#positionwise-feed-forward-networks" title="Link to this heading">#</a></h2>
<p>The term ‚Äúpositionwise feed-forward network‚Äù (FFN) in the context of Transformer
models refers to a dense neural network (otherwise known as multilayer
perceptron) that operates on the output of the Multi-Head Attention mechanism.
This component is called ‚Äúpositionwise‚Äù because it applies the <strong>same</strong>
feed-forward neural network (FFN) <strong>independently</strong> and <strong>identically</strong> to each
position <span class="math notranslate nohighlight">\(t\)</span> in the sequence of length <span class="math notranslate nohighlight">\(T\)</span>.</p>
<section id="independent-processing">
<h3><a class="toc-backref" href="#id36" role="doc-backlink">Independent Processing</a><a class="headerlink" href="#independent-processing" title="Link to this heading">#</a></h3>
<p>In the Transformer architecture, after the Multi-Head Attention mechanism
aggregates information from different positions in the sequence based on
attention scores, each element (or position) <span class="math notranslate nohighlight">\(t\)</span> in the sequence has an updated
representation. The positionwise FFN then processes each of these updated
representations. However, rather than considering the sequence as a whole or how
elements relate to each other at this stage, the FFN operates on each position
separately. This means that for a sequence of length <span class="math notranslate nohighlight">\(T\)</span>, the same FFN is
applied <span class="math notranslate nohighlight">\(T\)</span> times independently, and by extension, given a batch of sequences,
the FFN is applied <span class="math notranslate nohighlight">\(T \times \mathcal{B}\)</span> times, where <span class="math notranslate nohighlight">\(\mathcal{B}\)</span> is the
batch size.</p>
</section>
<section id="identical-application">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">Identical Application</a><a class="headerlink" href="#identical-application" title="Link to this heading">#</a></h3>
<p>The term ‚Äúusing the same FFN‚Äù signifies that the same set of parameters (weights
and biases) of the feed-forward neural network is used for each position in the
sequence. The rationale is that the transformation is consistent across all
sequence positions, so each element is transformed by the same learned function.
This means the weight matrices and bias vectors of the FFN are shared across all
positions in the sequence. In other words, if a sequence has <span class="math notranslate nohighlight">\(T=3\)</span>
positions/tokens, the weight matrices and bias vectors of the FFN are the same
for all three positions.</p>
</section>
<section id="id2">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">Definition</a><a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
<p>Typically, a positionwise FFN consists of two linear transformations with a
non-linear activation function in between. The general form can be represented
as follows.</p>
<div class="proof definition admonition" id="def-positionwise-ffn-notation">
<p class="admonition-title"><span class="caption-number">Definition 1 </span> (Position-wise Feedforward Networks)</p>
<section class="definition-content" id="proof-content">
<p>Given an input matrix <span class="math notranslate nohighlight">\(\mathbf{Z} \in \mathbb{R}^{T \times D}\)</span>, the
position-wise feedforward network computes the output matrix
<span class="math notranslate nohighlight">\(\mathbf{Z}^{\prime} \in \mathbb{R}^{T \times D}\)</span> via the following operations:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{Z}^{\prime}=\sigma_Z\left(\mathbf{Z} \mathbf{W}^{\text{FF}}_1 + \mathbf{b}^{\text{FF}}_1\right) \mathbf{W}^{\text{FF}}_2 + \mathbf{b}^{\text{FF}}_2
\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{W}^{\text{FF}}_1 \in \mathbb{R}^{D \times d_{\text{ff}}}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{W}^{\text{FF}}_2 \in \mathbb{R}^{d_{\text{ff}} \times D}\)</span> are
learnable weight matrices.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b}^{\text{FF}}_1 \in \mathbb{R}^{d_{\text{ff}}}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{b}^{\text{FF}}_2 \in \mathbb{R}^{D}\)</span> are learnable bias vectors.</p></li>
<li><p><span class="math notranslate nohighlight">\(\sigma_Z\)</span> is a non-linear activation function, such as the Gaussian Error
Linear Unit (GELU) or the Rectified Linear Unit (ReLU).</p></li>
</ul>
</section>
</div></section>
<section id="projection-to-a-higher-dimension-space">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">Projection to a Higher Dimension Space</a><a class="headerlink" href="#projection-to-a-higher-dimension-space" title="Link to this heading">#</a></h3>
<p>In the Transformer architecture, the dimensionality of the hidden layer in the
positionwise FFN, denoted as <span class="math notranslate nohighlight">\(d_{\text{ff}}\)</span>, is often chosen to be larger than
the dimensionality of the input and output embeddings, <span class="math notranslate nohighlight">\(D\)</span>. This means that the
FFN projects the input embeddings into a higher-dimensional space before
projecting them back to the original dimensionality.</p>
<p>The motivation behind this design choice is to allow the model to learn more
complex and expressive representations. By projecting the input embeddings into
a higher-dimensional space, the model capacity is increased, and the FFN can
capture more intricate patterns and relationships among the features. We then
project back (‚Äúunembedding‚Äù) the higher-dimensional representations to the
original dimensionality to maintain the consistency of the model.</p>
<p>In practice, a common choice for the dimensionality of the hidden layer is to
set <span class="math notranslate nohighlight">\(d_{\text{ff}}\)</span> to be a multiple of the input and output dimensionality <span class="math notranslate nohighlight">\(D\)</span>.
For example, in the original Transformer paper <span id="id3">[<a class="reference internal" href="../../bibliography.html#id15" title="Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. 2017. arXiv:1706.03762.">Vaswani <em>et al.</em>, 2017</a>]</span>, the
authors used <span class="math notranslate nohighlight">\(d_{\text{ff}} = 4 \times D\)</span>.</p>
</section>
<section id="gaussian-error-linear-unit-gelu">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">Gaussian Error Linear Unit (GELU)</a><a class="headerlink" href="#gaussian-error-linear-unit-gelu" title="Link to this heading">#</a></h3>
<p>The Gaussian Error Linear Unit (GELU) is a non-linear activation function used
in the context of neural networks, which allows the model to capture more
complex patterns in the data compared to traditional activation functions like
ReLU. The GELU activation function is defined as:</p>
<div class="math notranslate nohighlight">
\[
\text{GELU}(x) = x \cdot \Phi(x)
\]</div>
<p>where <span class="math notranslate nohighlight">\(x\)</span> is the input to the activation function, and <span class="math notranslate nohighlight">\(\Phi(x)\)</span> represents the
cumulative distribution function (CDF) of the standard Gaussian distribution.
The GELU function, effectively, models inputs with a non-linear transformation
that weights inputs by their value, with a probabilistic gating mechanism
derived from the Gaussian distribution.</p>
<p>The cumulative distribution function <span class="math notranslate nohighlight">\(\Phi(x)\)</span> for a standard Gaussian
distribution is given by:</p>
<div class="math notranslate nohighlight">
\[
\Phi(x) = \frac{1}{2} \left[1 + \text{erf}\left(\frac{x}{\sqrt{2}}\right)\right]
\]</div>
<p>where <span class="math notranslate nohighlight">\(\text{erf}\)</span> denotes the error function, which is a special function
integral of the Gaussian distribution. Combining these, the GELU function can be
expressed as:</p>
<div class="math notranslate nohighlight">
\[
\text{GELU}(x) = x \cdot \frac{1}{2} \left[1 + \text{erf}\left(\frac{x}{\sqrt{2}}\right)\right]
\]</div>
<p>I will not pretend I have went through the entire paper and motivation of GELU,
but usually, when new and ‚Äúbetter‚Äù activation functions are proposed, they
usually serve as an alternative to the common activation functions such as ReLU
etc, where they solve some of the problems that the common activation functions
have. From the formulation, we can see that GELU obeys the following properties:</p>
<ul class="simple">
<li><p><strong>Non-linearity</strong>: GELU introduces non-linearity to the model, a given
requirement.</p></li>
<li><p><strong>Differentiability</strong>: GELU is smooth and differentiable everywhere, which
is beneficial for gradient-based optimization methods.</p></li>
<li><p><strong>Boundedness</strong>: GELU seems to be bounded below by <span class="math notranslate nohighlight">\(-0.17\)</span> and not upper
bounded, but practice we can show there is an upper bound if we normalize
the input.</p></li>
</ul>
<div class="proof remark admonition" id="remark-approx-gelu-notation">
<p class="admonition-title"><span class="caption-number">Remark 1 </span> (Approximation of GELU)</p>
<section class="remark-content" id="proof-content">
<p>To further simplify the GELU function and enhance computational efficiency, an
approximation of the Gaussian CDF is commonly used in practice (extracted from
<a class="reference external" href="https://www.hindawi.com/journals/jmath/2023/4229924/">Mathematical Analysis and Performance Evaluation of the GELU Activation Function in Deep Learning</a>):</p>
<div class="math notranslate nohighlight">
\[
\Phi(\alpha x) \approx \frac{1}{2}\left(1+\tanh \left(\beta\left(\alpha x+\gamma(\alpha x)^3\right)\right)\right),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\beta&gt;0\)</span> and <span class="math notranslate nohighlight">\(\gamma \in \mathbb{R}\)</span> are constants, selected to minimize
approximation error. Substituting this approximation into the GELU function, we
arrive at the final approximate form of the GELU activation function (Figure 1):</p>
<div class="math notranslate nohighlight">
\[
\operatorname{GELU}(x)=0.5 x\left(1+\tanh \left(\sqrt{\frac{2}{\pi}}\left(x+0.044715 x^3\right)\right)\right) .
\]</div>
</section>
</div><div class="proof definition admonition" id="def-gelu-notation">
<p class="admonition-title"><span class="caption-number">Definition 2 </span> (GELU Activation Function)</p>
<section class="definition-content" id="proof-content">
<p>For a matrix <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> with elements <span class="math notranslate nohighlight">\(\mathbf{Z}_{t d}\)</span> where <span class="math notranslate nohighlight">\(t\)</span> indexes the
sequence (from 1 to <span class="math notranslate nohighlight">\(T\)</span> ) and <span class="math notranslate nohighlight">\(d\)</span> indexes the feature dimension (from 1 to <span class="math notranslate nohighlight">\(D\)</span>
), the GELU activation is applied <strong>element-wise</strong> to each element
<span class="math notranslate nohighlight">\(\mathbf{Z}_{t d}\)</span> independently:</p>
<div class="math notranslate nohighlight">
\[
\operatorname{GELU}\left(x_{t d}\right)=x_{t d} \cdot \frac{1}{2}\left[1+\operatorname{erf}\left(\frac{x_{t d}}{\sqrt{2}}\right)\right]
\]</div>
</section>
</div><div class="seealso admonition">
<p class="admonition-title">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.hindawi.com/journals/jmath/2023/4229924/">Mathematical Analysis and Performance Evaluation of the GELU Activation Function in Deep Learning</a></p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/1606.08415">Gaussian Error Linear Units (GELUs) </a></p></li>
</ul>
</div>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Matrix Description</strong></p></th>
<th class="head"><p><strong>Symbol</strong></p></th>
<th class="head"><p><strong>Dimensions</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Input to FFN in Layer <span class="math notranslate nohighlight">\(\ell\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_4\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span></p></td>
<td><p>Output from the residual connection that adds the normalized self-attention outputs to the initial input embeddings.</p></td>
</tr>
<tr class="row-odd"><td><p>First Linear Transformation in FFN</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{FF, (\ell)}_1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times d_{\text{ff}}\)</span></p></td>
<td><p>Applies the first linear transformation to each position‚Äôs embedding, projecting it to a higher dimensional space (<span class="math notranslate nohighlight">\(d_{\text{ff}}\)</span>).</p></td>
</tr>
<tr class="row-even"><td><p>Activation (e.g., GELU) Applied to First Linear Output</p></td>
<td><p><span class="math notranslate nohighlight">\(\sigma\left(\mathbf{Z}^{FF, (\ell)}_1\right)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times d_{\text{ff}}\)</span></p></td>
<td><p>Applies the GELU non-linear activation function to the output of the first linear transformation.</p></td>
</tr>
<tr class="row-odd"><td><p>Second Linear Transformation in FFN</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_5\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span></p></td>
<td><p>Transforms the activated output back down to the original dimensionality <span class="math notranslate nohighlight">\(D\)</span> of the embeddings.</p></td>
</tr>
<tr class="row-even"><td><p><strong>Weights and Biases</strong></p></td>
<td><p></p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>Weights for First Linear Transformation</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}^{FF, (\ell)}_1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(D \times d_{\text{ff}}\)</span></p></td>
<td><p>Weights used to transform the input embeddings from dimension <span class="math notranslate nohighlight">\(D\)</span> to <span class="math notranslate nohighlight">\(d_{\text{ff}}\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p>Biases for First Linear Transformation</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{b}^{FF, (\ell)}_1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(d_{\text{ff}}\)</span></p></td>
<td><p>Biases added to the linearly transformed embeddings in the first FFN layer.</p></td>
</tr>
<tr class="row-odd"><td><p>Weights for Second Linear Transformation</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}^{FF, (\ell)}_2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(d_{\text{ff}} \times D\)</span></p></td>
<td><p>Weights used to project the activated embeddings from dimension <span class="math notranslate nohighlight">\(d_{\text{ff}}\)</span> back to <span class="math notranslate nohighlight">\(D\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p>Biases for Second Linear Transformation</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{b}^{FF, (\ell)}_2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(D\)</span></p></td>
<td><p>Biases added to the output of the second linear transformation in the FFN, shaping it back to the original embedding dimension.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="the-full-workflow">
<h2><a class="toc-backref" href="#id41" role="doc-backlink">The Full Workflow</a><a class="headerlink" href="#the-full-workflow" title="Link to this heading">#</a></h2>
<section id="autoregressive-self-supervised-learning-paradigm">
<h3><a class="toc-backref" href="#id42" role="doc-backlink">Autoregressive Self-Supervised Learning Paradigm</a><a class="headerlink" href="#autoregressive-self-supervised-learning-paradigm" title="Link to this heading">#</a></h3>
<p>Let <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> be the true but unknown distribution of the natural language
space. In the context of unsupervised learning with self-supervision, such as
language modeling, we consider both the inputs and the implicit labels derived
from the same data sequence. Thus, while traditionally we might decompose the
distribution <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> of a supervised learning task into input space
<span class="math notranslate nohighlight">\(\mathcal{X}\)</span> and label space <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span>, in this scenario, <span class="math notranslate nohighlight">\(\mathcal{X}\)</span> and
<span class="math notranslate nohighlight">\(\mathcal{Y}\)</span> are intrinsically linked, because <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span> is a shifted
version of <span class="math notranslate nohighlight">\(\mathcal{X}\)</span>, and so we can consider <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> as a distribution
over <span class="math notranslate nohighlight">\(\mathcal{X}\)</span> only.</p>
<p>Since <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> is a distribution, we also define it as a probability
distribution over <span class="math notranslate nohighlight">\(\mathcal{X}\)</span>, and we can write it as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathcal{D} &amp;= \mathbb{P}(\mathcal{X} ; \boldsymbol{\Theta}) \\
            &amp;= \mathbb{P}_{\{\mathcal{X} ; \boldsymbol{\Theta}\}}(\mathbf{x})
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{\Theta}\)</span> is the parameter space that defines the distribution
<span class="math notranslate nohighlight">\(\mathbb{P}(\mathcal{X} ; \boldsymbol{\Theta})\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is a sample
from <span class="math notranslate nohighlight">\(\mathcal{X}\)</span> generated by the distribution <span class="math notranslate nohighlight">\(\mathcal{D}\)</span>. It is common to
treat <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> as a sequence of tokens (i.e. a sentence is a sequence of
tokens), and we can write <span class="math notranslate nohighlight">\(\mathbf{x} = \left(x_1, x_2, \ldots, x_T\right)\)</span>,
where <span class="math notranslate nohighlight">\(T\)</span> is the length of the sequence.</p>
<p>Given such a sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>, the joint probability of the sequence can be
factorized into the product of the conditional probabilities of each token in
the sequence via the
<a class="reference external" href="https://en.wikipedia.org/wiki/Chain_rule_(probability)">chain rule of probability</a>:</p>
<div class="math notranslate nohighlight">
\[
\mathbb{P}(\mathbf{x} ; \boldsymbol{\Theta}) = \prod_{t=1}^T \mathbb{P}(x_t \mid x_1, x_2, \ldots, x_{t-1} ; \boldsymbol{\Theta})
\]</div>
<p>We can do this because natural language are <em>inherently ordered</em>. Such
decomposition allows for <em>tractable sampling</em> from and <em>estimation</em> of the
distribution <span class="math notranslate nohighlight">\(\mathbb{P}(\mathbf{x} ; \boldsymbol{\Theta})\)</span> as well as any
conditionals in the form of
<span class="math notranslate nohighlight">\(\mathbb{P}(x_{t-k}, x_{t-k+1}, \ldots, x_{t} \mid x_{1}, x_{2}, \ldots, x_{t-k-1} ; \boldsymbol{\Theta})\)</span>
<span id="id4">[<a class="reference internal" href="../../bibliography.html#id13" title="Alec Radford, Jeff Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language models are unsupervised multitask learners. 2019.">Radford <em>et al.</em>, 2019</a>]</span>.</p>
<p>To this end, consider a corpus <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> with <span class="math notranslate nohighlight">\(N\)</span> sequences
<span class="math notranslate nohighlight">\(\left\{\mathbf{x}_{1}, \mathbf{x}_{2}, \ldots, \mathbf{x}_{N}\right\}\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\mathcal{S} = \left\{\mathbf{x}_{1}, \mathbf{x}_{2}, \ldots, \mathbf{x}_{N}\right\} \underset{\text{i.i.d.}}{\sim} \mathcal{D}
\]</div>
<p>where each sequence <span class="math notranslate nohighlight">\(\mathbf{x}_{n}\)</span> is a sequence of tokens that are sampled
<span class="math notranslate nohighlight">\(\text{i.i.d.}\)</span> from the distribution <span class="math notranslate nohighlight">\(\mathcal{D}\)</span>.</p>
<p>Then, we can frame the
<a class="reference external" href="https://gao-hongnan.github.io/gaohn-galaxy/probability_theory/08_estimation_theory/maximum_likelihood_estimation/concept.html">likelihood function</a>
<span class="math notranslate nohighlight">\(\hat{\mathcal{L}}(\cdot)\)</span> as the likelihood of observing the sequences in the
corpus <span class="math notranslate nohighlight">\(\mathcal{S}\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\hat{\mathcal{L}}\left(\mathcal{S} ; \hat{\boldsymbol{\Theta}}\right) = \prod_{n=1}^N \mathbb{P}(\mathbf{x}_{n} ; \hat{\boldsymbol{\Theta}})
\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\boldsymbol{\Theta}}\)</span> is the estimated parameter space that
approximates the true parameter space <span class="math notranslate nohighlight">\(\boldsymbol{\Theta}\)</span>.</p>
<p>Subsequently, the objective function is now well-defined, to be the maximization
of the likelihood of the sequences in the corpus <span class="math notranslate nohighlight">\(\mathcal{S}\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\hat{\boldsymbol{\theta}}^{*} &amp;= \underset{\hat{\boldsymbol{\theta}} \in \boldsymbol{\Theta}}{\text{argmax}} \hat{\mathcal{L}}\left(\mathcal{S} ; \hat{\boldsymbol{\Theta}}\right) \\
                              &amp;= \underset{\hat{\boldsymbol{\theta}} \in \boldsymbol{\Theta}}{\text{argmax}} \prod_{n=1}^N \mathbb{P}(\mathbf{x}_{n} ; \hat{\boldsymbol{\Theta}}) \\
                              &amp;= \underset{\hat{\boldsymbol{\theta}} \in \boldsymbol{\Theta}}{\text{argmax}} \prod_{n=1}^N \prod_{t=1}^{T_n} \mathbb{P}(x_{n, t} \mid x_{n, 1}, x_{n, 2}, \ldots, x_{n, t-1} ; \hat{\boldsymbol{\Theta}}) \\
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(T_n\)</span> is the length of the sequence <span class="math notranslate nohighlight">\(\mathbf{x}_{n}\)</span>.</p>
<p>Owing to the fact that multiplying many probabilities together can lead to
<a class="reference external" href="https://d2l.ai/chapter_appendix-mathematics-for-deep-learning/maximum-likelihood.html#numerical-optimization-and-the-negative-log-likelihood">numerical instability</a>
because the product of many probabilities can be very small, it is common and
necessary to use the log-likelihood as the objective function, because it can be
proven that maximizing the log-likelihood is equivalent to maximizing the
likelihood itself.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\hat{\boldsymbol{\theta}}^{*} &amp;= \underset{\hat{\boldsymbol{\theta}} \in \boldsymbol{\Theta}}{\text{argmax}} \log\left(\hat{\mathcal{L}}\left(\mathcal{S} ; \hat{\boldsymbol{\Theta}}\right)\right) \\
&amp;= \underset{\hat{\boldsymbol{\theta}} \in \boldsymbol{\Theta}}{\text{argmax}} \sum_{n=1}^N \sum_{t=1}^{T_n} \log \mathbb{P}(x_{n, t} \mid x_{n, 1}, x_{n, 2}, \ldots, x_{n, t-1} ; \hat{\boldsymbol{\Theta}}) \\
\end{aligned}
\end{split}\]</div>
<p>Furthermore, since we are treating the the loss function as a form of
minimization, we can simply negate the log-likelihood to obtain the negative
log-likelihood as the objective function to be minimized,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\hat{\boldsymbol{\theta}}^{*} &amp;= \underset{\hat{\boldsymbol{\theta}} \in \boldsymbol{\Theta}}{\text{argmin}} \left(-\log\left(\hat{\mathcal{L}}\left(\mathcal{S} ; \hat{\boldsymbol{\Theta}}\right)\right)\right) \\
&amp;= \underset{\hat{\boldsymbol{\theta}} \in \boldsymbol{\Theta}}{\text{argmin}} \left(-\sum_{n=1}^N \sum_{t=1}^{T_n} \log \mathbb{P}(x_{n, t} \mid x_{n, 1}, x_{n, 2}, \ldots, x_{n, t-1} ; \hat{\boldsymbol{\Theta}})\right) \\
\end{aligned}
\end{split}\]</div>
<p>It is worth noting that the objective function is a function of the parameter
space <span class="math notranslate nohighlight">\(\hat{\boldsymbol{\Theta}}\)</span>, and not the data <span class="math notranslate nohighlight">\(\mathcal{S}\)</span>, so all
analysis such as convergence and consistency will be with respect to the
parameter space <span class="math notranslate nohighlight">\(\hat{\boldsymbol{\Theta}}\)</span>.</p>
<p>To this end, we denote the GPT model <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> to be an <em>autoregressive</em> and
<em>self-supervised learning</em> model that is trained to maximize the likelihood of
observing all data points <span class="math notranslate nohighlight">\(\mathbf{x} \in \mathcal{S}\)</span> via the objective
function <span class="math notranslate nohighlight">\(\hat{\mathcal{L}}\left(\mathcal{S} ; \hat{\boldsymbol{\Theta}}\right)\)</span>
by learning the conditional probability distribution
<span class="math notranslate nohighlight">\(\mathbb{P}(x_t \mid x_{&lt;t} ; \hat{\boldsymbol{\Theta}})\)</span> over the vocabulary
<span class="math notranslate nohighlight">\(\mathcal{V}\)</span> of tokens, conditioned on the contextual preciding tokens
<span class="math notranslate nohighlight">\(x_{&lt;t} = \left(x_1, x_2, \ldots, x_{t-1}\right)\)</span>. We are clear that although
the goal is to model the joint probability distribution of the token sequences,
we can do so by estimating the joint probability distribution via the
conditional probability distributions.</p>
</section>
<section id="steps">
<h3><a class="toc-backref" href="#id43" role="doc-backlink">Steps</a><a class="headerlink" href="#steps" title="Link to this heading">#</a></h3>
<div class="note admonition">
<p class="admonition-title">Step 1. Corpus</p>
<p>Consider a corpus <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> consisting of <span class="math notranslate nohighlight">\(N\)</span> sequences, denoted as
<span class="math notranslate nohighlight">\({\mathbf{x}_1, \mathbf{x}_2, \ldots, \mathbf{x}_N}\)</span>, where each sequence
<span class="math notranslate nohighlight">\(\mathbf{x} = (x_1, x_2, \ldots, x_T) \in \mathcal{S}\)</span> is a sequence of <span class="math notranslate nohighlight">\(T\)</span>
tokens. These tokens are sampled i.i.d. from a true, unknown distribution
<span class="math notranslate nohighlight">\(\mathcal{D}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{S}=\left\{\mathbf{x}_1, \mathbf{x}_2, \ldots, \mathbf{x}_N\right\} \underset{\text { i.i.d. }}{\sim} \mathcal{D}
\]</div>
<p>Each sequence <span class="math notranslate nohighlight">\(\mathbf{x} \in \mathcal{S}\)</span> represents a collection of tokenized
elements (e.g., words or characters), where each token <span class="math notranslate nohighlight">\(x_t\)</span> comes from a finite
vocabulary <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>.</p>
</div>
<div class="note admonition">
<p class="admonition-title">Step 2. Vocabulary and Tokenization</p>
<p>Let <span class="math notranslate nohighlight">\(\mathcal{V} = \{w_1, w_2, \ldots, w_V\}\)</span> be the vocabulary set, where <span class="math notranslate nohighlight">\(w_j\)</span>
is the <span class="math notranslate nohighlight">\(j\)</span>-th token in the vocabulary and <span class="math notranslate nohighlight">\(V = |\mathcal{V}|\)</span> is the size of the
vocabulary. It is worth noting that it is common to train one‚Äôs own vocabulary
and tokenizer on the corpus <span class="math notranslate nohighlight">\(\mathcal{S}\)</span>, but for simplicity, we assume that
the vocabulary set <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> is predefined.</p>
<p>Let <span class="math notranslate nohighlight">\(\mathcal{X}\)</span> be the set of all possible sequences that can be formed by
concatenating tokens from the vocabulary set <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>. Each sequence
<span class="math notranslate nohighlight">\(\mathbf{x} \in \mathcal{X}\)</span> is a finite sequence of tokens, and the length of
each sequence is denoted by <span class="math notranslate nohighlight">\(\tau\)</span>. Formally:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{X} = \bigcup_{\tau=1}^{T} \mathcal{V}^{\tau}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{V}^\tau\)</span> represents the set of all sequences of length <span class="math notranslate nohighlight">\(\tau\)</span>
formed by concatenating tokens from <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>, and <span class="math notranslate nohighlight">\(T\)</span> is the maximum
sequence length.</p>
<p>Now, let
<span class="math notranslate nohighlight">\(\mathcal{S} = \{\mathbf{x}_1, \mathbf{x}_2, \ldots, \mathbf{x}_N\} \subset \mathcal{X}\)</span>
be a corpus of <span class="math notranslate nohighlight">\(N\)</span> sequences, where each sequence <span class="math notranslate nohighlight">\(\mathbf{x}_n \in \mathcal{X}\)</span>
is a finite sequence of tokens from the vocabulary set <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>.</p>
<p>The tokenizer algorithm <span class="math notranslate nohighlight">\(\mathcal{T}\)</span> is a function that operates on individual
sequences <span class="math notranslate nohighlight">\(\mathbf{x}_n\)</span> from the corpus <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> and maps the tokens to
their corresponding integer indices using the vocabulary set <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{T}: \mathcal{X} \rightarrow \mathbb{N}^{\leq T}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbb{N}^{\leq T}\)</span> represents the set of all finite sequences of
natural numbers (non-negative integers) with lengths up to <span class="math notranslate nohighlight">\(T\)</span>. The output of
<span class="math notranslate nohighlight">\(\mathcal{T}\)</span> is a tokenized sequence, which is a finite sequence of integer
indices corresponding to the tokens in the input sequence.</p>
<p>To map the tokens to their corresponding integer indices, we define a bijective
mapping function <span class="math notranslate nohighlight">\(f: \mathcal{V} \rightarrow \{1, 2, \ldots, V\}\)</span> such that:</p>
<div class="math notranslate nohighlight">
\[
f(w_j) = j, \quad \forall j \in \{1, 2, \ldots, V\}
\]</div>
<p>where <span class="math notranslate nohighlight">\(f(w_j)\)</span> represents the integer index assigned to the token
<span class="math notranslate nohighlight">\(w_j \in \mathcal{V}\)</span>.</p>
<p>Given a sequence <span class="math notranslate nohighlight">\(\mathbf{x} = (x_1, x_2, \ldots, x_\tau) \in \mathcal{X}\)</span>,
where <span class="math notranslate nohighlight">\(\tau \leq T\)</span> is the length of the sequence, the tokenizer algorithm
<span class="math notranslate nohighlight">\(\mathcal{T}\)</span> maps each token <span class="math notranslate nohighlight">\(x_t\)</span> to its corresponding integer index using the
bijective mapping function <span class="math notranslate nohighlight">\(f\)</span>. The tokenized representation of the sequence
<span class="math notranslate nohighlight">\(\mathbf{x}\)</span> can be defined as:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{T}(\mathbf{x}) = \left(f(x_1), f(x_2), \ldots, f(x_\tau)\right)
\]</div>
<p>where <span class="math notranslate nohighlight">\(f(x_t)\)</span> is the integer index assigned to the token <span class="math notranslate nohighlight">\(x_t\)</span> based on <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>In the case where a token <span class="math notranslate nohighlight">\(x_t\)</span> is not present in the vocabulary set
<span class="math notranslate nohighlight">\(\mathcal{V}\)</span>, a special token index, such as <span class="math notranslate nohighlight">\(f(\text{&lt;UNK&gt;})\)</span>, can be assigned
to represent an unknown token.</p>
<p>The tokenizer algorithm <span class="math notranslate nohighlight">\(\mathcal{T}\)</span> can be applied to each sequence
<span class="math notranslate nohighlight">\(\mathbf{x}_n\)</span> in the corpus <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> to obtain the tokenized corpus
<span class="math notranslate nohighlight">\(\mathcal{S}^{\mathcal{T}}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\mathcal{S}^{\mathcal{T}} = \left\{\mathcal{T}(\mathbf{x}_1), \mathcal{T}(\mathbf{x}_2), \ldots, \mathcal{T}(\mathbf{x}_N)\right\} \subset \mathbb{N}^{\leq T}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{T}(\mathbf{x}_n)\)</span> is the tokenized representation of the
sequence <span class="math notranslate nohighlight">\(\mathbf{x}_n \in \mathcal{S}\)</span>.</p>
<p>The tokenized corpus <span class="math notranslate nohighlight">\(\mathcal{S}^{\mathcal{T}}\)</span> is a set of sequences, where
each sequence is a finite sequence of integer indices representing the tokens in
the original sequences from the corpus <span class="math notranslate nohighlight">\(\mathcal{S}\)</span>.</p>
</div>
<div class="note admonition">
<p class="admonition-title">Step 3. One Hot Encoding</p>
<p>For each sequence <span class="math notranslate nohighlight">\(\mathbf{x} \in \mathcal{S}^{\mathcal{T}}\)</span> in the corpus, we
would apply one hot encoding so that each sample/sequence is transformed to
<span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}} \in \{0, 1\}^{T \times V}\)</span> where <span class="math notranslate nohighlight">\(V\)</span> is the vocabulary
size and <span class="math notranslate nohighlight">\(T\)</span> the pre-defined context window size.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{X}^{\text{ohe}} = \begin{bmatrix}
o_{1,1} &amp; o_{1,2} &amp; \cdots &amp; o_{1,V} \\
o_{2,1} &amp; o_{2,2} &amp; \cdots &amp; o_{2,V} \\
\vdots  &amp; \vdots  &amp; \ddots &amp; \vdots  \\
o_{T,1} &amp; o_{T,2} &amp; \cdots &amp; o_{T,V}
\end{bmatrix} \in \{0, 1\}^{T \times V}
\end{split}\]</div>
<p>Each row <span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}_{t} \in \mathbb{R}^{1 \times V}\)</span> represents
the one-hot encoded representation of the token at position <span class="math notranslate nohighlight">\(t\)</span> in the sequence.</p>
</div>
<div class="note admonition">
<p class="admonition-title">Step 4. Token Embedding</p>
<p>Given the one-hot encoded input
<span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}} \in \{0, 1\}^{T \times |\mathcal{V}|}\)</span>, where <span class="math notranslate nohighlight">\(T\)</span> is
the sequence length and <span class="math notranslate nohighlight">\(V = |\mathcal{V}|\)</span> is the vocabulary size, we obtain
the token embedding matrix <span class="math notranslate nohighlight">\(\mathbf{X} \in \mathbb{R}^{T \times D}\)</span> by matrix
multiplying <span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span> with the token embedding weight matrix
<span class="math notranslate nohighlight">\(\mathbf{W}_e \in \mathbb{R}^{V \times D}\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> is the embedding
dimension:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{X} &amp;= \mathbf{X}^{\text{ohe}} \operatorname{&#64;} \mathbf{W}_{e} \\
T \times D                      &amp;\leftarrow T \times V \operatorname{&#64;} V \times D  \\
\mathcal{B} \times T \times D   &amp;\leftarrow\mathcal{B} \times T \times V \operatorname{&#64;} V \times D
\end{aligned}
\end{split}\]</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Weight Sharing</p>
<p>Note carefully that with the addition of batch dimension <span class="math notranslate nohighlight">\(\mathcal{B}\)</span> the
matrix multiplication is still well-defined for such tensor in PyTorch because
we are essentially just performing matrix multiplication in <span class="math notranslate nohighlight">\(T \times D\)</span> for
each sequence <span class="math notranslate nohighlight">\(\mathbf{X}_b \in \mathbf{X}^{\mathcal{B}}\)</span> with the same weight
matrix <span class="math notranslate nohighlight">\(\mathbf{W}_{e}\)</span>.</p>
<p>The token embedding weight matrix <span class="math notranslate nohighlight">\(\mathbf{W}_e\)</span> with dimensions <span class="math notranslate nohighlight">\(V \times D\)</span> is
shared across all sequences in the batch. Each sequence <span class="math notranslate nohighlight">\(\mathbf{X}^{(b)}\)</span> in the
batched input tensor <span class="math notranslate nohighlight">\(\mathbf{X}^{\mathcal{B}}\)</span> undergoes the same matrix
multiplication with <span class="math notranslate nohighlight">\(\mathbf{W}_e\)</span> to obtain the corresponding embedded sequence
representation.</p>
<p>The idea of weight sharing is that the same set of parameters (in this case, the
embedding weights) is used for processing multiple instances of the input
(sequences in the batch). Instead of having separate embedding weights for each
sequence, the same embedding matrix is applied to all sequences. This parameter
sharing allows the model to learn a common representation for the tokens across
different sequences.</p>
</div>
<div class="note admonition">
<p class="admonition-title">Step 5. Positional Embedding</p>
<p>In addition to the token embeddings, we incorporate positional information into
the input representation to capture the sequential nature of the input
sequences. Let <span class="math notranslate nohighlight">\(\operatorname{PE}(\cdot)\)</span> denote the positional encoding
function that maps the token positions to their corresponding positional
embeddings.</p>
<p>Given the token embedding matrix <span class="math notranslate nohighlight">\(\mathbf{X} \in \mathbb{R}^{T \times D}\)</span>, where
<span class="math notranslate nohighlight">\(T\)</span> is the sequence length and <span class="math notranslate nohighlight">\(D\)</span> is the embedding dimension, we add the
positional embeddings to obtain the position-aware input representation
<span class="math notranslate nohighlight">\(\tilde{\mathbf{X}} \in \mathbb{R}^{T \times D}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\tilde{\mathbf{X}} &amp;= \operatorname{PE}(\mathbf{X}) + \mathbf{X} \\
T \times D                      &amp;\leftarrow T \times D \operatorname{+} T \times D  \\
\mathcal{B} \times T \times D   &amp;\leftarrow \mathcal{B} \times T \times D \operatorname{+} \mathcal{B} \times T \times D
\end{aligned}
\end{split}\]</div>
<p>The positional encoding function <span class="math notranslate nohighlight">\(\operatorname{PE}(\cdot)\)</span> can be implemented
in various ways, such as using fixed sinusoidal functions or learned positional
embeddings. For the latter, we can easily replace <span class="math notranslate nohighlight">\(\operatorname{PE}(\cdot)\)</span>
with a learnable positional embedding layer in the model architecture
(<span class="math notranslate nohighlight">\(\mathbf{W}_{p}\)</span>).</p>
</div>
<div class="tip admonition">
<p class="admonition-title">Dropout And Elementwise Operation</p>
<p>At this stage, it is common practice to apply a dropout layer
<span class="math notranslate nohighlight">\(\operatorname{Dropout}(\cdot)\)</span> to the position-aware input representation
<span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span> (or <span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}_{\text{batch}}\)</span> in the case of a
batch). Dropout is a regularization technique that randomly sets a fraction of
the elements in the input tensor to zero during training and is an
<strong><em>element-wise</em></strong> operation that acts <strong><em>independently</em></strong> on each element in
the tensor. This means that each element has a fixed probability (usually
denoted as <span class="math notranslate nohighlight">\(p\)</span>) of being set to zero, regardless of its position or the values
of other elements in the tensor.</p>
<p>Mathematically, for an input tensor <span class="math notranslate nohighlight">\(\mathbf{X} \in \mathbb{R}^{T \times D}\)</span>,
elementwise dropout can be expressed as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{X}^{\text{dropout}} &amp;= \mathbf{X} \odot \mathbf{M} \\
T \times D &amp;= T \times D \odot T \times D
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\odot\)</span> denotes the elementwise (Hadamard) product, and
<span class="math notranslate nohighlight">\(\mathbf{M} \in \{0, 1\}^{T \times D}\)</span> is a binary mask tensor of the same shape
as <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>. Each element in <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is independently sampled from a
Bernoulli distribution with probability <span class="math notranslate nohighlight">\(p\)</span> of being 0 (i.e., dropped) and
probability <span class="math notranslate nohighlight">\(1-p\)</span> of being 1 (i.e., retained).</p>
</div>
<div class="note admonition">
<p class="admonition-title">Step 6. Pre-Layer Normalization For Masked Multi-Head Attention</p>
<p>Before passing the input through the Multi-Head Attention (MHA) layer, we apply
Layer Normalization to the positionally encoded embeddings <span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span>.
This is known as pre-layer Normalization in the more modern GPT architecture (as
opposed to post-layer Normalization, which is applied after the MHA layer).</p>
<p>The Layer Normalization function <span class="math notranslate nohighlight">\(\operatorname{LayerNorm}(\cdot)\)</span> is a
<strong><em>vectorwise</em></strong> operation that operates on the feature dimension <span class="math notranslate nohighlight">\(D\)</span> of the
input tensor. It normalizes the activations to have zero mean and unit variance
across the features for each token independently. The vectorwise nature of Layer
Normalization arises from the fact that it computes the mean and standard
deviation along the feature dimension, requiring <strong>aggregation</strong> of information
across the entire feature vector for each token.</p>
<p>Mathematically, for an input tensor <span class="math notranslate nohighlight">\(\mathbf{X} \in \mathbb{R}^{T \times D}\)</span>,
Layer Normalization is applied independently to each row
<span class="math notranslate nohighlight">\(\mathbf{x}_t \in \mathbb{R}^{1 \times D}\)</span>, where <span class="math notranslate nohighlight">\(t \in \{1, 2, \ldots, T\}\)</span>.
The normalization is performed using the following formula:</p>
<div class="math notranslate nohighlight">
\[
\operatorname{LayerNorm}(\mathbf{x}_t) = \frac{\mathbf{x}_t - \mu_t}{\sqrt{\sigma_t^2 + \epsilon}} \odot \gamma + \beta
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu_t \in \mathbb{R}\)</span> and <span class="math notranslate nohighlight">\(\sigma_t^2 \in \mathbb{R}\)</span> are the mean and
variance of the features in <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span> (broadcasted), respectively,
<span class="math notranslate nohighlight">\(\epsilon\)</span> is a small constant for numerical stability,
<span class="math notranslate nohighlight">\(\gamma \in \mathbb{R}^D\)</span> and <span class="math notranslate nohighlight">\(\beta \in \mathbb{R}^D\)</span> are learnable affine
parameters (scale and shift), and <span class="math notranslate nohighlight">\(\odot\)</span> denotes the elementwise product.</p>
<p>Applying Layer Normalization to the positionally encoded embeddings
<span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span> at layer <span class="math notranslate nohighlight">\(\ell\)</span> results in the normalized embeddings
<span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{(\ell)}_1 &amp;= \operatorname{LayerNorm}\left(\tilde{\mathbf{X}}\right) \\
T \times D &amp;\leftarrow T \times D \\
\mathcal{B} \times T \times D &amp;\leftarrow \mathcal{B} \times T \times D
\end{aligned}
\end{split}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1\)</span> represents the normalized embeddings at layer
<span class="math notranslate nohighlight">\(\ell\)</span>, and the index <span class="math notranslate nohighlight">\(1\)</span> refers to the first sub-layer/sub-step in the decoder
block.</p>
<p>For the first layer (<span class="math notranslate nohighlight">\(\ell = 1\)</span>), <span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span> is the output from Step 4
(Positional Embedding). So we have:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{(1)}_1 &amp;= \operatorname{LayerNorm}\left(\tilde{\mathbf{X}}\right) \\
T \times D &amp;\leftarrow T \times D \\
\mathcal{B} \times T \times D &amp;\leftarrow \mathcal{B} \times T \times D
\end{aligned}
\end{split}\]</div>
<p>In code we have:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># [1]</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># [2]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">elementwise_affine</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">std</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span>  <span class="c1"># [3]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">std</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>  <span class="c1"># [4]</span>
</pre></div>
</div>
</div>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Line</strong></p></th>
<th class="head"><p><strong>Code</strong></p></th>
<th class="head"><p><strong>Operation Description</strong></p></th>
<th class="head"><p><strong>Input Shape</strong></p></th>
<th class="head"><p><strong>Output Shape</strong></p></th>
<th class="head"><p><strong>Notes</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>[1]</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mean</span> <span class="pre">=</span> <span class="pre">x.mean(dim=-1,</span> <span class="pre">keepdim=True)</span></code></p></td>
<td><p>Computes the mean of <code class="docutils literal notranslate"><span class="pre">x</span></code> along the last dimension.</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times 1\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">keepdim=True</span></code> ensures the number of dimensions is preserved, facilitating broadcasting in subsequent operations. Mean is computed for each feature vector.</p></td>
</tr>
<tr class="row-odd"><td><p>[2]</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">x.std(dim=-1,</span> <span class="pre">keepdim=True,</span> <span class="pre">unbiased=False)</span></code></p></td>
<td><p>Computes the standard deviation along the last dimension.</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times 1\)</span></p></td>
<td><p>Similar to the mean, <code class="docutils literal notranslate"><span class="pre">std</span></code> is computed per feature vector with unbiased variance estimation disabled (appropriate for normalization purposes).</p></td>
</tr>
<tr class="row-even"><td><p>[3]</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">self.gamma</span> <span class="pre">*</span> <span class="pre">(x</span> <span class="pre">-</span> <span class="pre">mean)</span> <span class="pre">/</span> <span class="pre">(std</span> <span class="pre">+</span> <span class="pre">self.eps)</span> <span class="pre">+</span> <span class="pre">self.beta</span></code></p></td>
<td><p>Applies the normalization formula with learnable parameters gamma (<span class="math notranslate nohighlight">\(\gamma\)</span>) and beta (<span class="math notranslate nohighlight">\(\beta\)</span>).</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span></p></td>
<td><p>Element-wise operations are used. <span class="math notranslate nohighlight">\(\gamma\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are of shape <span class="math notranslate nohighlight">\(D\)</span>, and are broadcasted to match the input shape. This line only executes if <code class="docutils literal notranslate"><span class="pre">elementwise_affine</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>[4]</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">(x</span> <span class="pre">-</span> <span class="pre">mean)</span> <span class="pre">/</span> <span class="pre">(std</span> <span class="pre">+</span> <span class="pre">self.eps)</span></code></p></td>
<td><p>Applies the normalization formula without learnable parameters.</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span></p></td>
<td><p>Simple normalization where each element in the feature vector <span class="math notranslate nohighlight">\(x\)</span> is normalized by the corresponding mean and standard deviation.</p></td>
</tr>
</tbody>
</table>
<div class="note admonition">
<p class="admonition-title">Step 7. Masked Multi-Head Self-Attention</p>
<p>Given the normalized input embeddings
<span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1 \in \mathbb{R}^{\mathcal{B} \times T \times D}\)</span> from Step
6 (Pre-Layer Normalization), we apply the masked multi-head self-attention
mechanism to compute the output embeddings <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_2\)</span>, where the
index <span class="math notranslate nohighlight">\(2\)</span> denotes the second sub-layer within the <span class="math notranslate nohighlight">\(\ell\)</span>-th decoder layer
(multi-head attention).</p>
<p>Let <span class="math notranslate nohighlight">\(\operatorname{MaskedMultiHead}^{(\ell)}(\cdot)\)</span> denote the masked
multi-head self-attention function at layer <span class="math notranslate nohighlight">\(\ell\)</span>. The masked multi-head
self-attention operation takes the normalized input embeddings
<span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1\)</span> as the query, key, and value matrices, and produces the
output embeddings <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_2\)</span>.</p>
<p>For the first layer (<span class="math notranslate nohighlight">\(\ell = 1\)</span>), the masked multi-head self-attention operation
can be expressed as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{(1)}_2 &amp;= \operatorname{MaskedMultiHead}^{(1)}\left(\mathbf{Z}^{(1)}_1, \mathbf{Z}^{(1)}_1, \mathbf{Z}^{(1)}_1\right) \\
\mathcal{B} \times T \times D &amp;\leftarrow \operatorname{MaskedMultiHead}^{(1)}\left(\mathcal{B} \times T \times D, \mathcal{B} \times T \times D, \mathcal{B} \times T \times D\right) \\
\mathcal{B} \times T \times D &amp;\leftarrow \mathcal{B} \times T \times D
\end{aligned}
\end{split}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_2 \in \mathbb{R}^{\mathcal{B} \times T \times D}\)</span>
represents the output embeddings of the masked multi-head self-attention
operation at layer <span class="math notranslate nohighlight">\(1\)</span>, and
<span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_1 \in \mathbb{R}^{\mathcal{B} \times T \times D}\)</span> represents
the normalized input embeddings from Step 6.</p>
<p>The <span class="math notranslate nohighlight">\(\operatorname{MaskedMultiHead}^{(\ell)}(\cdot)\)</span> function internally
performs the following steps:</p>
<ol class="arabic simple">
<li><p>Linearly projects the input embeddings <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1\)</span> into query,
key, and value matrices for each attention head.</p></li>
<li><p>Computes the scaled dot-product attention scores between the query and key
matrices, and applies the attention mask to prevent attending to future
tokens.</p></li>
<li><p>Applies the softmax function to the masked attention scores to obtain the
attention weights.</p></li>
<li><p>Multiplies the attention weights with the value matrices to produce the
output embeddings for each attention head.</p></li>
<li><p>Concatenates the output embeddings from all attention heads and linearly
projects them to obtain the final output embeddings <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_2\)</span>.</p></li>
</ol>
<p>The specifics of the scaled dot-product attention mechanism and the multi-head
attention operation will be discussed in the next few steps.</p>
</div>
<div class="note admonition">
<p class="admonition-title">Step 7.1. Linear Projections, Query, Key, and Value Matrices</p>
<p>In the masked multi-head self-attention mechanism, the first step is to linearly
project the normalized input embeddings <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1\)</span> into query, key,
and value matrices for each attention head. This step is performed using
learnable weight matrices <span class="math notranslate nohighlight">\(\mathbf{W}^{Q, (\ell)}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{W}^{K, (\ell)}\)</span>,
and <span class="math notranslate nohighlight">\(\mathbf{W}^{V, (\ell)}\)</span>.</p>
<p>Mathematically, the linear projections can be expressed as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Q}^{(\ell)} &amp;= \mathbf{Z}^{(\ell)}_1 \mathbf{W}^{Q, (\ell)} ,\quad \mathcal{B} \times T \times D \leftarrow \mathcal{B} \times T \times D \times D \\
\mathbf{K}^{(\ell)} &amp;= \mathbf{Z}^{(\ell)}_1 \mathbf{W}^{K, (\ell)} ,\quad \mathcal{B} \times T \times D \leftarrow \mathcal{B} \times T \times D \times D \\
\mathbf{V}^{(\ell)} &amp;= \mathbf{Z}^{(\ell)}_1 \mathbf{W}^{V, (\ell)} ,\quad \mathcal{B} \times T \times D \leftarrow \mathcal{B} \times T \times D \times D
\end{aligned}
\end{split}\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{Q}^{(\ell)} \in \mathbb{R}^{\mathcal{B} \times T \times D}\)</span> is the
query matrix for the <span class="math notranslate nohighlight">\(\ell\)</span>-th decoder layer.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{K}^{(\ell)} \in \mathbb{R}^{\mathcal{B} \times T \times D}\)</span> is the
key matrix for the <span class="math notranslate nohighlight">\(\ell\)</span>-th decoder layer.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{V}^{(\ell)} \in \mathbb{R}^{\mathcal{B} \times T \times D}\)</span> is the
value matrix for the <span class="math notranslate nohighlight">\(\ell\)</span>-th decoder layer.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{W}^{Q, (\ell)} \in \mathbb{R}^{D \times D}\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{W}^{K, (\ell)} \in \mathbb{R}^{D \times D}\)</span>, and
<span class="math notranslate nohighlight">\(\mathbf{W}^{V, (\ell)} \in \mathbb{R}^{D \times D}\)</span> are the learnable
weight matrices that transform the normalized embeddings into queries, keys,
and values, respectively.</p></li>
<li><p>Again notice that we are using the same weight matrices for all heads,
weight/parameters sharing.</p></li>
</ul>
<p>The linear projections are performed using matrix multiplication between the
normalized input embeddings <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1\)</span> and the corresponding weight
matrices. The resulting query, key, and value matrices have the same shape as
the input embeddings: <span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span>.</p>
<p>In the provided code snippet, the linear projections are implemented using the
<code class="docutils literal notranslate"><span class="pre">torch.nn.Linear</span></code> modules <code class="docutils literal notranslate"><span class="pre">self.W_Q</span></code>, <code class="docutils literal notranslate"><span class="pre">self.W_K</span></code>, and <code class="docutils literal notranslate"><span class="pre">self.W_V</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_Q</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>  <span class="c1"># Z @ W_Q = [B, T, D] @ [D, D] = [B, T, D]</span>
<span class="n">K</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>  <span class="c1"># Z @ W_K = [B, T, D] @ [D, D] = [B, T, D]</span>
<span class="n">V</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_V</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>  <span class="c1"># Z @ W_V = [B, T, D] @ [D, D] = [B, T, D]</span>
</pre></div>
</div>
</div>
<div class="note admonition">
<p class="admonition-title">Step 7.2. Reshaping and Transposing Query, Key, and Value Matrices</p>
<p>Subsequently, we have already known that instead of for loop to compute each
head, we can compute all heads in parallel using matrix operations. The query,
key, and value matrices are split into <span class="math notranslate nohighlight">\(H\)</span> heads, and the attention scores are
computed in parallel. So our aim is simple, we want to reshape the query, key,
and value matrices to include the head dimension, basically splitting the <span class="math notranslate nohighlight">\(D\)</span>
dimension into <span class="math notranslate nohighlight">\(H\)</span> heads. We can denote the reshaping and transposition
operation using tensor index notation which makes it explicit how indices are
permuted and combined:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Q}_{b,t,d} &amp; \rightarrow \mathbf{Q}_{b,t,h,d_q} \quad \text{where } d = h \cdot (D // H) + d_q, \text{ for } h \in [0, H-1] \text{ and } d_q \in [0, D//H-1] \\
\mathbf{Q}_{b,t,h,d_q} &amp; \rightarrow \mathbf{Q}_{b,h,t,d_q} \quad \text{(transpose dimensions)}
\end{aligned}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{K}_{b,t,d} &amp; \rightarrow \mathbf{K}_{b,t,h,d_k} \quad \text{where } d = h \cdot (D // H) + d_k, \text{ for } h \in [0, H-1] \text{ and } d_k \in [0, D//H-1] \\
\mathbf{K}_{b,t,h,d_k} &amp; \rightarrow \mathbf{K}_{b,h,t,d_k} \quad \text{(transpose dimensions)}
\end{aligned}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{V}_{b,t,d} &amp; \rightarrow \mathbf{V}_{b,t,h,d_v} \quad \text{where } d = h \cdot (D // H) + d_v, \text{ for } h \in [0, H-1] \text{ and } d_v \in [0, D//H-1] \\
\mathbf{V}_{b,t,h,d_v} &amp; \rightarrow \mathbf{V}_{b,h,t,d_v} \quad \text{(transpose dimensions)}
\end{aligned}
\end{split}\]</div>
<p>To this end, we have reshaped and transposed the query, key, and value matrices
as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Q}^{(\ell)} &amp;\in \mathbb{R}^{\mathcal{B} \times T \times D} \rightarrow \mathbf{Q}^{(\ell)}  \in \mathbb{R}^{\mathcal{B} \times T \times H \times D // H} \rightarrow \mathbf{Q}^{(\ell)}  \in \mathbb{R}^{\mathcal{B} \times H \times T \times D // H} \\
\mathbf{K}^{(\ell)}  &amp;\in \mathbb{R}^{\mathcal{B} \times T \times D} \rightarrow \mathbf{K}^{(\ell)}  \in \mathbb{R}^{\mathcal{B} \times T \times H \times D // H} \rightarrow \mathbf{K}^{(\ell)}  \in \mathbb{R}^{\mathcal{B} \times H \times T \times D // H} \\
\mathbf{V}^{(\ell)}  &amp;\in \mathbb{R}^{\mathcal{B} \times T \times D} \rightarrow \mathbf{V}^{(\ell)}  \in \mathbb{R}^{\mathcal{B} \times T \times H \times D // H} \rightarrow \mathbf{V}^{(\ell)}  \in \mathbb{R}^{\mathcal{B} \times H \times T \times D // H}
\end{aligned}
\end{split}\]</div>
<p>In code, the reshaping and transposition operations are performed as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">D</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">dim0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># [B, T, D] -&gt; [B, T, H, D // H] -&gt; [B, H, T, D//H]</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">D</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">dim0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">D</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">dim0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">view</span></code> operation reshapes the matrices to include the head dimension, and
the <code class="docutils literal notranslate"><span class="pre">transpose</span></code> operation swaps the sequence and head dimensions to obtain the
desired ordering of dimensions.</p>
</div>
<div class="note admonition">
<p class="admonition-title">Step 7.3. Scaled Dot-Product Attention and Masking</p>
<p>The attention mask matrix <span class="math notranslate nohighlight">\(\mathbf{M} \in \{0, -\infty\}^{T \times T}\)</span> is
initially constructed as a lower triangular matrix of ones and zeros:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{M} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\
1 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\
1 &amp; 1 &amp; 1 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1
\end{bmatrix}
\end{split}\]</div>
<p>In this matrix, ‚Äú1‚Äù (conceptually) allows attention, and ‚Äú0‚Äù blocks it. This
mask is broadcastable to the attention scores tensor
<span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times T\)</span> since this is a typical shape for
multi-head self-attention.</p>
<p>However, before applying the mask, the ones in <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> are typically
replaced with zeros, and the zeros are replaced with a large negative value
(e.g., <span class="math notranslate nohighlight">\(-\infty\)</span>) to effectively set the attention weights of the masked
positions to zero after the softmax operation (which is to mimic the
<code class="docutils literal notranslate"><span class="pre">masked_fill</span></code> operation in the code). So, the actual mask matrix used in the
attention mechanism looks like this:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{M}_{ij} = \left\{\begin{array}{ll}
0 &amp; \text{if } i \geq j \\
-\infty &amp; \text{if } i &lt; j
\end{array} \right\} \quad \text{forms a triangular matrix:} \quad \begin{bmatrix}
0 &amp; -\infty &amp; -\infty &amp; \cdots &amp; -\infty \\
0 &amp; 0 &amp; -\infty &amp; \cdots &amp; -\infty \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; -\infty \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0
\end{bmatrix}
\end{split}\]</div>
<p>The masking operation will then be applied elementwise to the attention scores
tensor <span class="math notranslate nohighlight">\(\mathbf{A}_{s}^{(\ell)}\)</span>, which is first obtained by computing the
scaled dot product between the query matrix <span class="math notranslate nohighlight">\(\mathbf{Q}^{(\ell)}\)</span> and the key
matrix <span class="math notranslate nohighlight">\(\mathbf{K}^{(\ell)}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{A}_{s}^{(\ell)} &amp;= \frac{\mathbf{Q}^{(\ell)} (\mathbf{K}^{(\ell)})^T}{\sqrt{D//H}} \\
\mathcal{B} \times H \times T \times T &amp;\leftarrow \frac{\mathcal{B} \times H \times T \times D//H \operatorname{&#64;} \mathcal{B} \times H \times D//H \times T}{\sqrt{D//H}}
\end{aligned}
\end{split}\]</div>
<p>The masking operation is performed using the elementwise sum (<span class="math notranslate nohighlight">\(\oplus\)</span>) between
the attention scores tensor
<span class="math notranslate nohighlight">\(\mathbf{A}_{s}^{(\ell)} \in \mathbb{R}^{\mathcal{B} \times H \times T \times T}\)</span>
and the <strong><em>broadcasted</em></strong> mask matrix
<span class="math notranslate nohighlight">\(\mathbf{M} \in \{0, -\infty\}^{\mathcal{B} \times H \times T \times T}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{A}_{s}^{M, (\ell)} &amp;= \mathbf{A}_{s}^{(\ell)} \oplus \mathbf{M} \\
\mathcal{B} \times H \times T \times T &amp;\leftarrow \mathcal{B} \times H \times T \times T \oplus \mathcal{B} \times H \times T \times T
\end{aligned}
\end{split}\]</div>
<p>The elementwise sum ensures that the attention scores corresponding to future
tokens (positions above the diagonal) are added by <span class="math notranslate nohighlight">\(-\infty\)</span> to effectively
block attention to those positions and added by <span class="math notranslate nohighlight">\(0\)</span> for the rest of the
positions that are allowed to attend to.</p>
<p>Finally, the masked attention scores <span class="math notranslate nohighlight">\(\mathbf{A}_{s}^{M, (\ell)}\)</span> are passed
through the softmax function to obtain the attention weights
<span class="math notranslate nohighlight">\(\mathbf{A}_{w}^{(\ell)}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{A}_{w}^{(\ell)} &amp;= \operatorname{softmax}\left(\mathbf{A}_{s}^{M, (\ell)}\right) \\
\mathcal{B} \times H \times T \times T &amp;\leftarrow \operatorname{softmax}\left(\mathcal{B} \times H \times T \times T\right) \\
\mathcal{B} \times H \times T \times T &amp;\leftarrow \mathcal{B} \times H \times T \times T
\end{aligned}
\end{split}\]</div>
<p>The softmax function is then applied to the masked attention scores tensor in a
<strong>vectorwise</strong> manner. Specifically, the softmax operation is applied
<strong>independently</strong> to each row of the last two dimensions (<span class="math notranslate nohighlight">\(T \times T\)</span>) for each
batch and head. This ensures that the attention weights for each token position
across the sequence length sum up to 1. The large negative values in the masked
positions ensure that the corresponding attention weights become close to zero
after the softmax operation.</p>
<p>Finally, the context matrix <span class="math notranslate nohighlight">\(\mathbf{C}^{(\ell)}\)</span> is obtained by multiplying the
attention weights <span class="math notranslate nohighlight">\(\mathbf{A}_{w}^{(\ell)}\)</span> with the value matrix
<span class="math notranslate nohighlight">\(\mathbf{V}^{(\ell)}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{C}^{(\ell)} &amp;= \mathbf{A}_{w}^{(\ell)} \mathbf{V}^{(\ell)} \\
\mathcal{B} \times H \times T \times D//H &amp;\leftarrow \mathcal{B} \times H \times T \times T \times \mathcal{B} \times H \times T \times D//H
\end{aligned}
\end{split}\]</div>
<p>The resulting context matrix <span class="math notranslate nohighlight">\(\mathbf{C}^{(\ell)}\)</span> contains the attended values
for each head in layer <span class="math notranslate nohighlight">\(\ell\)</span>.</p>
<p>Note <span class="math notranslate nohighlight">\(\mathbf{C}^{(\ell)}\)</span> is the context matrix which is the output of the
self-attention mechanism and it contains <span class="math notranslate nohighlight">\(\operatorname{head}_{\ell, h}^{M}\)</span> for
each head <span class="math notranslate nohighlight">\(h\)</span> in the layer <span class="math notranslate nohighlight">\(\ell\)</span>.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d_q</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">attention_scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">dim0</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">d_q</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">())</span>         <span class="c1"># [B, H, T, d_q] @ [B, H, d_q, T] = [B, H, T, T]</span>
<span class="n">attention_scores</span> <span class="o">=</span> <span class="n">attention_scores</span><span class="o">.</span><span class="n">masked_fill</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">))</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">attention_scores</span>     <span class="c1"># [B, H, T, T]</span>

<span class="n">attention_weights</span> <span class="o">=</span> <span class="n">attention_scores</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>        <span class="c1"># [B, H, T, T]</span>
<span class="n">attention_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">attention_weights</span><span class="p">)</span>         <span class="c1"># [B, H, T, T]</span>

<span class="n">context_vector</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attention_weights</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>     <span class="c1"># [B, H, T, T] @ [B, H, T, d_v] = [B, H, T, d_v]</span>
</pre></div>
</div>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Line</strong></p></th>
<th class="head"><p><strong>Code</strong></p></th>
<th class="head"><p><strong>Operation Description</strong></p></th>
<th class="head"><p><strong>Input Shape</strong></p></th>
<th class="head"><p><strong>Output Shape</strong></p></th>
<th class="head"><p><strong>Notes</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>[1]</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">d_q</span> <span class="pre">=</span> <span class="pre">query.size(dim=-1)</span></code></p></td>
<td><p>Retrieves the dimension of the query vectors.</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times d_q\)</span></p></td>
<td><p>Scalar value</p></td>
<td><p>The last dimension of the query tensor represents the query vector dimension.</p></td>
</tr>
<tr class="row-odd"><td><p>[2]</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">attention_scores</span> <span class="pre">=</span> <span class="pre">torch.matmul(query,</span> <span class="pre">key.transpose(dim0=-2,</span> <span class="pre">dim1=-1))</span> <span class="pre">/</span> <span class="pre">torch.sqrt(torch.tensor(d_q).float())</span></code></p></td>
<td><p>Computes the scaled dot-product attention scores by matrix multiplying the query and key matrices and scaling by the square root of the query dimension.</p></td>
<td><p>Query: <span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times d_q\)</span><br>Key: <span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times d_k\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times T\)</span></p></td>
<td><p>The key matrix is transposed to align the dimensions for matrix multiplication. The scaling factor helps stabilize gradients during training.</p></td>
</tr>
<tr class="row-even"><td><p>[3]</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">attention_scores</span> <span class="pre">=</span> <span class="pre">attention_scores.masked_fill(mask</span> <span class="pre">==</span> <span class="pre">0,</span> <span class="pre">float(&quot;-inf&quot;))</span> <span class="pre">if</span> <span class="pre">mask</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span> <span class="pre">else</span> <span class="pre">attention_scores</span></code></p></td>
<td><p>Applies the attention mask to the attention scores. Positions where the mask is 0 are filled with <span class="math notranslate nohighlight">\(-\infty\)</span> to effectively block attention to those positions.</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times T\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times T\)</span></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">masked_fill</span></code> operation is an elementwise operation that replaces the attention scores at masked positions with <span class="math notranslate nohighlight">\(-\infty\)</span>. This step is skipped if no mask is provided.</p></td>
</tr>
<tr class="row-odd"><td><p>[4]</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">attention_weights</span> <span class="pre">=</span> <span class="pre">attention_scores.softmax(dim=-1)</span></code></p></td>
<td><p>Applies the softmax function to the masked attention scores along the last dimension to obtain the attention weights.</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times T\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times T\)</span></p></td>
<td><p>The softmax operation is applied in a vectorwise manner, independently for each row of the last two dimensions (<span class="math notranslate nohighlight">\(T \times T\)</span>) for each batch and head. This ensures that the attention weights for each token position across the sequence length sum up to 1.</p></td>
</tr>
<tr class="row-even"><td><p>[5]</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">attention_weights</span> <span class="pre">=</span> <span class="pre">self.dropout(attention_weights)</span></code></p></td>
<td><p>Applies dropout regularization to the attention weights to prevent overfitting.</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times T\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times T\)</span></p></td>
<td><p>Dropout randomly sets a fraction of the attention weights to zero during training, which helps improve generalization. This is element-wise operation.</p></td>
</tr>
<tr class="row-odd"><td><p>[6]</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">context_vector</span> <span class="pre">=</span> <span class="pre">torch.matmul(attention_weights,</span> <span class="pre">value)</span></code></p></td>
<td><p>Computes the context vector by matrix multiplying the attention weights with the value matrix.</p></td>
<td><p>Attention Weights: <span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times T\)</span><br>Value: <span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times d_v\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times d_v\)</span></p></td>
<td><p>The attention weights are used to weight the importance of each token‚Äôs value vector. The resulting context vector captures the attended information from the input sequence.</p></td>
</tr>
</tbody>
</table>
<div class="note admonition">
<p class="admonition-title">Step 7.4. Concatenation and Projection</p>
<p>Recall that the output from the masked multi-head self-attention operation,
denoted as <span class="math notranslate nohighlight">\(\mathbf{C}^{(\ell)}\)</span>, has a shape of
<span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times D//H\)</span>, where <span class="math notranslate nohighlight">\(\mathcal{B}\)</span> is the batch
size, <span class="math notranslate nohighlight">\(H\)</span> is the number of attention heads, <span class="math notranslate nohighlight">\(T\)</span> is the sequence length, and
<span class="math notranslate nohighlight">\(D//H\)</span> is the dimension of each head.</p>
<p>To concatenate the heads and obtain a tensor of shape
<span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span>, we first need to transpose the dimensions of
<span class="math notranslate nohighlight">\(\mathbf{C}^{(\ell)}\)</span> from <span class="math notranslate nohighlight">\(\mathcal{B} \times H \times T \times D//H\)</span> to
<span class="math notranslate nohighlight">\(\mathcal{B} \times T \times H \times D//H\)</span> - necessary to concatenate the heads
along the last dimension (feature dimension).</p>
<p>Using tensor index notation or semi einsum notation, we can denote the
transposition operation as follows:</p>
<div class="math notranslate nohighlight">
\[
\begin{aligned}
\mathbf{C}^{(\ell)}_{b,h,t,d} &amp; \rightarrow \mathbf{C}^{(\ell)}_{b,t,h,d} \quad \text{(transpose dimensions)}
\end{aligned}
\]</div>
<p>After transposition, the heads are concatenated along the last dimension
(feature dimension) to obtain a tensor of shape <span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span>.
The concatenation operation can be expressed using the direct sum notation as
follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{C}^{(\ell)}_{\text{concat}} &amp;= \bigoplus_{h=0}^{H-1} \mathbf{C}^{(\ell)}_{b,t,h,:} \\
&amp;= \mathbf{C}^{(\ell)}_{b,t,0,:} \oplus \mathbf{C}^{(\ell)}_{b,t,1,:} \oplus \cdots \oplus \mathbf{C}^{(\ell)}_{b,t,H-1,:} \\
&amp;= \operatorname{head}^{\ell}_1 \oplus \operatorname{head}^{\ell}_2 \oplus \cdots \oplus \operatorname{head}^{\ell}_H \\
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{C}^{(\ell)}_{b,t,h,:}\)</span> represents the tensor slice corresponding
to the <span class="math notranslate nohighlight">\(h\)</span>-th head at batch index <span class="math notranslate nohighlight">\(b\)</span> and time step <span class="math notranslate nohighlight">\(t\)</span>, and <span class="math notranslate nohighlight">\(\oplus\)</span> denotes
the concatenation operation along the feature dimension.</p>
<div class="dropdown admonition">
<p class="admonition-title">Direct Sum Notation Is Concatenation</p>
<p>In the concatenation of attention heads, the direct sum notation (<span class="math notranslate nohighlight">\(\oplus\)</span>) is
used to represent the concatenation operation, not elementwise addition. The
direct sum combines the output tensors from each attention head along a specific
dimension (usually the feature dimension). It is a vectorwise operation that
stacks the tensors along the specified dimension, creating a new tensor with an
increased dimension size.</p>
</div>
<p>The concatenation operation can be summarized as:</p>
<div class="math notranslate nohighlight">
\[
\begin{aligned}
\mathbf{C}^{(\ell)} &amp;\in \mathbb{R}^{\mathcal{B} \times T \times H \times D//H} \xrightarrow{\text{concatenate}} \mathbf{C}^{(\ell)}_{\text{concat}} \in \mathbb{R}^{\mathcal{B} \times T \times D}
\end{aligned}
\]</div>
<p>To summarize, the transposition and concatenation operations can be represented
as:</p>
<div class="math notranslate nohighlight">
\[
\begin{aligned}
\mathbf{C}^{(\ell)} &amp;\in \mathbb{R}^{\mathcal{B} \times H \times T \times D//H} \rightarrow \mathbf{C}^{(\ell)}  \in \mathbb{R}^{\mathcal{B} \times T \times H \times D//H} \rightarrow \mathbf{C}^{(\ell)}  \in \mathbb{R}^{\mathcal{B} \times T \times D}
\end{aligned}
\]</div>
<p>Finally, the concatenated tensor is linearly transformed using the projection
matrix <span class="math notranslate nohighlight">\(\mathbf{W}^{O, (\ell)}\)</span> to obtain the output <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_2\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{(\ell)}_2 &amp;= \mathbf{C}^{(\ell)}_{\text{concat}} \mathbf{W}^{O, (\ell)} \\
\mathcal{B} \times T \times D &amp;\leftarrow \mathcal{B} \times T \times D \operatorname{&#64;} D \times D \\
\mathcal{B} \times T \times D &amp;\leftarrow \mathcal{B} \times T \times D
\end{aligned}
\end{split}\]</div>
<p>In code, these operations can be implemented as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">context_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">context_vector</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">dim0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>  <span class="c1"># merge all heads together</span>

<span class="n">projected_context_vector</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid_dropout</span><span class="p">(</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">context_projection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context_vector</span><span class="p">)</span>  <span class="c1"># [B, T, D] @ [D, D] = [B, T, D]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>To this end, for layer <span class="math notranslate nohighlight">\(\ell=1\)</span>, we would have the output tensor
<span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_2\)</span> - which becomes the input to the next sub-layer within the
same block <span class="math notranslate nohighlight">\(\ell\)</span>. Optionally, we can apply a projection dropout to the output
tensor <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_2\)</span> before passing it to the next sub-layer.</p>
</div>
<div class="note admonition">
<p class="admonition-title">Step 8. Residual Connection</p>
<p>In the Transformer/GPT architecture, residual connections are used to facilitate
the flow of information and gradients throughout the network. The residual
connection in the decoder block is added between the input to the block and the
output of the Masked Multi-Head Attention layer.</p>
<p>For the first decoder block (<span class="math notranslate nohighlight">\(\ell = 1\)</span>), the residual connection is added
between the positionally encoded embeddings <span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span> and the output
of the Masked Multi-Head Attention layer <span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_2\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{(1)}_{3} &amp;= \tilde{\mathbf{X}} + \text{MaskedMultiHead}^{(1)}\left(\text{LayerNorm}\left(\tilde{\mathbf{X}}\right), \text{LayerNorm}\left(\tilde{\mathbf{X}}\right), \text{LayerNorm}\left(\tilde{\mathbf{X}}\right)\right) \\
&amp;= \tilde{\mathbf{X}} + \text{MaskedMultiHead}^{(1)}\left(\mathbf{Z}^{(1)}_{1}, \mathbf{Z}^{(1)}_{1}, \mathbf{Z}^{(1)}_{1}\right) \\
&amp;= \tilde{\mathbf{X}} + \mathbf{Z}^{(1)}_{2} \\
\mathcal{B} \times T \times D &amp;\leftarrow \mathcal{B} \times T \times D + \mathcal{B} \times T \times D
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_{3}\)</span> represents the output of the residual connection
for the first decoder block, <span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span> is the positionally encoded
embeddings, and <span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_{2}\)</span> is the output of the Masked Multi-Head
Attention layer.</p>
<p>For subsequent decoder blocks (<span class="math notranslate nohighlight">\(\ell &gt; 1\)</span>), the residual connection is added
between the output of the previous decoder block
<span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell-1)}_{\text{out}}\)</span> and the output of the Masked Multi-Head
Attention layer <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_2\)</span> of the current block:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{Z}^{(\ell)}_3 = \mathbf{Z}^{(\ell-1)}_{\text{out}} + \mathbf{Z}^{(\ell)}_2
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_3\)</span> represents the output of the residual connection
for the <span class="math notranslate nohighlight">\(\ell\)</span>-th decoder block, <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell-1)}_{\text{out}}\)</span> is the
output of the previous decoder block after the Position-wise Feed-Forward
Network and the second residual connection, and <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_2\)</span> is the
output of the Masked Multi-Head Attention layer of the current block.</p>
<p>The complete set of equations for the <span class="math notranslate nohighlight">\(\ell\)</span>-th decoder block (<span class="math notranslate nohighlight">\(\ell &gt; 1\)</span>) can
be summarized as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{(\ell)}_1 &amp;= \text{LayerNorm}\left(\mathbf{Z}^{(\ell-1)}_{\text{out}}\right) \\
\mathbf{Z}^{(\ell)}_2 &amp;= \text{MaskedMultiHead}^{(\ell)}\left(\mathbf{Z}^{(\ell)}_1, \mathbf{Z}^{(\ell)}_1, \mathbf{Z}^{(\ell)}_1\right) \\
\mathbf{Z}^{(\ell)}_3 &amp;= \mathbf{Z}^{(\ell-1)}_{\text{out}} + \mathbf{Z}^{(\ell)}_2
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1\)</span> represents the output of the Layer Normalization
step, <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_2\)</span> represents the output of the Masked Multi-Head
Attention layer, and <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_3\)</span> represents the output of the
residual connection.</p>
<p>The residual connection allows the model to learn the identity function more
easily, enabling the flow of information and gradients across multiple layers.
By adding the input of the block to the output of the Masked Multi-Head
Attention layer, the model can choose to either learn new information from the
attention mechanism or retain the original input information if it is already
sufficient.</p>
<p>In code, the whole series of operation up till now is simply:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attn</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_1</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="note admonition">
<p class="admonition-title">Step 9. Pre-Layer Normalization For Position-wise Feed-Forward Network</p>
<p>After the masked multi-head attention block and the residual connection, the
next step is to apply the position-wise feed-forward network (FFN) to the output
of the self-attention mechanism and the residual block <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_3\)</span>.
However, before applying the FFN, we perform pre-layer normalization on the
input to the FFN.</p>
<p>Mathematically, the pre-layer normalization step for the FFN can be expressed
as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{(\ell)}_4 &amp;= \operatorname{LayerNorm}\left(\mathbf{Z}^{(\ell)}_3\right) \\
\mathcal{B} \times T \times D &amp;\leftarrow \operatorname{LayerNorm}\left(\mathcal{B} \times T \times D\right) \\
\mathcal{B} \times T \times D &amp;\leftarrow \mathcal{B} \times T \times D
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_4\)</span> represents the normalized input to the FFN at
layer <span class="math notranslate nohighlight">\(\ell\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_3\)</span> is the output of the residual
connection from the previous step.</p>
<p>As discussed in Step 6, the Layer Normalization function
<span class="math notranslate nohighlight">\(\operatorname{LayerNorm}(\cdot)\)</span> is a vectorwise operation that operates on the
feature dimension <span class="math notranslate nohighlight">\(D\)</span> of the input tensor. It normalizes the activations to have
zero mean and unit variance across the features for each token independently.
It‚Äôs important to note that the pre-layer normalization step is applied
independently to each token
<span class="math notranslate nohighlight">\(\mathbf{Z}_{3, t}^{(\ell)} \in \mathbf{Z}_3^{(\ell)}\)</span> in the sequence with
shape <span class="math notranslate nohighlight">\(T \times D\)</span>, where <span class="math notranslate nohighlight">\(T\)</span> is the sequence length and <span class="math notranslate nohighlight">\(D\)</span> is the feature
dimension, normalizing the features across the feature dimension <span class="math notranslate nohighlight">\(D\)</span>.</p>
<p>For the first layer (<span class="math notranslate nohighlight">\(\ell = 1\)</span>), the pre-layer normalization step can be
written as:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{Z}^{(1)}_4 = \operatorname{LayerNorm}\left(\mathbf{Z}^{(1)}_3\right)
\]</div>
</div>
<div class="note admonition">
<p class="admonition-title">Step 10. Position-wise Feed-Forward Network</p>
<p>Given the normalized input <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_4\)</span> to the Position-wise
Feed-Forward Network (FFN) in layer <span class="math notranslate nohighlight">\(\ell\)</span>, the FFN applies two linear
transformations with a GELU activation function in between. The operations
within the FFN can be mathematically represented as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{FF, (\ell)}_1 &amp;= \text{GELU}\left(\mathbf{Z}^{(\ell)}_4 \mathbf{W}^{FF, (\ell)}_1 + \mathbf{b}^{FF, (\ell)}_1\right) \\
\mathcal{B} \times T \times d_{\text{ff}} &amp;\leftarrow \text{GELU}\left(\mathcal{B} \times T \times D \operatorname{&#64;} D \times d_{\text{ff}} + d_{\text{ff}}\right) \\
\mathcal{B} \times T \times d_{\text{ff}} &amp;\leftarrow \mathcal{B} \times T \times d_{\text{ff}} \\
\mathbf{Z}^{(\ell)}_5 &amp;= \mathbf{Z}^{FF, (\ell)}_1 \mathbf{W}^{FF, (\ell)}_2 + \mathbf{b}^{FF, (\ell)}_2 \\
\mathcal{B} \times T \times D &amp;\leftarrow \mathcal{B} \times T \times d_{\text{ff}} \operatorname{&#64;} d_{\text{ff}} \times D + D \\
\mathcal{B} \times T \times D &amp;\leftarrow \mathcal{B} \times T \times D
\end{aligned}
\end{split}\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{W}^{FF, (\ell)}_1 \in \mathbb{R}^{D \times d_{\text{ff}}}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{b}^{FF, (\ell)}_1 \in \mathbb{R}^{d_{\text{ff}}}\)</span> are the weights
and biases of the first linear transformation, respectively.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{W}^{FF, (\ell)}_2 \in \mathbb{R}^{d_{\text{ff}} \times D}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{b}^{FF, (\ell)}_2 \in \mathbb{R}^{D}\)</span> are the weights and biases of
the second linear transformation, respectively.</p></li>
<li><p><span class="math notranslate nohighlight">\(d_{\text{ff}}\)</span> is the dimensionality of the hidden layer in the FFN, which
is typically larger than the input dimensionality <span class="math notranslate nohighlight">\(D\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\operatorname{GELU}(\cdot)\)</span> denotes the Gaussian Error Linear Unit
activation function.</p></li>
</ul>
<p>Note the slight abuse of notation where <span class="math notranslate nohighlight">\(\mathbf{Z}^{FF, (\ell)}_1\)</span> is used to
denote the intermediate output of the first linear transformation in the FFN.
This should not be confused with the earlier notation <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1\)</span>.</p>
<p>For the first layer (<span class="math notranslate nohighlight">\(\ell = 1\)</span>), the FFN operations can be written as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{FF, (1)}_1 &amp;= \operatorname{GELU}\left(\mathbf{Z}^{(1)}_4 \mathbf{W}^{FF, (1)}_1 + \mathbf{b}^{FF, (1)}_1\right) \\
\mathbf{Z}^{(1)}_5 &amp;= \mathbf{Z}^{FF, (1)}_1 \mathbf{W}^{FF, (1)}_2 + \mathbf{b}^{FF, (1)}_2
\end{aligned}
\end{split}\]</div>
</div>
<div class="note admonition">
<p class="admonition-title">Step 11. Residual Connection</p>
<p>Given the output <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_5\)</span> from the feed-forward network in layer
<span class="math notranslate nohighlight">\(\ell\)</span>, we apply a residual connection followed by layer normalization:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_2</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
</pre></div>
</div>
<p>Mathematically, this is represented as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{(\ell)}_6 &amp;= \text{LayerNorm}\left(\mathbf{Z}^{(\ell)}_3 + \mathbf{Z}^{(\ell)}_5\right) \\
\mathcal{B} \times T \times D &amp;\leftarrow \text{LayerNorm}\left(\mathcal{B} \times T \times D + \mathcal{B} \times T \times D\right) \\
\mathcal{B} \times T \times D &amp;\leftarrow \mathcal{B} \times T \times D
\end{aligned}
\end{split}\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_3\)</span> is the input to the feed-forward network that was
initially passed through layer normalization at the beginning of this
layer‚Äôs computation cycle.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_5\)</span> is the output from the position-wise feed-forward
network.</p></li>
<li><p>The output of this step, <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_6\)</span>, becomes the input to the
next decoder block.</p></li>
</ul>
<p>So in our case, we are at <span class="math notranslate nohighlight">\(\ell=1\)</span>, so we have:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{Z}^{(1)}_6 = \text{LayerNorm}\left(\mathbf{Z}^{(1)}_3 + \mathbf{Z}^{(1)}_5\right)
\]</div>
</div>
</section>
<section id="iterative-process-through-l-decoder-blocks">
<h3><a class="toc-backref" href="#id44" role="doc-backlink">Iterative Process Through L Decoder Blocks</a><a class="headerlink" href="#iterative-process-through-l-decoder-blocks" title="Link to this heading">#</a></h3>
<p>Now <span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_6\)</span> becomes the input to the next decoder block and so on.
More concretely, the operation of each decoder block can be described through a
series of mathematical transformations, where each block builds upon the output
of the previous block. The subscript notation <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_i\)</span> indicates
the i-th step output of the <span class="math notranslate nohighlight">\(\ell\)</span>-th decoder block.</p>
<section id="for-the-first-decoder-block-ell-1">
<h4><a class="toc-backref" href="#id45" role="doc-backlink">For the First Decoder Block (<span class="math notranslate nohighlight">\(\ell = 1\)</span>)</a><a class="headerlink" href="#for-the-first-decoder-block-ell-1" title="Link to this heading">#</a></h4>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{(1)}_1 &amp;= \text{LayerNorm}\left(\tilde{\mathbf{X}}\right) &amp; \text{(Initial normalization of inputs)} \\
\mathbf{Z}^{(1)}_2 &amp;= \text{MaskedMultiHead}\left(\mathbf{Z}^{(1)}_1, \mathbf{Z}^{(1)}_1, \mathbf{Z}^{(1)}_1\right) &amp; \text{(Self-attention mechanism)} \\
\mathbf{Z}^{(1)}_3 &amp;= \tilde{\mathbf{X}} + \mathbf{Z}^{(1)}_2 &amp; \text{(Addition of the first residual connection)} \\
\mathbf{Z}^{(1)}_4 &amp;= \text{LayerNorm}\left(\mathbf{Z}^{(1)}_3\right) &amp; \text{(Normalization before FFN)}\\
\mathbf{Z}^{(1)}_5 &amp;= \text{FFN}\left(\mathbf{Z}^{(1)}_4\right) &amp; \text{(Feed-forward network)}\\
\mathbf{Z}^{(1)}_6 &amp;= \mathbf{Z}^{(1)}_3 + \mathbf{Z}^{(1)}_5 &amp; \text{(Second residual connection)}
\end{aligned}
\end{split}\]</div>
</section>
</section>
<section id="for-subsequent-blocks-ell-1">
<h3><a class="toc-backref" href="#id46" role="doc-backlink">For Subsequent Blocks (<span class="math notranslate nohighlight">\(\ell &gt; 1\)</span>)</a><a class="headerlink" href="#for-subsequent-blocks-ell-1" title="Link to this heading">#</a></h3>
<p>Each subsequent block <span class="math notranslate nohighlight">\(\ell\)</span> uses the output of the previous block‚Äôs final
output <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell-1)}_6\)</span> as the input for its operations.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{(\ell)}_1 &amp;= \text{LayerNorm}\left(\mathbf{Z}^{(\ell-1)}_6\right) &amp; \text{(Normalization of previous block's output)} \\
\mathbf{Z}^{(\ell)}_2 &amp;= \text{MaskedMultiHead}\left(\mathbf{Z}^{(\ell)}_1, \mathbf{Z}^{(\ell)}_1, \mathbf{Z}^{(\ell)}_1\right) &amp; \text{(Self-attention mechanism)} \\
\mathbf{Z}^{(\ell)}_3 &amp;= \mathbf{Z}^{(\ell)}_1 + \mathbf{Z}^{(\ell)}_2 &amp; \text{(First residual connection post self-attention)} \\
\mathbf{Z}^{(\ell)}_4 &amp;= \text{LayerNorm}\left(\mathbf{Z}^{(\ell)}_3\right) &amp; \text{(Normalization before FFN)}\\
\mathbf{Z}^{(\ell)}_5 &amp;= \text{FFN}\left(\mathbf{Z}^{(\ell)}_4\right) &amp; \text{(Feed-forward network)}\\
\mathbf{Z}^{(\ell)}_6 &amp;= \mathbf{Z}^{(\ell)}_3 + \mathbf{Z}^{(\ell)}_5 &amp; \text{(Second residual connection post FFN)}
\end{aligned}
\end{split}\]</div>
<p>Finally, after going through the decoder blocks a total number of <span class="math notranslate nohighlight">\(L\)</span> times, the
final output we get now is <span class="math notranslate nohighlight">\(\mathbf{Z}^{(L)}_6\)</span> which is the output of the last
decoder block of shape <span class="math notranslate nohighlight">\(\mathcal{B} \times T \times D\)</span>. We need to apply one
more layer normalization to this output to get the final output before
projection to the vocabulary space.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone</span><span class="o">.</span><span class="n">ln_final</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>  <span class="c1"># [B, T, D]</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">Step 10. Layer Normalization Before Projection</p>
<p>The final output of the decoder block <span class="math notranslate nohighlight">\(\mathbf{Z}^{(L)}_6\)</span> is passed through a
layer normalization before being projected to the vocabulary space.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z}^{(L)}_7 &amp;= \text{LayerNorm}\left(\mathbf{Z}^{(L)}_6\right) \\
\mathcal{B} \times T \times D &amp;\leftarrow \text{LayerNorm}\left(\mathcal{B} \times T \times D\right) \\
\mathcal{B} \times T \times D &amp;\leftarrow \mathcal{B} \times T \times D
\end{aligned}
\end{split}\]</div>
</div>
</section>
<section id="head">
<h3><a class="toc-backref" href="#id47" role="doc-backlink">Head</a><a class="headerlink" href="#head" title="Link to this heading">#</a></h3>
<p>We denote the weight of the last projection layer as <span class="math notranslate nohighlight">\(\mathbf{W}_{s}\)</span> where <span class="math notranslate nohighlight">\(s\)</span>
indicates the softmax layer, essentially projecting the output of the last layer
to the vocabulary space.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span>
    <span class="n">in_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_model</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab_size</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">bias</span>
<span class="p">)</span>
<span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>  <span class="c1"># [B, T, V]</span>
</pre></div>
</div>
<p>We have:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{Z} &amp;= \mathbf{Z}^{(L)}_7 \mathbf{W}_{s} \\
\mathcal{B} \times T \times V &amp;\leftarrow \mathcal{B} \times T \times D \operatorname{&#64;} D \times V \\
\mathcal{B} \times T \times V &amp;\leftarrow \mathcal{B} \times T \times V
\end{aligned}
\end{split}\]</div>
<p>This is the logits <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> of shape <span class="math notranslate nohighlight">\(\mathcal{B} \times T \times V\)</span> where
<span class="math notranslate nohighlight">\(V\)</span> is the size of the vocabulary.</p>
</section>
</section>
<section id="table">
<h2><a class="toc-backref" href="#id48" role="doc-backlink">Table</a><a class="headerlink" href="#table" title="Link to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Matrix Description</p></th>
<th class="head"><p>Symbol</p></th>
<th class="head"><p>Dimensions</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>One-Hot Encoded Input Matrix</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{X}^{\text{ohe}}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times V\)</span></p></td>
<td><p>Each row corresponds to a one-hot encoded vector representing a token in the sequence.</p></td>
</tr>
<tr class="row-odd"><td><p>Embedding Matrix</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}_e\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(V \times D\)</span></p></td>
<td><p>Each row is the embedding vector of the corresponding token in the vocabulary.</p></td>
</tr>
<tr class="row-even"><td><p>Embedded Input Matrix</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>Each row is the embedding vector of the corresponding token in the input sequence.</p></td>
</tr>
<tr class="row-odd"><td><p>Embedding Vector for Token <span class="math notranslate nohighlight">\(t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{X}_t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(1 \times D\)</span></p></td>
<td><p>The embedding vector for the token at position <span class="math notranslate nohighlight">\(t\)</span> in the input sequence.</p></td>
</tr>
<tr class="row-even"><td><p>Batched Input Tensor</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{X}^{\mathcal{B}}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>A batched tensor containing <span class="math notranslate nohighlight">\(B\)</span> input sequences, each sequence is of shape <span class="math notranslate nohighlight">\(T \times D\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p>Positional Encoding Matrix</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{W}_{p}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>Matrix with positional encoding vectors for each position in the sequence, computed using sinusoidal functions.</p></td>
</tr>
<tr class="row-even"><td><p>Output of Positional Encoding Layer</p></td>
<td><p><span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>The resultant embeddings matrix after adding positional encoding <span class="math notranslate nohighlight">\(\mathbf{W}_{p}\)</span> to the embedded input matrix <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>. Each row now includes positional information.</p></td>
</tr>
<tr class="row-odd"><td><p>Embedding Vector for Token <span class="math notranslate nohighlight">\(t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}_t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(1 \times D\)</span></p></td>
<td><p>The token and positional embedding vector for the token at position <span class="math notranslate nohighlight">\(t\)</span> in the input sequence.</p></td>
</tr>
<tr class="row-even"><td><p>Batched Input Tensor</p></td>
<td><p><span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}^{\mathcal{B}}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>A batched tensor containing <span class="math notranslate nohighlight">\(B\)</span> input sequences, each sequence is of shape <span class="math notranslate nohighlight">\(T \times D\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p>Batched Embedding Matrix Sequence <span class="math notranslate nohighlight">\(b\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{X}^{(b)}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T \times D\)</span></p></td>
<td><p>The token and positional embedding vector for the <span class="math notranslate nohighlight">\(b\)</span>-th input sequence of the batch.</p></td>
</tr>
<tr class="row-even"><td><p>Batched Embedding Vector for Token <span class="math notranslate nohighlight">\(t\)</span> in Sequence <span class="math notranslate nohighlight">\(b\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{X}^{(b)}_t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(1 \times D\)</span></p></td>
<td><p>The token and positional embedding vector for the token at position <span class="math notranslate nohighlight">\(t\)</span> in the <span class="math notranslate nohighlight">\(b\)</span>-th input sequence of the batch.</p></td>
</tr>
<tr class="row-odd"><td><p>First Layer Normalized Input</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>The output of the initial layer normalization applied to <span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}^{\mathcal{B}}\)</span>, serving as the input to the first decoder block‚Äôs self-attention mechanism.</p></td>
</tr>
<tr class="row-even"><td><p>First Self-Attention Output</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>Output from the first block‚Äôs self-attention mechanism; processes <span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_1\)</span> with respect to itself to refine token representations.</p></td>
</tr>
<tr class="row-odd"><td><p>Output After First Residual Connection</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_3\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>Resultant tensor after adding the self-attention outputs back to the initial normalized inputs (<span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_1\)</span>), i.e., the input to the first feed-forward network.</p></td>
</tr>
<tr class="row-even"><td><p>Normalized Before Feed-Forward Network (FFN)</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_4\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>Output of applying layer normalization to <span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_3\)</span>, prepping it for processing through the FFN.</p></td>
</tr>
<tr class="row-odd"><td><p>Output of First Feed-Forward Network</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_5\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>The result of applying the first FFN to <span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_4\)</span>, which involves two linear transformations and a non-linear activation (typically GELU).</p></td>
</tr>
<tr class="row-even"><td><p>Output After Second Residual Connection</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_6\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>Final output of the first decoder block, which is the sum of <span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_3\)</span> and <span class="math notranslate nohighlight">\(\mathbf{Z}^{(1)}_5\)</span>. This output is used as the input to the next decoder block (<span class="math notranslate nohighlight">\(\ell = 2\)</span>).</p></td>
</tr>
<tr class="row-odd"><td><p>Subsequent Block Input (Normalized)</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>For <span class="math notranslate nohighlight">\(\ell &gt; 1\)</span>, <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1\)</span> is the layer normalized output of <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell-1)}_6\)</span>, serving as the input to the self-attention of block <span class="math notranslate nohighlight">\(\ell\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p>Subsequent Self-Attention Output</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>Self-attention output for block <span class="math notranslate nohighlight">\(\ell\)</span>, refining the input based on the learned attention mechanisms within the block.</p></td>
</tr>
<tr class="row-odd"><td><p>Output After First Residual Connection (Block <span class="math notranslate nohighlight">\(\ell\)</span>)</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_3\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>Resultant tensor after adding the self-attention output (<span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_2\)</span>) to the normalized input from the previous block‚Äôs output (<span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_1\)</span>).</p></td>
</tr>
<tr class="row-even"><td><p>Normalized Before FFN (Block <span class="math notranslate nohighlight">\(\ell\)</span>)</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_4\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>Output from applying layer normalization to <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_3\)</span>, which is the input to the FFN of block <span class="math notranslate nohighlight">\(\ell\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p>Output of FFN (Block <span class="math notranslate nohighlight">\(\ell\)</span>)</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_5\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>Output from the FFN for block <span class="math notranslate nohighlight">\(\ell\)</span>, which includes non-linear processing through two layers of linear transformations and GELU activation.</p></td>
</tr>
<tr class="row-even"><td><p>Output After Second Residual Connection (Block <span class="math notranslate nohighlight">\(\ell\)</span>)</p></td>
<td><p><span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_6\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(B \times T \times D\)</span></p></td>
<td><p>Final output of block <span class="math notranslate nohighlight">\(\ell\)</span>, being the addition of <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_3\)</span> and <span class="math notranslate nohighlight">\(\mathbf{Z}^{(\ell)}_5\)</span>. This output is used as the input to the next block or as the final output.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="references">
<h2><a class="toc-backref" href="#id49" role="doc-backlink">References</a><a class="headerlink" href="#references" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://lilianweng.github.io/posts/2023-01-27-the-transformer-family-v2/">The Transformer Family v2.0 - Lilian Weng, OpenAI</a></p></li>
<li><p><a class="reference external" href="https://leimao.github.io/blog/Transformer-Explained/">Transformer Explained - Lei Mao, NVIDIA</a></p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./transformer/decoder"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="intro.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Generative Pre-trained Transformers</p>
      </div>
    </a>
    <a class="right-next"
       href="concept.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">The Concept of Generative Pre-trained Transformers (GPT)</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dimensions-and-indexing">Dimensions and Indexing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#general-notations">General Notations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#elementwise-and-vectorwise-operations">Elementwise and Vectorwise Operations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vocabulary">Vocabulary</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#input-sequence">Input Sequence</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#batched-input-sequences">Batched Input Sequences</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#token-to-index-and-index-to-token-mappings">Token to Index, and Index to Token Mappings</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#string-to-index-mapping">String-to-Index Mapping</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#index-to-string-mapping">Index-to-String Mapping</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#one-hot-representation-of-input-sequence-mathbf-x">One-Hot Representation of Input Sequence <span class="math notranslate nohighlight">\(\mathbf{x}\)</span></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#definition">Definition</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#one-hot-encoding-process">One-Hot Encoding Process</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#batched">Batched</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#weights-and-embeddings">Weights And Embeddings</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matrix-multiplication-primer">Matrix Multiplication Primer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mathbf-x-output-of-the-embedding-layer"><span class="math notranslate nohighlight">\(\mathbf{X}\)</span>: Output of the Embedding Layer</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Definition</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lookup">Lookup</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#semantic-representation">Semantic Representation</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mathbf-w-e-embedding-matrix"><span class="math notranslate nohighlight">\(\mathbf{W}_{e}\)</span>: Embedding Matrix</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pe-positional-encoding-layer"><span class="math notranslate nohighlight">\(PE\)</span>: Positional Encoding Layer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tilde-mathbf-x-output-of-the-positional-encoding-layer"><span class="math notranslate nohighlight">\(\tilde{\mathbf{X}}\)</span>: Output of the Positional Encoding Layer</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#layer-normalization">Layer Normalization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#attention-notations">Attention Notations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dimensions">Dimensions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#query-key-and-values">Query, Key and Values</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#general-attention-mechanism">General Attention Mechanism</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-head-attention-for-layer-ell">Multi-Head Attention for Layer <span class="math notranslate nohighlight">\(\ell\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#masked-multi-head-attention-for-decoder-layer-ell">Masked Multi-Head Attention for Decoder Layer <span class="math notranslate nohighlight">\(\ell\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#updated-matrix-description-table-with-batch-and-head-dimensions">Updated Matrix Description Table with Batch and Head Dimensions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#positionwise-feed-forward-networks">Positionwise Feed-Forward Networks</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#independent-processing">Independent Processing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#identical-application">Identical Application</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Definition</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#projection-to-a-higher-dimension-space">Projection to a Higher Dimension Space</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gaussian-error-linear-unit-gelu">Gaussian Error Linear Unit (GELU)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-full-workflow">The Full Workflow</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#autoregressive-self-supervised-learning-paradigm">Autoregressive Self-Supervised Learning Paradigm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#steps">Steps</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iterative-process-through-l-decoder-blocks">Iterative Process Through L Decoder Blocks</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#for-the-first-decoder-block-ell-1">For the First Decoder Block (<span class="math notranslate nohighlight">\(\ell = 1\)</span>)</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#for-subsequent-blocks-ell-1">For Subsequent Blocks (<span class="math notranslate nohighlight">\(\ell &gt; 1\)</span>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#head">Head</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#table">Table</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Gao Hongnan
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      ¬© Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>